function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly &&
        (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })),
        keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2
        ? ownKeys(Object(source), !0).forEach(function (key) {
            _defineProperty2(target, key, source[key]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source)
          )
        : ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key)
            );
          });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _slicedToArray(arr, i) {
    return (
      _arrayWithHoles(arr) ||
      _iterableToArrayLimit(arr, i) ||
      _unsupportedIterableToArray(arr, i) ||
      _nonIterableRest()
    );
  }
  function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  function _iterableToArrayLimit(arr, i) {
    var _i =
      arr == null
        ? null
        : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
          arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: { value: subClass, writable: true, configurable: true }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof2(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError(
        "Derived constructors may only return object or undefined"
      );
    }
    return _assertThisInitialized(self);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    }
    return self;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      );
      return true;
    } catch (e) {
      return false;
    }
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
  function _toConsumableArray(arr) {
    return (
      _arrayWithoutHoles(arr) ||
      _iterableToArray(arr) ||
      _unsupportedIterableToArray(arr) ||
      _nonIterableSpread()
    );
  }
  function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  function _iterableToArray(iter) {
    if (
      (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
      iter["@@iterator"] != null
    )
      return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it =
      (typeof Symbol !== "undefined" && o[Symbol.iterator]) || o["@@iterator"];
    if (!it) {
      if (
        Array.isArray(o) ||
        (it = _unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function F() {};
        return {
          s: F,
          n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function e(_e2) {
            throw _e2;
          },
          f: F
        };
      }
      throw new TypeError(
        "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e3) {
        didErr = true;
        err = _e3;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return (
      (_typeof2 =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                "function" == typeof Symbol &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            }),
      _typeof2(obj)
    );
  }
  (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw ((a.code = "MODULE_NOT_FOUND"), a);
          }
          var p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t
          );
        }
        return n[i].exports;
      }
      for (
        var u = "function" == typeof require && require, i = 0;
        i < t.length;
        i++
      ) {
        o(t[i]);
      }
      return o;
    }
    return r;
  })()(
    {
      1: [
        function (require, module, exports) {
          "use strict";
          var $Ref = require("./ref");
          var Pointer = require("./pointer");
          var url = require("./util/url");
          module.exports = bundle;
          /**
           * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that
           * only has *internal* references, not any *external* references.
           * This method mutates the JSON schema object, adding new references and re-mapping existing ones.
           *
           * @param {$RefParser} parser
           * @param {$RefParserOptions} options
           */ function bundle(parser, options) {
            // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);
            // Build an inventory of all $ref pointers in the JSON Schema
            var inventory = [];
            crawl(
              parser,
              "schema",
              parser.$refs._root$Ref.path + "#",
              "#",
              0,
              inventory,
              parser.$refs,
              options
            ); // Remap all $ref pointers
            remap(inventory);
          }
          /**
           * Recursively crawls the given value, and inventories all JSON references.
           *
           * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.
           * @param {string} key - The property key of `parent` to be crawled
           * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash
           * @param {string} pathFromRoot - The path of the property being crawled, from the schema root
           * @param {object[]} inventory - An array of already-inventoried $ref pointers
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           */ function crawl(
            parent,
            key,
            path,
            pathFromRoot,
            indirections,
            inventory,
            $refs,
            options
          ) {
            var obj = key === null ? parent : parent[key];
            if (obj && _typeof2(obj) === "object" && !ArrayBuffer.isView(obj)) {
              if ($Ref.isAllowed$Ref(obj)) {
                inventory$Ref(
                  parent,
                  key,
                  path,
                  pathFromRoot,
                  indirections,
                  inventory,
                  $refs,
                  options
                );
              } else {
                // Crawl the object in a specific order that's optimized for bundling.
                // This is important because it determines how `pathFromRoot` gets built,
                // which later determines which keys get dereferenced and which ones get remapped
                var keys = Object.keys(obj).sort(function (a, b) {
                  // Most people will expect references to be bundled into the the "definitions" property,
                  // so we always crawl that property first, if it exists.
                  if (a === "definitions") {
                    return -1;
                  } else if (b === "definitions") {
                    return 1;
                  } else {
                    // Otherwise, crawl the keys based on their length.
                    // This produces the shortest possible bundled references
                    return a.length - b.length;
                  }
                }); // eslint-disable-next-line no-shadow
                var _iterator4 = _createForOfIteratorHelper(keys),
                  _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                    var _key2 = _step4.value;
                    var keyPath = Pointer.join(path, _key2);
                    var keyPathFromRoot = Pointer.join(pathFromRoot, _key2);
                    var value = obj[_key2];
                    if ($Ref.isAllowed$Ref(value)) {
                      inventory$Ref(
                        obj,
                        _key2,
                        path,
                        keyPathFromRoot,
                        indirections,
                        inventory,
                        $refs,
                        options
                      );
                    } else {
                      crawl(
                        obj,
                        _key2,
                        keyPath,
                        keyPathFromRoot,
                        indirections,
                        inventory,
                        $refs,
                        options
                      );
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            }
          }
          /**
           * Inventories the given JSON Reference (i.e. records detailed information about it so we can
           * optimize all $refs in the schema), and then crawls the resolved value.
           *
           * @param {object} $refParent - The object that contains a JSON Reference as one of its keys
           * @param {string} $refKey - The key in `$refParent` that is a JSON Reference
           * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash
           * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root
           * @param {object[]} inventory - An array of already-inventoried $ref pointers
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           */ function inventory$Ref(
            $refParent,
            $refKey,
            path,
            pathFromRoot,
            indirections,
            inventory,
            $refs,
            options
          ) {
            var $ref = $refKey === null ? $refParent : $refParent[$refKey];
            var $refPath = url.resolve(path, $ref.$ref);
            var pointer = $refs._resolve($refPath, pathFromRoot, options);
            if (pointer === null) {
              return;
            }
            var depth = Pointer.parse(pathFromRoot).length;
            var file = url.stripHash(pointer.path);
            var hash = url.getHash(pointer.path);
            var external = file !== $refs._root$Ref.path;
            var extended = $Ref.isExtended$Ref($ref);
            indirections += pointer.indirections;
            var existingEntry = findInInventory(inventory, $refParent, $refKey);
            if (existingEntry) {
              // This $Ref has already been inventoried, so we don't need to process it again
              if (
                depth < existingEntry.depth ||
                indirections < existingEntry.indirections
              ) {
                removeFromInventory(inventory, existingEntry);
              } else {
                return;
              }
            }
            inventory.push({
              $ref: $ref, // The JSON Reference (e.g. {$ref: string})
              parent: $refParent, // The object that contains this $ref pointer
              key: $refKey, // The key in `parent` that is the $ref pointer
              pathFromRoot: pathFromRoot, // The path to the $ref pointer, from the JSON Schema root
              depth: depth, // How far from the JSON Schema root is this $ref pointer?
              file: file, // The file that the $ref pointer resolves to
              hash: hash, // The hash within `file` that the $ref pointer resolves to
              value: pointer.value, // The resolved value of the $ref pointer
              circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
              extended: extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
              external: external, // Does this $ref pointer point to a file other than the main JSON Schema file?
              indirections: indirections // The number of indirect references that were traversed to resolve the value
            }); // Recursively crawl the resolved value
            if (!existingEntry) {
              crawl(
                pointer.value,
                null,
                pointer.path,
                pathFromRoot,
                indirections + 1,
                inventory,
                $refs,
                options
              );
            }
          }
          /**
           * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.
           * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same
           * value are re-mapped to point to the first reference.
           *
           * @example:
           *  {
           *    first: { $ref: somefile.json#/some/part },
           *    second: { $ref: somefile.json#/another/part },
           *    third: { $ref: somefile.json },
           *    fourth: { $ref: somefile.json#/some/part/sub/part }
           *  }
           *
           * In this example, there are four references to the same file, but since the third reference points
           * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be
           * remapped to point inside the third one.
           *
           * On the other hand, if the third reference DIDN'T exist, then the first and second would both need
           * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT
           * need to be dereferenced, because it can be remapped to point inside the first one.
           *
           * @param {object[]} inventory
           */ function remap(inventory) {
            // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them
            inventory.sort(function (a, b) {
              if (a.file !== b.file) {
                // Group all the $refs that point to the same file
                return a.file < b.file ? -1 : +1;
              } else if (a.hash !== b.hash) {
                // Group all the $refs that point to the same part of the file
                return a.hash < b.hash ? -1 : +1;
              } else if (a.circular !== b.circular) {
                // If the $ref points to itself, then sort it higher than other $refs that point to this $ref
                return a.circular ? -1 : +1;
              } else if (a.extended !== b.extended) {
                // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value
                return a.extended ? +1 : -1;
              } else if (a.indirections !== b.indirections) {
                // Sort direct references higher than indirect references
                return a.indirections - b.indirections;
              } else if (a.depth !== b.depth) {
                // Sort $refs by how close they are to the JSON Schema root
                return a.depth - b.depth;
              } else {
                // Determine how far each $ref is from the "definitions" property.
                // Most people will expect references to be bundled into the the "definitions" property if possible.
                var aDefinitionsIndex =
                  a.pathFromRoot.lastIndexOf("/definitions");
                var bDefinitionsIndex =
                  b.pathFromRoot.lastIndexOf("/definitions");
                if (aDefinitionsIndex !== bDefinitionsIndex) {
                  // Give higher priority to the $ref that's closer to the "definitions" property
                  return bDefinitionsIndex - aDefinitionsIndex;
                } else {
                  // All else is equal, so use the shorter path, which will produce the shortest possible reference
                  return a.pathFromRoot.length - b.pathFromRoot.length;
                }
              }
            });
            var file, hash, pathFromRoot;
            var _iterator5 = _createForOfIteratorHelper(inventory),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var entry = _step5.value; // console.log('Re-mapping $ref pointer "%s" at %s', entry.$ref.$ref, entry.pathFromRoot);
                if (!entry.external) {
                  // This $ref already resolves to the main JSON Schema file
                  entry.$ref.$ref = entry.hash;
                } else if (entry.file === file && entry.hash === hash) {
                  // This $ref points to the same value as the prevous $ref, so remap it to the same path
                  entry.$ref.$ref = pathFromRoot;
                } else if (
                  entry.file === file &&
                  entry.hash.indexOf(hash + "/") === 0
                ) {
                  // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path
                  entry.$ref.$ref = Pointer.join(
                    pathFromRoot,
                    Pointer.parse(entry.hash.replace(hash, "#"))
                  );
                } else {
                  // We've moved to a new file or new hash
                  file = entry.file;
                  hash = entry.hash;
                  pathFromRoot = entry.pathFromRoot; // This is the first $ref to point to this value, so dereference the value.
                  // Any other $refs that point to the same value will point to this $ref instead
                  entry.$ref = entry.parent[entry.key] = $Ref.dereference(
                    entry.$ref,
                    entry.value
                  );
                  if (entry.circular) {
                    // This $ref points to itself
                    entry.$ref.$ref = entry.pathFromRoot;
                  }
                } // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          /**
           * TODO
           */ function findInInventory(inventory, $refParent, $refKey) {
            for (var i = 0; i < inventory.length; i++) {
              var existingEntry = inventory[i];
              if (
                existingEntry.parent === $refParent &&
                existingEntry.key === $refKey
              ) {
                return existingEntry;
              }
            }
          }
          function removeFromInventory(inventory, entry) {
            var index = inventory.indexOf(entry);
            inventory.splice(index, 1);
          }
        },
        { "./pointer": 11, "./ref": 12, "./util/url": 19 }
      ],
      2: [
        function (require, module, exports) {
          "use strict";
          var $Ref = require("./ref");
          var Pointer = require("./pointer");
          var _require3 = require("@jsdevtools/ono"),
            ono = _require3.ono;
          var url = require("./util/url");
          module.exports = dereference;
          /**
           * Crawls the JSON schema, finds all JSON references, and dereferences them.
           * This method mutates the JSON schema object, replacing JSON references with their resolved value.
           *
           * @param {$RefParser} parser
           * @param {$RefParserOptions} options
           */ function dereference(parser, options) {
            // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);
            var dereferenced = crawl(
              parser.schema,
              parser.$refs._root$Ref.path,
              "#",
              new Set(),
              new Set(),
              new Map(),
              parser.$refs,
              options
            );
            parser.$refs.circular = dereferenced.circular;
            parser.schema = dereferenced.value;
          }
          /**
           * Recursively crawls the given value, and dereferences any JSON references.
           *
           * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
           * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
           * @param {string} pathFromRoot - The path of `obj` from the schema root
           * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced
           * @param {Set<object>} processedObjects - An array of all the objects that have already been processed
           * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           * @returns {{value: object, circular: boolean}}
           */ function crawl(
            obj,
            path,
            pathFromRoot,
            parents,
            processedObjects,
            dereferencedCache,
            $refs,
            options
          ) {
            var dereferenced;
            var result = { value: obj, circular: false };
            if (
              options.dereference.circular === "ignore" ||
              !processedObjects.has(obj)
            ) {
              if (obj && _typeof2(obj) === "object" && !ArrayBuffer.isView(obj)) {
                parents.add(obj);
                processedObjects.add(obj);
                if ($Ref.isAllowed$Ref(obj, options)) {
                  dereferenced = dereference$Ref(
                    obj,
                    path,
                    pathFromRoot,
                    parents,
                    processedObjects,
                    dereferencedCache,
                    $refs,
                    options
                  );
                  result.circular = dereferenced.circular;
                  result.value = dereferenced.value;
                } else {
                  for (
                    var _i2 = 0, _Object$keys = Object.keys(obj);
                    _i2 < _Object$keys.length;
                    _i2++
                  ) {
                    var key = _Object$keys[_i2];
                    var keyPath = Pointer.join(path, key);
                    var keyPathFromRoot = Pointer.join(pathFromRoot, key);
                    var value = obj[key];
                    var circular = false;
                    if ($Ref.isAllowed$Ref(value, options)) {
                      dereferenced = dereference$Ref(
                        value,
                        keyPath,
                        keyPathFromRoot,
                        parents,
                        processedObjects,
                        dereferencedCache,
                        $refs,
                        options
                      );
                      circular = dereferenced.circular; // Avoid pointless mutations; breaks frozen objects to no profit
                      if (obj[key] !== dereferenced.value) {
                        obj[key] = dereferenced.value;
                      }
                    } else {
                      if (!parents.has(value)) {
                        dereferenced = crawl(
                          value,
                          keyPath,
                          keyPathFromRoot,
                          parents,
                          processedObjects,
                          dereferencedCache,
                          $refs,
                          options
                        );
                        circular = dereferenced.circular; // Avoid pointless mutations; breaks frozen objects to no profit
                        if (obj[key] !== dereferenced.value) {
                          obj[key] = dereferenced.value;
                        }
                      } else {
                        circular = foundCircularReference(
                          keyPath,
                          $refs,
                          options
                        );
                      }
                    } // Set the "isCircular" flag if this or any other property is circular
                    result.circular = result.circular || circular;
                  }
                }
                parents["delete"](obj);
              }
            }
            return result;
          }
          /**
           * Dereferences the given JSON Reference, and then crawls the resulting value.
           *
           * @param {{$ref: string}} $ref - The JSON Reference to resolve
           * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
           * @param {string} pathFromRoot - The path of `$ref` from the schema root
           * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced
           * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced
           * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           * @returns {{value: object, circular: boolean}}
           */ function dereference$Ref(
            $ref,
            path,
            pathFromRoot,
            parents,
            processedObjects,
            dereferencedCache,
            $refs,
            options
          ) {
            // console.log('Dereferencing $ref pointer "%s" at %s', $ref.$ref, path);
            var $refPath = url.resolve(path, $ref.$ref);
            var cache = dereferencedCache.get($refPath);
            if (cache) {
              var refKeys = Object.keys($ref);
              if (refKeys.length > 1) {
                var extraKeys = {};
                var _iterator6 = _createForOfIteratorHelper(refKeys),
                  _step6;
                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                    var key = _step6.value;
                    if (key !== "$ref" && !(key in cache.value)) {
                      extraKeys[key] = $ref[key];
                    }
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
                return {
                  circular: cache.circular,
                  value: Object.assign({}, cache.value, extraKeys)
                };
              }
              return cache;
            }
            var pointer = $refs._resolve($refPath, path, options);
            if (pointer === null) {
              return { circular: false, value: null };
            } // Check for circular references
            var directCircular = pointer.circular;
            var circular = directCircular || parents.has(pointer.value);
            circular && foundCircularReference(path, $refs, options); // Dereference the JSON reference
            var dereferencedValue = $Ref.dereference($ref, pointer.value); // Crawl the dereferenced value (unless it's circular)
            if (!circular) {
              // Determine if the dereferenced value is circular
              var dereferenced = crawl(
                dereferencedValue,
                pointer.path,
                pathFromRoot,
                parents,
                processedObjects,
                dereferencedCache,
                $refs,
                options
              );
              circular = dereferenced.circular;
              dereferencedValue = dereferenced.value;
            }
            if (
              circular &&
              !directCircular &&
              options.dereference.circular === "ignore"
            ) {
              // The user has chosen to "ignore" circular references, so don't change the value
              dereferencedValue = $ref;
            }
            if (directCircular) {
              // The pointer is a DIRECT circular reference (i.e. it references itself).
              // So replace the $ref path with the absolute path from the JSON Schema root
              dereferencedValue.$ref = pathFromRoot;
            }
            var dereferencedObject = {
              circular: circular,
              value: dereferencedValue
            }; // only cache if no extra properties than $ref
            if (Object.keys($ref).length === 1) {
              dereferencedCache.set($refPath, dereferencedObject);
            }
            return dereferencedObject;
          }
          /**
           * Called when a circular reference is found.
           * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.
           *
           * @param {string} keyPath - The JSON Reference path of the circular reference
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           * @returns {boolean} - always returns true, to indicate that a circular reference was found
           */ function foundCircularReference(keyPath, $refs, options) {
            $refs.circular = true;
            if (!options.dereference.circular) {
              throw ono.reference(
                "Circular $ref pointer found at ".concat(keyPath)
              );
            }
            return true;
          }
        },
        { "./pointer": 11, "./ref": 12, "./util/url": 19, "@jsdevtools/ono": 102 }
      ],
      3: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              /* eslint-disable no-unused-vars */ "use strict";
              var $Refs = require("./refs");
              var _parse = require("./parse");
              var normalizeArgs = require("./normalize-args");
              var resolveExternal = require("./resolve-external");
              var _bundle = require("./bundle");
              var _dereference = require("./dereference");
              var url = require("./util/url");
              var _require4 = require("./util/errors"),
                JSONParserError = _require4.JSONParserError,
                InvalidPointerError = _require4.InvalidPointerError,
                MissingPointerError = _require4.MissingPointerError,
                ResolverError = _require4.ResolverError,
                ParserError = _require4.ParserError,
                UnmatchedParserError = _require4.UnmatchedParserError,
                UnmatchedResolverError = _require4.UnmatchedResolverError,
                isHandledError = _require4.isHandledError,
                JSONParserErrorGroup = _require4.JSONParserErrorGroup;
              var maybe = require("call-me-maybe");
              var _require5 = require("@jsdevtools/ono"),
                ono = _require5.ono;
              module.exports = $RefParser;
              module.exports["default"] = $RefParser;
              module.exports.JSONParserError = JSONParserError;
              module.exports.InvalidPointerError = InvalidPointerError;
              module.exports.MissingPointerError = MissingPointerError;
              module.exports.ResolverError = ResolverError;
              module.exports.ParserError = ParserError;
              module.exports.UnmatchedParserError = UnmatchedParserError;
              module.exports.UnmatchedResolverError = UnmatchedResolverError;
              /**
               * This class parses a JSON schema, builds a map of its JSON references and their resolved values,
               * and provides methods for traversing, manipulating, and dereferencing those references.
               *
               * @constructor
               */ function $RefParser() {
                /**
                 * The parsed (and possibly dereferenced) JSON schema object
                 *
                 * @type {object}
                 * @readonly
                 */ this.schema = null;
                /**
                 * The resolved JSON references
                 *
                 * @type {$Refs}
                 * @readonly
                 */ this.$refs = new $Refs();
              }
              /**
               * Parses the given JSON schema.
               * This method does not resolve any JSON references.
               * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
               * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
               * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
               */ $RefParser.parse = function parse(
                path,
                schema,
                options,
                callback
              ) {
                var Class = this; // eslint-disable-line consistent-this
                var instance = new Class();
                return instance.parse.apply(instance, arguments);
              };
              /**
               * Parses the given JSON schema.
               * This method does not resolve any JSON references.
               * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
               * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
               * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
               */ $RefParser.prototype.parse = function parse(
                path,
                schema,
                options,
                callback
              ) {
                var args = normalizeArgs(arguments);
                var promise;
                if (!args.path && !args.schema) {
                  var err = ono(
                    "Expected a file path, URL, or object. Got ".concat(
                      args.path || args.schema
                    )
                  );
                  return maybe(args.callback, Promise.reject(err));
                } // Reset everything
                this.schema = null;
                this.$refs = new $Refs(); // If the path is a filesystem path, then convert it to a URL.
                // NOTE: According to the JSON Reference spec, these should already be URLs,
                // but, in practice, many people use local filesystem paths instead.
                // So we're being generous here and doing the conversion automatically.
                // This is not intended to be a 100% bulletproof solution.
                // If it doesn't work for your use-case, then use a URL instead.
                var pathType = "http";
                if (url.isFileSystemPath(args.path)) {
                  args.path = url.fromFileSystemPath(args.path);
                  pathType = "file";
                } // Resolve the absolute path of the schema
                args.path = url.resolve(url.cwd(), args.path);
                if (args.schema && _typeof2(args.schema) === "object") {
                  // A schema object was passed-in.
                  // So immediately add a new $Ref with the schema object as its value
                  var $ref = this.$refs._add(args.path);
                  $ref.value = args.schema;
                  $ref.pathType = pathType;
                  promise = Promise.resolve(args.schema);
                } else {
                  // Parse the schema file/url
                  promise = _parse(args.path, this.$refs, args.options);
                }
                var me = this;
                try {
                  var result = /*await*/ promise;
                  if (
                    result !== null &&
                    _typeof2(result) === "object" &&
                    !Buffer.isBuffer(result)
                  ) {
                    me.schema = result;
                    return maybe(args.callback, Promise.resolve(me.schema));
                  } else if (args.options.continueOnError) {
                    me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability
                    return maybe(args.callback, Promise.resolve(me.schema));
                  } else {
                    throw ono.syntax(
                      '"'.concat(
                        me.$refs._root$Ref.path || result,
                        '" is not a valid JSON Schema'
                      )
                    );
                  }
                } catch (err) {
                  if (!args.options.continueOnError || !isHandledError(err)) {
                    return maybe(args.callback, Promise.reject(err));
                  }
                  if (this.$refs._$refs[url.stripHash(args.path)]) {
                    this.$refs._$refs[url.stripHash(args.path)].addError(err);
                  }
                  return maybe(args.callback, Promise.resolve(null));
                }
              };
              /**
               * Parses the given JSON schema and resolves any JSON references, including references in
               * externally-referenced files.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
               * @param {function} [callback]
               * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
               *
               * @returns {Promise}
               * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
               */ $RefParser.resolve = function resolve(
                path,
                schema,
                options,
                callback
              ) {
                var Class = this; // eslint-disable-line consistent-this
                var instance = new Class();
                return instance.resolve.apply(instance, arguments);
              };
              /**
               * Parses the given JSON schema and resolves any JSON references, including references in
               * externally-referenced files.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
               * @param {function} [callback]
               * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
               *
               * @returns {Promise}
               * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
               */ $RefParser.prototype.resolve = /*async*/ function resolve(
                path,
                schema,
                options,
                callback
              ) {
                var me = this;
                var args = normalizeArgs(arguments);
                try {
                  /*await*/ this.parse(args.path, args.schema, args.options);
                  /*await*/ resolveExternal(me, args.options);
                  finalize(me);
                  return maybe(args.callback, Promise.resolve(me.$refs));
                } catch (err) {
                  return maybe(args.callback, Promise.reject(err));
                }
              };
              /**
               * Parses the given JSON schema, resolves any JSON references, and bundles all external references
               * into the main JSON schema. This produces a JSON schema that only has *internal* references,
               * not any *external* references.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
               * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
               * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
               */ $RefParser.bundle = function bundle(
                path,
                schema,
                options,
                callback
              ) {
                var Class = this; // eslint-disable-line consistent-this
                var instance = new Class();
                return instance.bundle.apply(instance, arguments);
              };
              /**
               * Parses the given JSON schema, resolves any JSON references, and bundles all external references
               * into the main JSON schema. This produces a JSON schema that only has *internal* references,
               * not any *external* references.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
               * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
               * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
               */ $RefParser.prototype.bundle = /*async*/ function bundle(
                path,
                schema,
                options,
                callback
              ) {
                var me = this;
                var args = normalizeArgs(arguments);
                try {
                  /*await*/ this.resolve(args.path, args.schema, args.options);
                  _bundle(me, args.options);
                  finalize(me);
                  return maybe(args.callback, Promise.resolve(me.schema));
                } catch (err) {
                  return maybe(args.callback, Promise.reject(err));
                }
              };
              /**
               * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
               * That is, all JSON references are replaced with their resolved values.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
               * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
               * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
               */ $RefParser.dereference = function dereference(
                path,
                schema,
                options,
                callback
              ) {
                var Class = this; // eslint-disable-line consistent-this
                var instance = new Class();
                return instance.dereference.apply(instance, arguments);
              };
              /**
               * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
               * That is, all JSON references are replaced with their resolved values.
               *
               * @param {string} [path] - The file path or URL of the JSON schema
               * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
               * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
               * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
               * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
               */ $RefParser.prototype.dereference =
                /*async*/ function dereference(path, schema, options, callback) {
                  var me = this;
                  var args = normalizeArgs(arguments);
                  try {
                    /*await*/ this.resolve(args.path, args.schema, args.options);
                    _dereference(me, args.options);
                    finalize(me);
                    return maybe(args.callback, Promise.resolve(me.schema));
                  } catch (err) {
                    return maybe(args.callback, Promise.reject(err));
                  }
                };
              function finalize(parser) {
                var errors = JSONParserErrorGroup.getParserErrors(parser);
                if (errors.length > 0) {
                  throw new JSONParserErrorGroup(parser);
                }
              }
            }.call(this));
          }.call(this, {
            isBuffer: require("../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js")
          }));
        },
        {
          "../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js": 241,
          "./bundle": 1,
          "./dereference": 2,
          "./normalize-args": 4,
          "./parse": 6,
          "./refs": 13,
          "./resolve-external": 14,
          "./util/errors": 17,
          "./util/url": 19,
          "@jsdevtools/ono": 102,
          "call-me-maybe": 152
        }
      ],
      4: [
        function (require, module, exports) {
          "use strict";
          var Options = require("./options");
          module.exports = normalizeArgs;
          /**
           * Normalizes the given arguments, accounting for optional args.
           *
           * @param {Arguments} args
           * @returns {object}
           */ function normalizeArgs(args) {
            var path, schema, options, callback;
            args = Array.prototype.slice.call(args);
            if (typeof args[args.length - 1] === "function") {
              // The last parameter is a callback function
              callback = args.pop();
            }
            if (typeof args[0] === "string") {
              // The first parameter is the path
              path = args[0];
              if (_typeof2(args[2]) === "object") {
                // The second parameter is the schema, and the third parameter is the options
                schema = args[1];
                options = args[2];
              } else {
                // The second parameter is the options
                schema = undefined;
                options = args[1];
              }
            } else {
              // The first parameter is the schema
              path = "";
              schema = args[0];
              options = args[1];
            }
            if (!(options instanceof Options)) {
              options = new Options(options);
            }
            return {
              path: path,
              schema: schema,
              options: options,
              callback: callback
            };
          }
        },
        { "./options": 5 }
      ],
      5: [
        function (require, module, exports) {
          /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */ "use strict";
          var jsonParser = require("./parsers/json");
          var yamlParser = require("./parsers/yaml");
          var textParser = require("./parsers/text");
          var binaryParser = require("./parsers/binary");
          var fileResolver = require("./resolvers/file");
          var httpResolver = require("./resolvers/http");
          module.exports = $RefParserOptions;
          /**
           * Options that determine how JSON schemas are parsed, resolved, and dereferenced.
           *
           * @param {object|$RefParserOptions} [options] - Overridden options
           * @constructor
           */ function $RefParserOptions(options) {
            merge(this, $RefParserOptions.defaults);
            merge(this, options);
          }
          $RefParserOptions.defaults = {
            /**
             * Determines how different types of files will be parsed.
             *
             * You can add additional parsers of your own, replace an existing one with
             * your own implementation, or disable any parser by setting it to false.
             */ parse: {
              json: jsonParser,
              yaml: yamlParser,
              text: textParser,
              binary: binaryParser
            },
            /**
             * Determines how JSON References will be resolved.
             *
             * You can add additional resolvers of your own, replace an existing one with
             * your own implementation, or disable any resolver by setting it to false.
             */ resolve: {
              file: fileResolver,
              http: httpResolver,
              /**
               * Determines whether external $ref pointers will be resolved.
               * If this option is disabled, then none of above resolvers will be called.
               * Instead, external $ref pointers will simply be ignored.
               *
               * @type {boolean}
               */ external: true
            },
            /**
             * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
             * causes it to keep processing as much as possible and then throw a single error that contains all errors
             * that were encountered.
             */ continueOnError: false,
            /**
             * Determines the types of JSON references that are allowed.
             */ dereference: {
              /**
               * Dereference circular (recursive) JSON references?
               * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
               * If "ignore", then circular references will not be dereferenced.
               *
               * @type {boolean|string}
               */ circular: true
            }
          };
          /**
           * Merges the properties of the source object into the target object.
           *
           * @param {object} target - The object that we're populating
           * @param {?object} source - The options that are being merged
           * @returns {object}
           */ function merge(target, source) {
            if (isMergeable(source)) {
              var keys = Object.keys(source);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var sourceSetting = source[key];
                var targetSetting = target[key];
                if (isMergeable(sourceSetting)) {
                  // It's a nested object, so merge it recursively
                  target[key] = merge(targetSetting || {}, sourceSetting);
                } else if (sourceSetting !== undefined) {
                  // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.
                  target[key] = sourceSetting;
                }
              }
            }
            return target;
          }
          /**
           * Determines whether the given value can be merged,
           * or if it is a scalar value that should just override the target value.
           *
           * @param   {*}  val
           * @returns {Boolean}
           */ function isMergeable(val) {
            return (
              val &&
              _typeof2(val) === "object" &&
              !Array.isArray(val) &&
              !(val instanceof RegExp) &&
              !(val instanceof Date)
            );
          }
        },
        {
          "./parsers/binary": 7,
          "./parsers/json": 8,
          "./parsers/text": 9,
          "./parsers/yaml": 10,
          "./resolvers/file": 15,
          "./resolvers/http": 16
        }
      ],
      6: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var _require6 = require("@jsdevtools/ono"),
                ono = _require6.ono;
              var url = require("./util/url");
              var plugins = require("./util/plugins");
              var _require7 = require("./util/errors"),
                ResolverError = _require7.ResolverError,
                ParserError = _require7.ParserError,
                UnmatchedParserError = _require7.UnmatchedParserError,
                UnmatchedResolverError = _require7.UnmatchedResolverError,
                isHandledError = _require7.isHandledError;
              module.exports = parse;
              /**
               * Reads and parses the specified file path or URL.
               *
               * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context
               * @param {$Refs} $refs
               * @param {$RefParserOptions} options
               *
               * @returns {Promise}
               * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.
               */ /*async*/ function parse(path, $refs, options) {
                // Remove the URL fragment, if any
                path = url.stripHash(path); // Add a new $Ref for this file, even though we don't have the value yet.
                // This ensures that we don't simultaneously read & parse the same file multiple times
                var $ref = $refs._add(path); // This "file object" will be passed to all resolvers and parsers.
                var file = { url: path, extension: url.getExtension(path) }; // Read the file and then parse the data
                try {
                  var resolver = /*await*/ readFile(file, options, $refs);
                  $ref.pathType = resolver.plugin.name;
                  file.data = resolver.result;
                  var parser = /*await*/ parseFile(file, options, $refs);
                  $ref.value = parser.result;
                  return parser.result;
                } catch (err) {
                  if (isHandledError(err)) {
                    $ref.value = err;
                  }
                  throw err;
                }
              }
              /**
               * Reads the given file, using the configured resolver plugins
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {$RefParserOptions} options
               *
               * @returns {Promise}
               * The promise resolves with the raw file contents and the resolver that was used.
               */ function readFile(file, options, $refs) {
                return new Promise(function (resolve, reject) {
                  // console.log('Reading %s', file.url);
                  // Find the resolvers that can read this file
                  var resolvers = plugins.all(options.resolve);
                  resolvers = plugins.filter(resolvers, "canRead", file); // Run the resolvers, in order, until one of them succeeds
                  plugins.sort(resolvers);
                  plugins
                    .run(resolvers, "read", file, $refs)
                    .then(resolve, onError);
                  function onError(err) {
                    if (!err && options.continueOnError) {
                      // No resolver could be matched
                      reject(new UnmatchedResolverError(file.url));
                    } else if (!err || !("error" in err)) {
                      // Throw a generic, friendly error.
                      reject(
                        ono.syntax(
                          'Unable to resolve $ref pointer "'.concat(file.url, '"')
                        )
                      );
                    } // Throw the original error, if it's one of our own (user-friendly) errors.
                    else if (err.error instanceof ResolverError) {
                      reject(err.error);
                    } else {
                      reject(new ResolverError(err, file.url));
                    }
                  }
                });
              }
              /**
               * Parses the given file's contents, using the configured parser plugins.
               *
               * @param {object} file           - An object containing information about the referenced file
               * @param {string} file.url       - The full URL of the referenced file
               * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
               * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
               * @param {$RefParserOptions} options
               *
               * @returns {Promise}
               * The promise resolves with the parsed file contents and the parser that was used.
               */ function parseFile(file, options, $refs) {
                return new Promise(function (resolve, reject) {
                  // console.log('Parsing %s', file.url);
                  // Find the parsers that can read this file type.
                  // If none of the parsers are an exact match for this file, then we'll try ALL of them.
                  // This handles situations where the file IS a supported type, just with an unknown extension.
                  var allParsers = plugins.all(options.parse);
                  var filteredParsers = plugins.filter(
                    allParsers,
                    "canParse",
                    file
                  );
                  var parsers =
                    filteredParsers.length > 0 ? filteredParsers : allParsers; // Run the parsers, in order, until one of them succeeds
                  plugins.sort(parsers);
                  plugins
                    .run(parsers, "parse", file, $refs)
                    .then(onParsed, onError);
                  function onParsed(parser) {
                    if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
                      reject(
                        ono.syntax(
                          'Error parsing "'
                            .concat(file.url, '" as ')
                            .concat(
                              parser.plugin.name,
                              ". \nParsed value is empty"
                            )
                        )
                      );
                    } else {
                      resolve(parser);
                    }
                  }
                  function onError(err) {
                    if (!err && options.continueOnError) {
                      // No resolver could be matched
                      reject(new UnmatchedParserError(file.url));
                    } else if (!err || !("error" in err)) {
                      reject(ono.syntax("Unable to parse ".concat(file.url)));
                    } else if (err.error instanceof ParserError) {
                      reject(err.error);
                    } else {
                      reject(new ParserError(err.error.message, file.url));
                    }
                  }
                });
              }
              /**
               * Determines whether the parsed value is "empty".
               *
               * @param {*} value
               * @returns {boolean}
               */ function isEmpty(value) {
                return (
                  value === undefined ||
                  (_typeof2(value) === "object" &&
                    Object.keys(value).length === 0) ||
                  (typeof value === "string" && value.trim().length === 0) ||
                  (Buffer.isBuffer(value) && value.length === 0)
                );
              }
            }.call(this));
          }.call(this, {
            isBuffer: require("../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js")
          }));
        },
        {
          "../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js": 241,
          "./util/errors": 17,
          "./util/plugins": 18,
          "./util/url": 19,
          "@jsdevtools/ono": 102
        }
      ],
      7: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
              module.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */ order: 400,
                /**
                 * Whether to allow "empty" files (zero bytes).
                 *
                 * @type {boolean}
                 */ allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that return true will be tried, in order, until one successfully parses the file.
                 * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
                 * every parser will be tried.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {boolean}
                 */ canParse: function canParse(file) {
                  // Use this parser if the file is a Buffer, and has a known binary extension
                  return (
                    Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url)
                  );
                },
                /**
                 * Parses the given data as a Buffer (byte array).
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Buffer}
                 */ parse: function parse(file) {
                  if (Buffer.isBuffer(file.data)) {
                    return file.data;
                  } else {
                    // This will reject if data is anything other than a string or typed array
                    return Buffer.from(file.data);
                  }
                }
              };
            }.call(this));
          }.call(this, require("buffer").Buffer));
        },
        { buffer: 223 }
      ],
      8: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var _require8 = require("../util/errors"),
                ParserError = _require8.ParserError;
              module.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */ order: 100,
                /**
                 * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
                 *
                 * @type {boolean}
                 */ allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that match will be tried, in order, until one successfully parses the file.
                 * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
                 * every parser will be tried.
                 *
                 * @type {RegExp|string|string[]|function}
                 */ canParse: ".json",
                /**
                 * Parses the given file as JSON
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Promise}
                 */ /*async*/ parse: function parse(file) {
                  // eslint-disable-line require-await
                  var data = file.data;
                  if (Buffer.isBuffer(data)) {
                    data = data.toString();
                  }
                  if (typeof data === "string") {
                    if (data.trim().length === 0) {
                      return; // This mirrors the YAML behavior
                    } else {
                      try {
                        return JSON.parse(data);
                      } catch (e) {
                        throw new ParserError(e.message, file.url);
                      }
                    }
                  } else {
                    // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                    return data;
                  }
                }
              };
            }.call(this));
          }.call(this, {
            isBuffer: require("../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js")
          }));
        },
        {
          "../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js": 241,
          "../util/errors": 17
        }
      ],
      9: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var _require9 = require("../util/errors"),
                ParserError = _require9.ParserError;
              var TEXT_REGEXP =
                /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
              module.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */ order: 300,
                /**
                 * Whether to allow "empty" files (zero bytes).
                 *
                 * @type {boolean}
                 */ allowEmpty: true,
                /**
                 * The encoding that the text is expected to be in.
                 *
                 * @type {string}
                 */ encoding: "utf8",
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that return true will be tried, in order, until one successfully parses the file.
                 * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
                 * every parser will be tried.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {boolean}
                 */ canParse: function canParse(file) {
                  // Use this parser if the file is a string or Buffer, and has a known text-based extension
                  return (
                    (typeof file.data === "string" ||
                      Buffer.isBuffer(file.data)) &&
                    TEXT_REGEXP.test(file.url)
                  );
                },
                /**
                 * Parses the given file as text
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {string}
                 */ parse: function parse(file) {
                  if (typeof file.data === "string") {
                    return file.data;
                  } else if (Buffer.isBuffer(file.data)) {
                    return file.data.toString(this.encoding);
                  } else {
                    throw new ParserError("data is not text", file.url);
                  }
                }
              };
            }.call(this));
          }.call(this, {
            isBuffer: require("../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js")
          }));
        },
        {
          "../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js": 241,
          "../util/errors": 17
        }
      ],
      10: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var _require10 = require("../util/errors"),
                ParserError = _require10.ParserError;
              var yaml = require("js-yaml");
              module.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */ order: 200,
                /**
                 * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
                 *
                 * @type {boolean}
                 */ allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that match will be tried, in order, until one successfully parses the file.
                 * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
                 * every parser will be tried.
                 *
                 * @type {RegExp|string[]|function}
                 */ canParse: [".yaml", ".yml", ".json"], // JSON is valid YAML
                /**
                 * Parses the given file as YAML
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Promise}
                 */ /*async*/ parse: function parse(file) {
                  // eslint-disable-line require-await
                  var data = file.data;
                  if (Buffer.isBuffer(data)) {
                    data = data.toString();
                  }
                  if (typeof data === "string") {
                    try {
                      return yaml.load(data);
                    } catch (e) {
                      throw new ParserError(e.message, file.url);
                    }
                  } else {
                    // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                    return data;
                  }
                }
              };
            }.call(this));
          }.call(this, {
            isBuffer: require("../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js")
          }));
        },
        {
          "../../../../../../../usr/local/nvm/versions/node/v16.4.0/lib/node_modules/browserify/node_modules/is-buffer/index.js": 241,
          "../util/errors": 17,
          "js-yaml": 20
        }
      ],
      11: [
        function (require, module, exports) {
          "use strict";
          module.exports = Pointer;
          var $Ref = require("./ref");
          var url = require("./util/url");
          var _require11 = require("./util/errors"),
            JSONParserError = _require11.JSONParserError,
            InvalidPointerError = _require11.InvalidPointerError,
            MissingPointerError = _require11.MissingPointerError,
            isHandledError = _require11.isHandledError;
          var slashes = /\//g;
          var tildes = /~/g;
          var escapedSlash = /~1/g;
          var escapedTilde = /~0/g;
          /**
           * This class represents a single JSON pointer and its resolved value.
           *
           * @param {$Ref} $ref
           * @param {string} path
           * @param {string} [friendlyPath] - The original user-specified path (used for error messages)
           * @constructor
           */ function Pointer($ref, path, friendlyPath) {
            /**
             * The {@link $Ref} object that contains this {@link Pointer} object.
             * @type {$Ref}
             */ this.$ref = $ref;
            /**
             * The file path or URL, containing the JSON pointer in the hash.
             * This path is relative to the path of the main JSON schema file.
             * @type {string}
             */ this.path = path;
            /**
             * The original path or URL, used for error messages.
             * @type {string}
             */ this.originalPath = friendlyPath || path;
            /**
             * The value of the JSON pointer.
             * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
             * @type {?*}
             */ this.value = undefined;
            /**
             * Indicates whether the pointer references itself.
             * @type {boolean}
             */ this.circular = false;
            /**
             * The number of indirect references that were traversed to resolve the value.
             * Resolving a single pointer may require resolving multiple $Refs.
             * @type {number}
             */ this.indirections = 0;
          }
          /**
           * Resolves the value of a nested property within the given object.
           *
           * @param {*} obj - The object that will be crawled
           * @param {$RefParserOptions} options
           * @param {string} pathFromRoot - the path of place that initiated resolving
           *
           * @returns {Pointer}
           * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
           * If resolving this value required resolving other JSON references, then
           * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
           * of the resolved value.
           */ Pointer.prototype.resolve = function (obj, options, pathFromRoot) {
            var tokens = Pointer.parse(this.path, this.originalPath); // Crawl the object, one token at a time
            this.value = unwrapOrThrow(obj);
            for (var i = 0; i < tokens.length; i++) {
              if (resolveIf$Ref(this, options)) {
                // The $ref path has changed, so append the remaining tokens to the path
                this.path = Pointer.join(this.path, tokens.slice(i));
              }
              if (
                _typeof2(this.value) === "object" &&
                this.value !== null &&
                "$ref" in this.value
              ) {
                return this;
              }
              var token = tokens[i];
              if (this.value[token] === undefined || this.value[token] === null) {
                this.value = null;
                throw new MissingPointerError(token, this.originalPath);
              } else {
                this.value = this.value[token];
              }
            } // Resolve the final value
            if (
              !this.value ||
              (this.value.$ref &&
                url.resolve(this.path, this.value.$ref) !== pathFromRoot)
            ) {
              resolveIf$Ref(this, options);
            }
            return this;
          };
          /**
           * Sets the value of a nested property within the given object.
           *
           * @param {*} obj - The object that will be crawled
           * @param {*} value - the value to assign
           * @param {$RefParserOptions} options
           *
           * @returns {*}
           * Returns the modified object, or an entirely new object if the entire object is overwritten.
           */ Pointer.prototype.set = function (obj, value, options) {
            var tokens = Pointer.parse(this.path);
            var token;
            if (tokens.length === 0) {
              // There are no tokens, replace the entire object with the new value
              this.value = value;
              return value;
            } // Crawl the object, one token at a time
            this.value = unwrapOrThrow(obj);
            for (var i = 0; i < tokens.length - 1; i++) {
              resolveIf$Ref(this, options);
              token = tokens[i];
              if (this.value && this.value[token] !== undefined) {
                // The token exists
                this.value = this.value[token];
              } else {
                // The token doesn't exist, so create it
                this.value = setValue(this, token, {});
              }
            } // Set the value of the final token
            resolveIf$Ref(this, options);
            token = tokens[tokens.length - 1];
            setValue(this, token, value); // Return the updated object
            return obj;
          };
          /**
           * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
           * and returns an array of the pointer's tokens.
           * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
           *
           * The pointer is parsed according to RFC 6901
           * {@link https://tools.ietf.org/html/rfc6901#section-3}
           *
           * @param {string} path
           * @param {string} [originalPath]
           * @returns {string[]}
           */ Pointer.parse = function (path, originalPath) {
            // Get the JSON pointer from the path's hash
            var pointer = url.getHash(path).substr(1); // If there's no pointer, then there are no tokens,
            // so return an empty array
            if (!pointer) {
              return [];
            } // Split into an array
            pointer = pointer.split("/"); // Decode each part, according to RFC 6901
            for (var i = 0; i < pointer.length; i++) {
              pointer[i] = decodeURIComponent(
                pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~")
              );
            }
            if (pointer[0] !== "") {
              throw new InvalidPointerError(
                pointer,
                originalPath === undefined ? path : originalPath
              );
            }
            return pointer.slice(1);
          };
          /**
           * Creates a JSON pointer path, by joining one or more tokens to a base path.
           *
           * @param {string} base - The base path (e.g. "schema.json#/definitions/person")
           * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
           * @returns {string}
           */ Pointer.join = function (base, tokens) {
            // Ensure that the base path contains a hash
            if (base.indexOf("#") === -1) {
              base += "#";
            } // Append each token to the base path
            tokens = Array.isArray(tokens) ? tokens : [tokens];
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i]; // Encode the token, according to RFC 6901
              base +=
                "/" +
                encodeURIComponent(
                  token.replace(tildes, "~0").replace(slashes, "~1")
                );
            }
            return base;
          };
          /**
           * If the given pointer's {@link Pointer#value} is a JSON reference,
           * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.
           * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the
           * resolution path of the new value.
           *
           * @param {Pointer} pointer
           * @param {$RefParserOptions} options
           * @returns {boolean} - Returns `true` if the resolution path changed
           */ function resolveIf$Ref(pointer, options) {
            // Is the value a JSON reference? (and allowed?)
            if ($Ref.isAllowed$Ref(pointer.value, options)) {
              var $refPath = url.resolve(pointer.path, pointer.value.$ref);
              if ($refPath === pointer.path) {
                // The value is a reference to itself, so there's nothing to do.
                pointer.circular = true;
              } else {
                var resolved = pointer.$ref.$refs._resolve(
                  $refPath,
                  pointer.path,
                  options
                );
                if (resolved === null) {
                  return false;
                }
                pointer.indirections += resolved.indirections + 1;
                if ($Ref.isExtended$Ref(pointer.value)) {
                  // This JSON reference "extends" the resolved value, rather than simply pointing to it.
                  // So the resolved path does NOT change.  Just the value does.
                  pointer.value = $Ref.dereference(pointer.value, resolved.value);
                  return false;
                } else {
                  // Resolve the reference
                  pointer.$ref = resolved.$ref;
                  pointer.path = resolved.path;
                  pointer.value = resolved.value;
                }
                return true;
              }
            }
          }
          /**
           * Sets the specified token value of the {@link Pointer#value}.
           *
           * The token is evaluated according to RFC 6901.
           * {@link https://tools.ietf.org/html/rfc6901#section-4}
           *
           * @param {Pointer} pointer - The JSON Pointer whose value will be modified
           * @param {string} token - A JSON Pointer token that indicates how to modify `obj`
           * @param {*} value - The value to assign
           * @returns {*} - Returns the assigned value
           */ function setValue(pointer, token, value) {
            if (pointer.value && _typeof2(pointer.value) === "object") {
              if (token === "-" && Array.isArray(pointer.value)) {
                pointer.value.push(value);
              } else {
                pointer.value[token] = value;
              }
            } else {
              throw new JSONParserError(
                'Error assigning $ref pointer "'
                  .concat(pointer.path, '". \nCannot set "')
                  .concat(token, '" of a non-object.')
              );
            }
            return value;
          }
          function unwrapOrThrow(value) {
            if (isHandledError(value)) {
              throw value;
            }
            return value;
          }
        },
        { "./ref": 12, "./util/errors": 17, "./util/url": 19 }
      ],
      12: [
        function (require, module, exports) {
          "use strict";
          module.exports = $Ref;
          var Pointer = require("./pointer");
          var _require12 = require("./util/errors"),
            InvalidPointerError = _require12.InvalidPointerError,
            isHandledError = _require12.isHandledError,
            normalizeError = _require12.normalizeError;
          var _require13 = require("./util/url"),
            safePointerToPath = _require13.safePointerToPath,
            stripHash = _require13.stripHash,
            getHash = _require13.getHash;
          /**
           * This class represents a single JSON reference and its resolved value.
           *
           * @class
           */ function $Ref() {
            /**
             * The file path or URL of the referenced file.
             * This path is relative to the path of the main JSON schema file.
             *
             * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.
             * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get
             * specific JSON pointers within the file.
             *
             * @type {string}
             */ this.path = undefined;
            /**
             * The resolved value of the JSON reference.
             * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
             *
             * @type {?*}
             */ this.value = undefined;
            /**
             * The {@link $Refs} object that contains this {@link $Ref} object.
             *
             * @type {$Refs}
             */ this.$refs = undefined;
            /**
             * Indicates the type of {@link $Ref#path} (e.g. "file", "http", etc.)
             *
             * @type {?string}
             */ this.pathType = undefined;
            /**
             * List of all errors. Undefined if no errors.
             *
             * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}
             */ this.errors = undefined;
          }
          /**
           * Pushes an error to errors array.
           *
           * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed
           * @returns {void}
           */ $Ref.prototype.addError = function (err) {
            if (this.errors === undefined) {
              this.errors = [];
            }
            var existingErrors = this.errors.map(function (_ref) {
              var footprint = _ref.footprint;
              return footprint;
            }); // the path has been almost certainly set at this point,
            // but just in case something went wrong, normalizeError injects path if necessary
            // moreover, certain errors might point at the same spot, so filter them out to reduce noise
            if (Array.isArray(err.errors)) {
              var _this$errors;
              (_this$errors = this.errors).push.apply(
                _this$errors,
                _toConsumableArray(
                  err.errors.map(normalizeError).filter(function (_ref2) {
                    var footprint = _ref2.footprint;
                    return !existingErrors.includes(footprint);
                  })
                )
              );
            } else if (!existingErrors.includes(err.footprint)) {
              this.errors.push(normalizeError(err));
            }
          };
          /**
           * Determines whether the given JSON reference exists within this {@link $Ref#value}.
           *
           * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
           * @param {$RefParserOptions} options
           * @returns {boolean}
           */ $Ref.prototype.exists = function (path, options) {
            try {
              this.resolve(path, options);
              return true;
            } catch (e) {
              return false;
            }
          };
          /**
           * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
           *
           * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
           * @param {$RefParserOptions} options
           * @returns {*} - Returns the resolved value
           */ $Ref.prototype.get = function (path, options) {
            return this.resolve(path, options).value;
          };
          /**
           * Resolves the given JSON reference within this {@link $Ref#value}.
           *
           * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
           * @param {$RefParserOptions} options
           * @param {string} friendlyPath - The original user-specified path (used for error messages)
           *  @param {string} pathFromRoot - The path of `obj` from the schema root
           * @returns {Pointer | null}
           */ $Ref.prototype.resolve = function (
            path,
            options,
            friendlyPath,
            pathFromRoot
          ) {
            var pointer = new Pointer(this, path, friendlyPath);
            try {
              return pointer.resolve(this.value, options, pathFromRoot);
            } catch (err) {
              if (!options || !options.continueOnError || !isHandledError(err)) {
                throw err;
              }
              if (err.path === null) {
                err.path = safePointerToPath(getHash(pathFromRoot));
              }
              if (err instanceof InvalidPointerError) {
                // this is a special case - InvalidPointerError is thrown when dereferencing external file,
                // but the issue is caused by the source file that referenced the file that undergoes dereferencing
                err.source = stripHash(pathFromRoot);
              }
              this.addError(err);
              return null;
            }
          };
          /**
           * Sets the value of a nested property within this {@link $Ref#value}.
           * If the property, or any of its parents don't exist, they will be created.
           *
           * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash
           * @param {*} value - The value to assign
           */ $Ref.prototype.set = function (path, value) {
            var pointer = new Pointer(this, path);
            this.value = pointer.set(this.value, value);
          };
          /**
           * Determines whether the given value is a JSON reference.
           *
           * @param {*} value - The value to inspect
           * @returns {boolean}
           */ $Ref.is$Ref = function (value) {
            return (
              value &&
              _typeof2(value) === "object" &&
              typeof value.$ref === "string" &&
              value.$ref.length > 0
            );
          };
          /**
           * Determines whether the given value is an external JSON reference.
           *
           * @param {*} value - The value to inspect
           * @returns {boolean}
           */ $Ref.isExternal$Ref = function (value) {
            return $Ref.is$Ref(value) && value.$ref[0] !== "#";
          };
          /**
           * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
           * For example, if it references an external file, then options.resolve.external must be true.
           *
           * @param {*} value - The value to inspect
           * @param {$RefParserOptions} options
           * @returns {boolean}
           */ $Ref.isAllowed$Ref = function (value, options) {
            if ($Ref.is$Ref(value)) {
              if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
                // It's a JSON Pointer reference, which is always allowed
                return true;
              } else if (
                value.$ref[0] !== "#" &&
                (!options || options.resolve.external)
              ) {
                // It's an external reference, which is allowed by the options
                return true;
              }
            }
          };
          /**
           * Determines whether the given value is a JSON reference that "extends" its resolved value.
           * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
           * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
           * value, plus the extra properties.
           *
           * @example:
           *  {
           *    person: {
           *      properties: {
           *        firstName: { type: string }
           *        lastName: { type: string }
           *      }
           *    }
           *    employee: {
           *      properties: {
           *        $ref: #/person/properties
           *        salary: { type: number }
           *      }
           *    }
           *  }
           *
           *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
           *  property (salary).  The result is a NEW value that looks like this:
           *
           *  {
           *    properties: {
           *      firstName: { type: string }
           *      lastName: { type: string }
           *      salary: { type: number }
           *    }
           *  }
           *
           * @param {*} value - The value to inspect
           * @returns {boolean}
           */ $Ref.isExtended$Ref = function (value) {
            return $Ref.is$Ref(value) && Object.keys(value).length > 1;
          };
          /**
           * Returns the resolved value of a JSON Reference.
           * If necessary, the resolved value is merged with the JSON Reference to create a new object
           *
           * @example:
           *  {
           *    person: {
           *      properties: {
           *        firstName: { type: string }
           *        lastName: { type: string }
           *      }
           *    }
           *    employee: {
           *      properties: {
           *        $ref: #/person/properties
           *        salary: { type: number }
           *      }
           *    }
           *  }
           *
           *  When "person" and "employee" are merged, you end up with the following object:
           *
           *  {
           *    properties: {
           *      firstName: { type: string }
           *      lastName: { type: string }
           *      salary: { type: number }
           *    }
           *  }
           *
           * @param {object} $ref - The JSON reference object (the one with the "$ref" property)
           * @param {*} resolvedValue - The resolved value, which can be any type
           * @returns {*} - Returns the dereferenced value
           */ $Ref.dereference = function ($ref, resolvedValue) {
            if (
              resolvedValue &&
              _typeof2(resolvedValue) === "object" &&
              $Ref.isExtended$Ref($ref)
            ) {
              var merged = {};
              for (
                var _i3 = 0, _Object$keys2 = Object.keys($ref);
                _i3 < _Object$keys2.length;
                _i3++
              ) {
                var key = _Object$keys2[_i3];
                if (key !== "$ref") {
                  merged[key] = $ref[key];
                }
              }
              for (
                var _i4 = 0, _Object$keys3 = Object.keys(resolvedValue);
                _i4 < _Object$keys3.length;
                _i4++
              ) {
                var _key3 = _Object$keys3[_i4];
                if (!(_key3 in merged)) {
                  merged[_key3] = resolvedValue[_key3];
                }
              }
              return merged;
            } else {
              // Completely replace the original reference with the resolved value
              return resolvedValue;
            }
          };
        },
        { "./pointer": 11, "./util/errors": 17, "./util/url": 19 }
      ],
      13: [
        function (require, module, exports) {
          "use strict";
          var _require14 = require("@jsdevtools/ono"),
            ono = _require14.ono;
          var $Ref = require("./ref");
          var url = require("./util/url");
          module.exports = $Refs;
          /**
           * This class is a map of JSON references and their resolved values.
           */ function $Refs() {
            /**
             * Indicates whether the schema contains any circular references.
             *
             * @type {boolean}
             */ this.circular = false;
            /**
             * A map of paths/urls to {@link $Ref} objects
             *
             * @type {object}
             * @protected
             */ this._$refs = {};
            /**
             * The {@link $Ref} object that is the root of the JSON schema.
             *
             * @type {$Ref}
             * @protected
             */ this._root$Ref = null;
          }
          /**
           * Returns the paths of all the files/URLs that are referenced by the JSON schema,
           * including the schema itself.
           *
           * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
           * @returns {string[]}
           */ $Refs.prototype.paths = function (types) {
            // eslint-disable-line no-unused-vars
            var paths = getPaths(this._$refs, arguments);
            return paths.map(function (path) {
              return path.decoded;
            });
          };
          /**
           * Returns the map of JSON references and their resolved values.
           *
           * @param {...string|string[]} [types] - Only return references of the given types ("file", "http", etc.)
           * @returns {object}
           */ $Refs.prototype.values = function (types) {
            // eslint-disable-line no-unused-vars
            var $refs = this._$refs;
            var paths = getPaths($refs, arguments);
            return paths.reduce(function (obj, path) {
              obj[path.decoded] = $refs[path.encoded].value;
              return obj;
            }, {});
          };
          /**
           * Returns a POJO (plain old JavaScript object) for serialization as JSON.
           *
           * @returns {object}
           */ $Refs.prototype.toJSON = $Refs.prototype.values;
          /**
           * Determines whether the given JSON reference exists.
           *
           * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
           * @param {$RefParserOptions} [options]
           * @returns {boolean}
           */ $Refs.prototype.exists = function (path, options) {
            try {
              this._resolve(path, "", options);
              return true;
            } catch (e) {
              return false;
            }
          };
          /**
           * Resolves the given JSON reference and returns the resolved value.
           *
           * @param {string} path - The path being resolved, with a JSON pointer in the hash
           * @param {$RefParserOptions} [options]
           * @returns {*} - Returns the resolved value
           */ $Refs.prototype.get = function (path, options) {
            return this._resolve(path, "", options).value;
          };
          /**
           * Sets the value of a nested property within this {@link $Ref#value}.
           * If the property, or any of its parents don't exist, they will be created.
           *
           * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash
           * @param {*} value - The value to assign
           */ $Refs.prototype.set = function (path, value) {
            var absPath = url.resolve(this._root$Ref.path, path);
            var withoutHash = url.stripHash(absPath);
            var $ref = this._$refs[withoutHash];
            if (!$ref) {
              throw ono(
                'Error resolving $ref pointer "'
                  .concat(path, '". \n"')
                  .concat(withoutHash, '" not found.')
              );
            }
            $ref.set(absPath, value);
          };
          /**
           * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
           *
           * @param {string} path  - The file path or URL of the referenced file
           */ $Refs.prototype._add = function (path) {
            var withoutHash = url.stripHash(path);
            var $ref = new $Ref();
            $ref.path = withoutHash;
            $ref.$refs = this;
            this._$refs[withoutHash] = $ref;
            this._root$Ref = this._root$Ref || $ref;
            return $ref;
          };
          /**
           * Resolves the given JSON reference.
           *
           * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
           * @param {string} pathFromRoot - The path of `obj` from the schema root
           * @param {$RefParserOptions} [options]
           * @returns {Pointer}
           * @protected
           */ $Refs.prototype._resolve = function (path, pathFromRoot, options) {
            var absPath = url.resolve(this._root$Ref.path, path);
            var withoutHash = url.stripHash(absPath);
            var $ref = this._$refs[withoutHash];
            if (!$ref) {
              throw ono(
                'Error resolving $ref pointer "'
                  .concat(path, '". \n"')
                  .concat(withoutHash, '" not found.')
              );
            }
            return $ref.resolve(absPath, options, path, pathFromRoot);
          };
          /**
           * Returns the specified {@link $Ref} object, or undefined.
           *
           * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
           * @returns {$Ref|undefined}
           * @protected
           */ $Refs.prototype._get$Ref = function (path) {
            path = url.resolve(this._root$Ref.path, path);
            var withoutHash = url.stripHash(path);
            return this._$refs[withoutHash];
          };
          /**
           * Returns the encoded and decoded paths keys of the given object.
           *
           * @param {object} $refs - The object whose keys are URL-encoded paths
           * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
           * @returns {object[]}
           */ function getPaths($refs, types) {
            var paths = Object.keys($refs); // Filter the paths by type
            types = Array.isArray(types[0])
              ? types[0]
              : Array.prototype.slice.call(types);
            if (types.length > 0 && types[0]) {
              paths = paths.filter(function (key) {
                return types.indexOf($refs[key].pathType) !== -1;
              });
            } // Decode local filesystem paths
            return paths.map(function (path) {
              return {
                encoded: path,
                decoded:
                  $refs[path].pathType === "file"
                    ? url.toFileSystemPath(path, true)
                    : path
              };
            });
          }
        },
        { "./ref": 12, "./util/url": 19, "@jsdevtools/ono": 102 }
      ],
      14: [
        function (require, module, exports) {
          "use strict";
          var $Ref = require("./ref");
          var Pointer = require("./pointer");
          var parse = require("./parse");
          var url = require("./util/url");
          var _require15 = require("./util/errors"),
            isHandledError = _require15.isHandledError;
          module.exports = resolveExternal;
          /**
           * Crawls the JSON schema, finds all external JSON references, and resolves their values.
           * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.
           *
           * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.
           *
           * @param {$RefParser} parser
           * @param {$RefParserOptions} options
           *
           * @returns {Promise}
           * The promise resolves once all JSON references in the schema have been resolved,
           * including nested references that are contained in externally-referenced files.
           */ function resolveExternal(parser, options) {
            if (!options.resolve.external) {
              // Nothing to resolve, so exit early
              return Promise.resolve();
            }
            try {
              // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);
              var promises = crawl(
                parser.schema,
                parser.$refs._root$Ref.path + "#",
                parser.$refs,
                options
              );
              return Promise.all(promises);
            } catch (e) {
              return Promise.reject(e);
            }
          }
          /**
           * Recursively crawls the given value, and resolves any external JSON references.
           *
           * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
           * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           * @param {Set} seen - Internal.
           *
           * @returns {Promise[]}
           * Returns an array of promises. There will be one promise for each JSON reference in `obj`.
           * If `obj` does not contain any JSON references, then the array will be empty.
           * If any of the JSON references point to files that contain additional JSON references,
           * then the corresponding promise will internally reference an array of promises.
           */ function crawl(obj, path, $refs, options, seen) {
            seen = seen || new Set();
            var promises = [];
            if (
              obj &&
              _typeof2(obj) === "object" &&
              !ArrayBuffer.isView(obj) &&
              !seen.has(obj)
            ) {
              seen.add(obj); // Track previously seen objects to avoid infinite recursion
              if ($Ref.isExternal$Ref(obj)) {
                promises.push(resolve$Ref(obj, path, $refs, options));
              } else {
                for (
                  var _i5 = 0, _Object$keys4 = Object.keys(obj);
                  _i5 < _Object$keys4.length;
                  _i5++
                ) {
                  var key = _Object$keys4[_i5];
                  var keyPath = Pointer.join(path, key);
                  var value = obj[key];
                  if ($Ref.isExternal$Ref(value)) {
                    promises.push(resolve$Ref(value, keyPath, $refs, options));
                  } else {
                    promises = promises.concat(
                      crawl(value, keyPath, $refs, options, seen)
                    );
                  }
                }
              }
            }
            return promises;
          }
          /**
           * Resolves the given JSON Reference, and then crawls the resulting value.
           *
           * @param {{$ref: string}} $ref - The JSON Reference to resolve
           * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
           * @param {$Refs} $refs
           * @param {$RefParserOptions} options
           *
           * @returns {Promise}
           * The promise resolves once all JSON references in the object have been resolved,
           * including nested references that are contained in externally-referenced files.
           */ /*async*/ function resolve$Ref($ref, path, $refs, options) {
            // console.log('Resolving $ref pointer "%s" at %s', $ref.$ref, path);
            var resolvedPath = url.resolve(path, $ref.$ref);
            var withoutHash = url.stripHash(resolvedPath); // Do we already have this $ref?
            $ref = $refs._$refs[withoutHash];
            if ($ref) {
              // We've already parsed this $ref, so use the existing value
              return Promise.resolve($ref.value);
            } // Parse the $referenced file/url
            try {
              var result = /*await*/ parse(resolvedPath, $refs, options); // Crawl the parsed value
              // console.log('Resolving $ref pointers in %s', withoutHash);
              var promises = crawl(result, withoutHash + "#", $refs, options);
              return Promise.all(promises);
            } catch (err) {
              if (!options.continueOnError || !isHandledError(err)) {
                throw err;
              }
              if ($refs._$refs[withoutHash]) {
                err.source = url.stripHash(path);
                err.path = url.safePointerToPath(url.getHash(path));
              }
              return [];
            }
          }
        },
        {
          "./parse": 6,
          "./pointer": 11,
          "./ref": 12,
          "./util/errors": 17,
          "./util/url": 19
        }
      ],
      15: [
        function (require, module, exports) {
          "use strict";
          var fs = require("fs");
          var _require16 = require("@jsdevtools/ono"),
            ono = _require16.ono;
          var url = require("../util/url");
          var _require17 = require("../util/errors"),
            ResolverError = _require17.ResolverError;
          module.exports = {
            /**
             * The order that this resolver will run, in relation to other resolvers.
             *
             * @type {number}
             */ order: 100,
            /**
             * Determines whether this resolver can read a given file reference.
             * Resolvers that return true will be tried, in order, until one successfully resolves the file.
             * Resolvers that return false will not be given a chance to resolve the file.
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @returns {boolean}
             */ canRead: function canRead(file) {
              return url.isFileSystemPath(file.url);
            },
            /**
             * Reads the given file and returns its raw contents as a Buffer.
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @returns {Promise<Buffer>}
             */ read: function read(file) {
              return new Promise(function (resolve, reject) {
                var path;
                try {
                  path = url.toFileSystemPath(file.url);
                } catch (err) {
                  reject(
                    new ResolverError(
                      ono.uri(err, "Malformed URI: ".concat(file.url)),
                      file.url
                    )
                  );
                } // console.log('Opening file: %s', path);
                try {
                  fs.readFile(path, function (err, data) {
                    if (err) {
                      reject(
                        new ResolverError(
                          ono(err, 'Error opening file "'.concat(path, '"')),
                          path
                        )
                      );
                    } else {
                      resolve(data);
                    }
                  });
                } catch (err) {
                  reject(
                    new ResolverError(
                      ono(err, 'Error opening file "'.concat(path, '"')),
                      path
                    )
                  );
                }
              });
            }
          };
        },
        {
          "../util/errors": 17,
          "../util/url": 19,
          "@jsdevtools/ono": 102,
          fs: 222
        }
      ],
      16: [
        function (require, module, exports) {
          (function (process, Buffer) {
            (function () {
              "use strict";
              var http = require("http");
              var https = require("https");
              var _require18 = require("@jsdevtools/ono"),
                ono = _require18.ono;
              var url = require("../util/url");
              var _require19 = require("../util/errors"),
                ResolverError = _require19.ResolverError;
              module.exports = {
                /**
                 * The order that this resolver will run, in relation to other resolvers.
                 *
                 * @type {number}
                 */ order: 200,
                /**
                 * HTTP headers to send when downloading files.
                 *
                 * @example:
                 * {
                 *   "User-Agent": "JSON Schema $Ref Parser",
                 *   Accept: "application/json"
                 * }
                 *
                 * @type {object}
                 */ headers: null,
                /**
                 * HTTP request timeout (in milliseconds).
                 *
                 * @type {number}
                 */ timeout: 5000, // 5 seconds
                /**
                 * The maximum number of HTTP redirects to follow.
                 * To disable automatic following of redirects, set this to zero.
                 *
                 * @type {number}
                 */ redirects: 5,
                /**
                 * The `withCredentials` option of XMLHttpRequest.
                 * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
                 *
                 * @type {boolean}
                 */ withCredentials: false,
                /**
                 * Determines whether this resolver can read a given file reference.
                 * Resolvers that return true will be tried in order, until one successfully resolves the file.
                 * Resolvers that return false will not be given a chance to resolve the file.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @returns {boolean}
                 */ canRead: function canRead(file) {
                  return url.isHttp(file.url);
                },
                /**
                 * Reads the given URL and returns its raw contents as a Buffer.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @returns {Promise<Buffer>}
                 */ read: function read(file) {
                  var u = url.parse(file.url);
                  if (process.browser && !u.protocol) {
                    // Use the protocol of the current page
                    u.protocol = url.parse(location.href).protocol;
                  }
                  return download(u, this);
                }
              };
              /**
               * Downloads the given file.
               *
               * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)
               * @param {object} httpOptions  - The `options.resolve.http` object
               * @param {number} [redirects]  - The redirect URLs that have already been followed
               *
               * @returns {Promise<Buffer>}
               * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.
               */ function download(u, httpOptions, redirects) {
                return new Promise(function (resolve, reject) {
                  u = url.parse(u);
                  redirects = redirects || [];
                  redirects.push(u.href);
                  get(u, httpOptions)
                    .then(function (res) {
                      if (res.statusCode >= 400) {
                        throw ono(
                          { status: res.statusCode },
                          "HTTP ERROR ".concat(res.statusCode)
                        );
                      } else if (res.statusCode >= 300) {
                        if (redirects.length > httpOptions.redirects) {
                          reject(
                            new ResolverError(
                              ono(
                                { status: res.statusCode },
                                "Error downloading "
                                  .concat(
                                    redirects[0],
                                    ". \nToo many redirects: \n  "
                                  )
                                  .concat(redirects.join(" \n  "))
                              )
                            )
                          );
                        } else if (!res.headers.location) {
                          throw ono(
                            { status: res.statusCode },
                            "HTTP ".concat(
                              res.statusCode,
                              " redirect with no location header"
                            )
                          );
                        } else {
                          // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);
                          var redirectTo = url.resolve(u, res.headers.location);
                          download(redirectTo, httpOptions, redirects).then(
                            resolve,
                            reject
                          );
                        }
                      } else {
                        resolve(res.body || Buffer.alloc(0));
                      }
                    })
                    ["catch"](function (err) {
                      reject(
                        new ResolverError(
                          ono(err, "Error downloading ".concat(u.href)),
                          u.href
                        )
                      );
                    });
                });
              }
              /**
               * Sends an HTTP GET request.
               *
               * @param {Url} u - A parsed {@link Url} object
               * @param {object} httpOptions - The `options.resolve.http` object
               *
               * @returns {Promise<Response>}
               * The promise resolves with the HTTP Response object.
               */ function get(u, httpOptions) {
                return new Promise(function (resolve, reject) {
                  // console.log('GET', u.href);
                  var protocol = u.protocol === "https:" ? https : http;
                  var req = protocol.get({
                    hostname: u.hostname,
                    port: u.port,
                    path: u.path,
                    auth: u.auth,
                    protocol: u.protocol,
                    headers: httpOptions.headers || {},
                    withCredentials: httpOptions.withCredentials
                  });
                  if (typeof req.setTimeout === "function") {
                    req.setTimeout(httpOptions.timeout);
                  }
                  req.on("timeout", function () {
                    req.abort();
                  });
                  req.on("error", reject);
                  req.once("response", function (res) {
                    res.body = Buffer.alloc(0);
                    res.on("data", function (data) {
                      res.body = Buffer.concat([res.body, Buffer.from(data)]);
                    });
                    res.on("error", reject);
                    res.on("end", function () {
                      resolve(res);
                    });
                  });
                });
              }
            }.call(this));
          }.call(this, require("_process"), require("buffer").Buffer));
        },
        {
          "../util/errors": 17,
          "../util/url": 19,
          "@jsdevtools/ono": 102,
          _process: 246,
          buffer: 223,
          http: 252,
          https: 237
        }
      ],
      17: [
        function (require, module, exports) {
          "use strict";
          var _require20 = require("@jsdevtools/ono"),
            Ono = _require20.Ono;
          var _require21 = require("./url"),
            stripHash = _require21.stripHash,
            toFileSystemPath = _require21.toFileSystemPath;
          var JSONParserError = (exports.JSONParserError =
            /*#__PURE__*/ (function (_Error) {
              _inherits(JSONParserError, _Error);
              var _super = _createSuper(JSONParserError);
              function JSONParserError(message, source) {
                var _this3;
                _classCallCheck2(this, JSONParserError);
                _this3 = _super.call(this);
                _this3.code = "EUNKNOWN";
                _this3.message = message;
                _this3.source = source;
                _this3.path = null;
                Ono.extend(_assertThisInitialized(_this3));
                return _this3;
              }
              _createClass2(JSONParserError, [
                {
                  key: "footprint",
                  get: function get() {
                    return ""
                      .concat(this.path, "+")
                      .concat(this.source, "+")
                      .concat(this.code, "+")
                      .concat(this.message);
                  }
                }
              ]);
              return JSONParserError;
            })(/*#__PURE__*/ _wrapNativeSuper(Error)));
          setErrorName(JSONParserError);
          var JSONParserErrorGroup = (exports.JSONParserErrorGroup =
            /*#__PURE__*/ (function (_Error2) {
              _inherits(JSONParserErrorGroup, _Error2);
              var _super2 = _createSuper(JSONParserErrorGroup);
              function JSONParserErrorGroup(parser) {
                var _this4;
                _classCallCheck2(this, JSONParserErrorGroup);
                _this4 = _super2.call(this);
                _this4.files = parser;
                _this4.message = ""
                  .concat(_this4.errors.length, " error")
                  .concat(
                    _this4.errors.length > 1 ? "s" : "",
                    " occurred while reading '"
                  )
                  .concat(toFileSystemPath(parser.$refs._root$Ref.path), "'");
                Ono.extend(_assertThisInitialized(_this4));
                return _this4;
              }
              _createClass2(
                JSONParserErrorGroup,
                [
                  {
                    key: "errors",
                    get: function get() {
                      return JSONParserErrorGroup.getParserErrors(this.files);
                    }
                  }
                ],
                [
                  {
                    key: "getParserErrors",
                    value: function getParserErrors(parser) {
                      var errors = [];
                      for (
                        var _i6 = 0,
                          _Object$values = Object.values(parser.$refs._$refs);
                        _i6 < _Object$values.length;
                        _i6++
                      ) {
                        var $ref = _Object$values[_i6];
                        if ($ref.errors) {
                          errors.push.apply(
                            errors,
                            _toConsumableArray($ref.errors)
                          );
                        }
                      }
                      return errors;
                    }
                  }
                ]
              );
              return JSONParserErrorGroup;
            })(/*#__PURE__*/ _wrapNativeSuper(Error)));
          setErrorName(JSONParserErrorGroup);
          var ParserError = (exports.ParserError = /*#__PURE__*/ (function (
            _JSONParserError
          ) {
            _inherits(ParserError, _JSONParserError);
            var _super3 = _createSuper(ParserError);
            function ParserError(message, source) {
              var _this5;
              _classCallCheck2(this, ParserError);
              _this5 = _super3.call(
                this,
                "Error parsing ".concat(source, ": ").concat(message),
                source
              );
              _this5.code = "EPARSER";
              return _this5;
            }
            return _createClass2(ParserError);
          })(JSONParserError));
          setErrorName(ParserError);
          var UnmatchedParserError = (exports.UnmatchedParserError =
            /*#__PURE__*/ (function (_JSONParserError2) {
              _inherits(UnmatchedParserError, _JSONParserError2);
              var _super4 = _createSuper(UnmatchedParserError);
              function UnmatchedParserError(source) {
                var _this6;
                _classCallCheck2(this, UnmatchedParserError);
                _this6 = _super4.call(
                  this,
                  'Could not find parser for "'.concat(source, '"'),
                  source
                );
                _this6.code = "EUNMATCHEDPARSER";
                return _this6;
              }
              return _createClass2(UnmatchedParserError);
            })(JSONParserError));
          setErrorName(UnmatchedParserError);
          var ResolverError = (exports.ResolverError = /*#__PURE__*/ (function (
            _JSONParserError3
          ) {
            _inherits(ResolverError, _JSONParserError3);
            var _super5 = _createSuper(ResolverError);
            function ResolverError(ex, source) {
              var _this7;
              _classCallCheck2(this, ResolverError);
              _this7 = _super5.call(
                this,
                ex.message || 'Error reading file "'.concat(source, '"'),
                source
              );
              _this7.code = "ERESOLVER";
              if ("code" in ex) {
                _this7.ioErrorCode = String(ex.code);
              }
              return _this7;
            }
            return _createClass2(ResolverError);
          })(JSONParserError));
          setErrorName(ResolverError);
          var UnmatchedResolverError = (exports.UnmatchedResolverError =
            /*#__PURE__*/ (function (_JSONParserError4) {
              _inherits(UnmatchedResolverError, _JSONParserError4);
              var _super6 = _createSuper(UnmatchedResolverError);
              function UnmatchedResolverError(source) {
                var _this8;
                _classCallCheck2(this, UnmatchedResolverError);
                _this8 = _super6.call(
                  this,
                  'Could not find resolver for "'.concat(source, '"'),
                  source
                );
                _this8.code = "EUNMATCHEDRESOLVER";
                return _this8;
              }
              return _createClass2(UnmatchedResolverError);
            })(JSONParserError));
          setErrorName(UnmatchedResolverError);
          var MissingPointerError = (exports.MissingPointerError =
            /*#__PURE__*/ (function (_JSONParserError5) {
              _inherits(MissingPointerError, _JSONParserError5);
              var _super7 = _createSuper(MissingPointerError);
              function MissingPointerError(token, path) {
                var _this9;
                _classCallCheck2(this, MissingPointerError);
                _this9 = _super7.call(
                  this,
                  'Token "'.concat(token, '" does not exist.'),
                  stripHash(path)
                );
                _this9.code = "EMISSINGPOINTER";
                return _this9;
              }
              return _createClass2(MissingPointerError);
            })(JSONParserError));
          setErrorName(MissingPointerError);
          var InvalidPointerError = (exports.InvalidPointerError =
            /*#__PURE__*/ (function (_JSONParserError6) {
              _inherits(InvalidPointerError, _JSONParserError6);
              var _super8 = _createSuper(InvalidPointerError);
              function InvalidPointerError(pointer, path) {
                var _this10;
                _classCallCheck2(this, InvalidPointerError);
                _this10 = _super8.call(
                  this,
                  'Invalid $ref pointer "'.concat(
                    pointer,
                    '". Pointers must begin with "#/"'
                  ),
                  stripHash(path)
                );
                _this10.code = "EINVALIDPOINTER";
                return _this10;
              }
              return _createClass2(InvalidPointerError);
            })(JSONParserError));
          setErrorName(InvalidPointerError);
          function setErrorName(err) {
            Object.defineProperty(err.prototype, "name", {
              value: err.name,
              enumerable: true
            });
          }
          exports.isHandledError = function (err) {
            return (
              err instanceof JSONParserError ||
              err instanceof JSONParserErrorGroup
            );
          };
          exports.normalizeError = function (err) {
            if (err.path === null) {
              err.path = [];
            }
            return err;
          };
        },
        { "./url": 19, "@jsdevtools/ono": 102 }
      ],
      18: [
        function (require, module, exports) {
          "use strict";
          /**
           * Returns the given plugins as an array, rather than an object map.
           * All other methods in this module expect an array of plugins rather than an object map.
           *
           * @param  {object} plugins - A map of plugin objects
           * @return {object[]}
           */ exports.all = function (plugins) {
            return Object.keys(plugins)
              .filter(function (key) {
                return _typeof2(plugins[key]) === "object";
              })
              .map(function (key) {
                plugins[key].name = key;
                return plugins[key];
              });
          };
          /**
           * Filters the given plugins, returning only the ones return `true` for the given method.
           *
           * @param  {object[]} plugins - An array of plugin objects
           * @param  {string}   method  - The name of the filter method to invoke for each plugin
           * @param  {object}   file    - A file info object, which will be passed to each method
           * @return {object[]}
           */ exports.filter = function (plugins, method, file) {
            return plugins.filter(function (plugin) {
              return !!getResult(plugin, method, file);
            });
          };
          /**
           * Sorts the given plugins, in place, by their `order` property.
           *
           * @param {object[]} plugins - An array of plugin objects
           * @returns {object[]}
           */ exports.sort = function (plugins) {
            var _iterator7 = _createForOfIteratorHelper(plugins),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                var plugin = _step7.value;
                plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            return plugins.sort(function (a, b) {
              return a.order - b.order;
            });
          };
          /**
           * Runs the specified method of the given plugins, in order, until one of them returns a successful result.
           * Each method can return a synchronous value, a Promise, or call an error-first callback.
           * If the promise resolves successfully, or the callback is called without an error, then the result
           * is immediately returned and no further plugins are called.
           * If the promise rejects, or the callback is called with an error, then the next plugin is called.
           * If ALL plugins fail, then the last error is thrown.
           *
           * @param {object[]}  plugins - An array of plugin objects
           * @param {string}    method  - The name of the method to invoke for each plugin
           * @param {object}    file    - A file info object, which will be passed to each method
           * @returns {Promise}
           */ exports.run = function (plugins, method, file, $refs) {
            var plugin,
              lastError,
              index = 0;
            return new Promise(function (resolve, reject) {
              runNextPlugin();
              function runNextPlugin() {
                plugin = plugins[index++];
                if (!plugin) {
                  // There are no more functions, so re-throw the last error
                  return reject(lastError);
                }
                try {
                  // console.log('  %s', plugin.name);
                  var result = getResult(plugin, method, file, callback, $refs);
                  if (result && typeof result.then === "function") {
                    // A promise was returned
                    result.then(onSuccess, onError);
                  } else if (result !== undefined) {
                    // A synchronous result was returned
                    onSuccess(result);
                  } else if (index === plugins.length) {
                    throw new Error(
                      "No promise has been returned or callback has been called."
                    );
                  }
                } catch (e) {
                  onError(e);
                }
              }
              function callback(err, result) {
                if (err) {
                  onError(err);
                } else {
                  onSuccess(result);
                }
              }
              function onSuccess(result) {
                // console.log('    success');
                resolve({ plugin: plugin, result: result });
              }
              function onError(error) {
                // console.log('    %s', err.message || err);
                lastError = { plugin: plugin, error: error };
                runNextPlugin();
              }
            });
          };
          /**
           * Returns the value of the given property.
           * If the property is a function, then the result of the function is returned.
           * If the value is a RegExp, then it will be tested against the file URL.
           * If the value is an aray, then it will be compared against the file extension.
           *
           * @param   {object}   obj        - The object whose property/method is called
           * @param   {string}   prop       - The name of the property/method to invoke
           * @param   {object}   file       - A file info object, which will be passed to the method
           * @param   {function} [callback] - A callback function, which will be passed to the method
           * @returns {*}
           */ function getResult(obj, prop, file, callback, $refs) {
            var value = obj[prop];
            if (typeof value === "function") {
              return value.apply(obj, [file, callback, $refs]);
            }
            if (!callback) {
              // The synchronous plugin functions (canParse and canRead)
              // allow a "shorthand" syntax, where the user can match
              // files by RegExp or by file extension.
              if (value instanceof RegExp) {
                return value.test(file.url);
              } else if (typeof value === "string") {
                return value === file.extension;
              } else if (Array.isArray(value)) {
                return value.indexOf(file.extension) !== -1;
              }
            }
            return value;
          }
        },
        {}
      ],
      19: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              "use strict";
              var isWindows = /^win/.test(process.platform),
                forwardSlashPattern = /\//g,
                protocolPattern = /^(\w{2,}):\/\//i,
                url = module.exports,
                jsonPointerSlash = /~1/g,
                jsonPointerTilde = /~0/g; // RegExp patterns to URL-encode special characters in local filesystem paths
              var urlEncodePatterns = [/\?/g, "%3F", /\#/g, "%23"]; // RegExp patterns to URL-decode special characters for local filesystem paths
              var urlDecodePatterns = [
                /\%23/g,
                "#",
                /\%24/g,
                "$",
                /\%26/g,
                "&",
                /\%2C/g,
                ",",
                /\%40/g,
                "@"
              ];
              exports.parse = require("url").parse;
              exports.resolve = require("url").resolve;
              /**
               * Returns the current working directory (in Node) or the current page URL (in browsers).
               *
               * @returns {string}
               */ exports.cwd = function cwd() {
                if (process.browser) {
                  return location.href;
                }
                var path = process.cwd();
                var lastChar = path.slice(-1);
                if (lastChar === "/" || lastChar === "\\") {
                  return path;
                } else {
                  return path + "/";
                }
              };
              /**
               * Returns the protocol of the given URL, or `undefined` if it has no protocol.
               *
               * @param   {string} path
               * @returns {?string}
               */ exports.getProtocol = function getProtocol(path) {
                var match = protocolPattern.exec(path);
                if (match) {
                  return match[1].toLowerCase();
                }
              };
              /**
               * Returns the lowercased file extension of the given URL,
               * or an empty string if it has no extension.
               *
               * @param   {string} path
               * @returns {string}
               */ exports.getExtension = function getExtension(path) {
                var lastDot = path.lastIndexOf(".");
                if (lastDot >= 0) {
                  return url.stripQuery(path.substr(lastDot).toLowerCase());
                }
                return "";
              };
              /**
               * Removes the query, if any, from the given path.
               *
               * @param   {string} path
               * @returns {string}
               */ exports.stripQuery = function stripQuery(path) {
                var queryIndex = path.indexOf("?");
                if (queryIndex >= 0) {
                  path = path.substr(0, queryIndex);
                }
                return path;
              };
              /**
               * Returns the hash (URL fragment), of the given path.
               * If there is no hash, then the root hash ("#") is returned.
               *
               * @param   {string} path
               * @returns {string}
               */ exports.getHash = function getHash(path) {
                var hashIndex = path.indexOf("#");
                if (hashIndex >= 0) {
                  return path.substr(hashIndex);
                }
                return "#";
              };
              /**
               * Removes the hash (URL fragment), if any, from the given path.
               *
               * @param   {string} path
               * @returns {string}
               */ exports.stripHash = function stripHash(path) {
                var hashIndex = path.indexOf("#");
                if (hashIndex >= 0) {
                  path = path.substr(0, hashIndex);
                }
                return path;
              };
              /**
               * Determines whether the given path is an HTTP(S) URL.
               *
               * @param   {string} path
               * @returns {boolean}
               */ exports.isHttp = function isHttp(path) {
                var protocol = url.getProtocol(path);
                if (protocol === "http" || protocol === "https") {
                  return true;
                } else if (protocol === undefined) {
                  // There is no protocol.  If we're running in a browser, then assume it's HTTP.
                  return process.browser;
                } else {
                  // It's some other protocol, such as "ftp://", "mongodb://", etc.
                  return false;
                }
              };
              /**
               * Determines whether the given path is a filesystem path.
               * This includes "file://" URLs.
               *
               * @param   {string} path
               * @returns {boolean}
               */ exports.isFileSystemPath = function isFileSystemPath(path) {
                if (process.browser) {
                  // We're running in a browser, so assume that all paths are URLs.
                  // This way, even relative paths will be treated as URLs rather than as filesystem paths
                  return false;
                }
                var protocol = url.getProtocol(path);
                return protocol === undefined || protocol === "file";
              };
              /**
               * Converts a filesystem path to a properly-encoded URL.
               *
               * This is intended to handle situations where JSON Schema $Ref Parser is called
               * with a filesystem path that contains characters which are not allowed in URLs.
               *
               * @example
               * The following filesystem paths would be converted to the following URLs:
               *
               *    <"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\'%3E.json
               *    C:\\My Documents\\File (1).json   ==>   C:/My%20Documents/File%20(1).json
               *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json
               *
               * @param {string} path
               * @returns {string}
               */ exports.fromFileSystemPath = function fromFileSystemPath(path) {
                // Step 1: On Windows, replace backslashes with forward slashes,
                // rather than encoding them as "%5C"
                if (isWindows) {
                  path = path.replace(/\\/g, "/");
                } // Step 2: `encodeURI` will take care of MOST characters
                path = encodeURI(path); // Step 3: Manually encode characters that are not encoded by `encodeURI`.
                // This includes characters such as "#" and "?", which have special meaning in URLs,
                // but are just normal characters in a filesystem path.
                for (var i = 0; i < urlEncodePatterns.length; i += 2) {
                  path = path.replace(
                    urlEncodePatterns[i],
                    urlEncodePatterns[i + 1]
                  );
                }
                return path;
              };
              /**
               * Converts a URL to a local filesystem path.
               *
               * @param {string}  path
               * @param {boolean} [keepFileProtocol] - If true, then "file://" will NOT be stripped
               * @returns {string}
               */ exports.toFileSystemPath = function toFileSystemPath(
                path,
                keepFileProtocol
              ) {
                // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.
                path = decodeURI(path); // Step 2: Manually decode characters that are not decoded by `decodeURI`.
                // This includes characters such as "#" and "?", which have special meaning in URLs,
                // but are just normal characters in a filesystem path.
                for (var i = 0; i < urlDecodePatterns.length; i += 2) {
                  path = path.replace(
                    urlDecodePatterns[i],
                    urlDecodePatterns[i + 1]
                  );
                } // Step 3: If it's a "file://" URL, then format it consistently
                // or convert it to a local filesystem path
                var isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
                if (isFileUrl) {
                  // Strip-off the protocol, and the initial "/", if there is one
                  path = path[7] === "/" ? path.substr(8) : path.substr(7); // insert a colon (":") after the drive letter on Windows
                  if (isWindows && path[1] === "/") {
                    path = path[0] + ":" + path.substr(1);
                  }
                  if (keepFileProtocol) {
                    // Return the consistently-formatted "file://" URL
                    path = "file:///" + path;
                  } else {
                    // Convert the "file://" URL to a local filesystem path.
                    // On Windows, it will start with something like "C:/".
                    // On Posix, it will start with "/"
                    isFileUrl = false;
                    path = isWindows ? path : "/" + path;
                  }
                } // Step 4: Normalize Windows paths (unless it's a "file://" URL)
                if (isWindows && !isFileUrl) {
                  // Replace forward slashes with backslashes
                  path = path.replace(forwardSlashPattern, "\\"); // Capitalize the drive letter
                  if (path.substr(1, 2) === ":\\") {
                    path = path[0].toUpperCase() + path.substr(1);
                  }
                }
                return path;
              };
              /**
               * Converts a $ref pointer to a valid JSON Path.
               *
               * @param {string}  pointer
               * @returns {Array<number | string>}
               */ exports.safePointerToPath = function safePointerToPath(
                pointer
              ) {
                if (
                  pointer.length <= 1 ||
                  pointer[0] !== "#" ||
                  pointer[1] !== "/"
                ) {
                  return [];
                }
                return pointer
                  .slice(2)
                  .split("/")
                  .map(function (value) {
                    return decodeURIComponent(value)
                      .replace(jsonPointerSlash, "/")
                      .replace(jsonPointerTilde, "~");
                  });
              };
            }.call(this));
          }.call(this, require("_process")));
        },
        { _process: 246, url: 272 }
      ],
      20: [
        function (require, module, exports) {
          "use strict";
          var loader = require("./lib/loader");
          var dumper = require("./lib/dumper");
          function renamed(from, to) {
            return function () {
              throw new Error(
                "Function yaml." +
                  from +
                  " is removed in js-yaml 4. " +
                  "Use yaml." +
                  to +
                  " instead, which is now safe by default."
              );
            };
          }
          module.exports.Type = require("./lib/type");
          module.exports.Schema = require("./lib/schema");
          module.exports.FAILSAFE_SCHEMA = require("./lib/schema/failsafe");
          module.exports.JSON_SCHEMA = require("./lib/schema/json");
          module.exports.CORE_SCHEMA = require("./lib/schema/core");
          module.exports.DEFAULT_SCHEMA = require("./lib/schema/default");
          module.exports.load = loader.load;
          module.exports.loadAll = loader.loadAll;
          module.exports.dump = dumper.dump;
          module.exports.YAMLException = require("./lib/exception"); // Re-export all types in case user wants to create custom schema
          module.exports.types = {
            binary: require("./lib/type/binary"),
            float: require("./lib/type/float"),
            map: require("./lib/type/map"),
            null: require("./lib/type/null"),
            pairs: require("./lib/type/pairs"),
            set: require("./lib/type/set"),
            timestamp: require("./lib/type/timestamp"),
            bool: require("./lib/type/bool"),
            int: require("./lib/type/int"),
            merge: require("./lib/type/merge"),
            omap: require("./lib/type/omap"),
            seq: require("./lib/type/seq"),
            str: require("./lib/type/str")
          }; // Removed functions from JS-YAML 3.0.x
          module.exports.safeLoad = renamed("safeLoad", "load");
          module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
          module.exports.safeDump = renamed("safeDump", "dump");
        },
        {
          "./lib/dumper": 22,
          "./lib/exception": 23,
          "./lib/loader": 24,
          "./lib/schema": 25,
          "./lib/schema/core": 26,
          "./lib/schema/default": 27,
          "./lib/schema/failsafe": 28,
          "./lib/schema/json": 29,
          "./lib/type": 31,
          "./lib/type/binary": 32,
          "./lib/type/bool": 33,
          "./lib/type/float": 34,
          "./lib/type/int": 35,
          "./lib/type/map": 36,
          "./lib/type/merge": 37,
          "./lib/type/null": 38,
          "./lib/type/omap": 39,
          "./lib/type/pairs": 40,
          "./lib/type/seq": 41,
          "./lib/type/set": 42,
          "./lib/type/str": 43,
          "./lib/type/timestamp": 44
        }
      ],
      21: [
        function (require, module, exports) {
          "use strict";
          function isNothing(subject) {
            return typeof subject === "undefined" || subject === null;
          }
          function isObject(subject) {
            return _typeof2(subject) === "object" && subject !== null;
          }
          function toArray(sequence) {
            if (Array.isArray(sequence)) return sequence;
            else if (isNothing(sequence)) return [];
            return [sequence];
          }
          function extend(target, source) {
            var index, length, key, sourceKeys;
            if (source) {
              sourceKeys = Object.keys(source);
              for (
                index = 0, length = sourceKeys.length;
                index < length;
                index += 1
              ) {
                key = sourceKeys[index];
                target[key] = source[key];
              }
            }
            return target;
          }
          function repeat(string, count) {
            var result = "",
              cycle;
            for (cycle = 0; cycle < count; cycle += 1) {
              result += string;
            }
            return result;
          }
          function isNegativeZero(number) {
            return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
          }
          module.exports.isNothing = isNothing;
          module.exports.isObject = isObject;
          module.exports.toArray = toArray;
          module.exports.repeat = repeat;
          module.exports.isNegativeZero = isNegativeZero;
          module.exports.extend = extend;
        },
        {}
      ],
      22: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable no-use-before-define*/ var common = require("./common");
          var YAMLException = require("./exception");
          var DEFAULT_SCHEMA = require("./schema/default");
          var _toString = Object.prototype.toString;
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CHAR_BOM = 0xfeff;
          var CHAR_TAB = 0x09;
          /* Tab */ var CHAR_LINE_FEED = 0x0a;
          /* LF */ var CHAR_CARRIAGE_RETURN = 0x0d;
          /* CR */ var CHAR_SPACE = 0x20;
          /* Space */ var CHAR_EXCLAMATION = 0x21;
          /* ! */ var CHAR_DOUBLE_QUOTE = 0x22;
          /* " */ var CHAR_SHARP = 0x23;
          /* # */ var CHAR_PERCENT = 0x25;
          /* % */ var CHAR_AMPERSAND = 0x26;
          /* & */ var CHAR_SINGLE_QUOTE = 0x27;
          /* ' */ var CHAR_ASTERISK = 0x2a;
          /* * */ var CHAR_COMMA = 0x2c;
          /* , */ var CHAR_MINUS = 0x2d;
          /* - */ var CHAR_COLON = 0x3a;
          /* : */ var CHAR_EQUALS = 0x3d;
          /* = */ var CHAR_GREATER_THAN = 0x3e;
          /* > */ var CHAR_QUESTION = 0x3f;
          /* ? */ var CHAR_COMMERCIAL_AT = 0x40;
          /* @ */ var CHAR_LEFT_SQUARE_BRACKET = 0x5b;
          /* [ */ var CHAR_RIGHT_SQUARE_BRACKET = 0x5d;
          /* ] */ var CHAR_GRAVE_ACCENT = 0x60;
          /* ` */ var CHAR_LEFT_CURLY_BRACKET = 0x7b;
          /* { */ var CHAR_VERTICAL_LINE = 0x7c;
          /* | */ var CHAR_RIGHT_CURLY_BRACKET = 0x7d;
          /* } */ var ESCAPE_SEQUENCES = {};
          ESCAPE_SEQUENCES[0x00] = "\\0";
          ESCAPE_SEQUENCES[0x07] = "\\a";
          ESCAPE_SEQUENCES[0x08] = "\\b";
          ESCAPE_SEQUENCES[0x09] = "\\t";
          ESCAPE_SEQUENCES[0x0a] = "\\n";
          ESCAPE_SEQUENCES[0x0b] = "\\v";
          ESCAPE_SEQUENCES[0x0c] = "\\f";
          ESCAPE_SEQUENCES[0x0d] = "\\r";
          ESCAPE_SEQUENCES[0x1b] = "\\e";
          ESCAPE_SEQUENCES[0x22] = '\\"';
          ESCAPE_SEQUENCES[0x5c] = "\\\\";
          ESCAPE_SEQUENCES[0x85] = "\\N";
          ESCAPE_SEQUENCES[0xa0] = "\\_";
          ESCAPE_SEQUENCES[0x2028] = "\\L";
          ESCAPE_SEQUENCES[0x2029] = "\\P";
          var DEPRECATED_BOOLEANS_SYNTAX = [
            "y",
            "Y",
            "yes",
            "Yes",
            "YES",
            "on",
            "On",
            "ON",
            "n",
            "N",
            "no",
            "No",
            "NO",
            "off",
            "Off",
            "OFF"
          ];
          var DEPRECATED_BASE60_SYNTAX =
            /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
          function compileStyleMap(schema, map) {
            var result, keys, index, length, tag, style, type;
            if (map === null) return {};
            result = {};
            keys = Object.keys(map);
            for (index = 0, length = keys.length; index < length; index += 1) {
              tag = keys[index];
              style = String(map[tag]);
              if (tag.slice(0, 2) === "!!") {
                tag = "tag:yaml.org,2002:" + tag.slice(2);
              }
              type = schema.compiledTypeMap["fallback"][tag];
              if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                style = type.styleAliases[style];
              }
              result[tag] = style;
            }
            return result;
          }
          function encodeHex(character) {
            var string, handle, length;
            string = character.toString(16).toUpperCase();
            if (character <= 0xff) {
              handle = "x";
              length = 2;
            } else if (character <= 0xffff) {
              handle = "u";
              length = 4;
            } else if (character <= 0xffffffff) {
              handle = "U";
              length = 8;
            } else {
              throw new YAMLException(
                "code point within a string may not be greater than 0xFFFFFFFF"
              );
            }
            return (
              "\\" + handle + common.repeat("0", length - string.length) + string
            );
          }
          var QUOTING_TYPE_SINGLE = 1,
            QUOTING_TYPE_DOUBLE = 2;
          function State(options) {
            this.schema = options["schema"] || DEFAULT_SCHEMA;
            this.indent = Math.max(1, options["indent"] || 2);
            this.noArrayIndent = options["noArrayIndent"] || false;
            this.skipInvalid = options["skipInvalid"] || false;
            this.flowLevel = common.isNothing(options["flowLevel"])
              ? -1
              : options["flowLevel"];
            this.styleMap = compileStyleMap(
              this.schema,
              options["styles"] || null
            );
            this.sortKeys = options["sortKeys"] || false;
            this.lineWidth = options["lineWidth"] || 80;
            this.noRefs = options["noRefs"] || false;
            this.noCompatMode = options["noCompatMode"] || false;
            this.condenseFlow = options["condenseFlow"] || false;
            this.quotingType =
              options["quotingType"] === '"'
                ? QUOTING_TYPE_DOUBLE
                : QUOTING_TYPE_SINGLE;
            this.forceQuotes = options["forceQuotes"] || false;
            this.replacer =
              typeof options["replacer"] === "function"
                ? options["replacer"]
                : null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.explicitTypes = this.schema.compiledExplicit;
            this.tag = null;
            this.result = "";
            this.duplicates = [];
            this.usedDuplicates = null;
          } // Indents every line in a string. Empty lines (\n only) are not indented.
          function indentString(string, spaces) {
            var ind = common.repeat(" ", spaces),
              position = 0,
              next = -1,
              result = "",
              line,
              length = string.length;
            while (position < length) {
              next = string.indexOf("\n", position);
              if (next === -1) {
                line = string.slice(position);
                position = length;
              } else {
                line = string.slice(position, next + 1);
                position = next + 1;
              }
              if (line.length && line !== "\n") result += ind;
              result += line;
            }
            return result;
          }
          function generateNextLine(state, level) {
            return "\n" + common.repeat(" ", state.indent * level);
          }
          function testImplicitResolving(state, str) {
            var index, length, type;
            for (
              index = 0, length = state.implicitTypes.length;
              index < length;
              index += 1
            ) {
              type = state.implicitTypes[index];
              if (type.resolve(str)) {
                return true;
              }
            }
            return false;
          } // [33] s-white ::= s-space | s-tab
          function isWhitespace(c) {
            return c === CHAR_SPACE || c === CHAR_TAB;
          } // Returns true if the character can be printed without escaping.
          // From YAML 1.2: "any allowed characters known to be non-printable
          // should also be escaped. [However,] This isn’t mandatory"
          // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
          function isPrintable(c) {
            return (
              (0x00020 <= c && c <= 0x00007e) ||
              (0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
              (0x0e000 <= c && c <= 0x00fffd && c !== CHAR_BOM) ||
              (0x10000 <= c && c <= 0x10ffff)
            );
          } // [34] ns-char ::= nb-char - s-white
          // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
          // [26] b-char  ::= b-line-feed | b-carriage-return
          // Including s-white (for some reason, examples doesn't match specs in this aspect)
          // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
          function isNsCharOrWhitespace(c) {
            return (
              isPrintable(c) &&
              c !== CHAR_BOM && // - b-char
              c !== CHAR_CARRIAGE_RETURN &&
              c !== CHAR_LINE_FEED
            );
          } // [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
          //                             c = flow-in   ⇒ ns-plain-safe-in
          //                             c = block-key ⇒ ns-plain-safe-out
          //                             c = flow-key  ⇒ ns-plain-safe-in
          // [128] ns-plain-safe-out ::= ns-char
          // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
          // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
          //                            | ( /* An ns-char preceding */ “#” )
          //                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
          function isPlainSafe(c, prev, inblock) {
            var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
            var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
            return (
              (// ns-plain-safe
              (inblock // c = flow-in
                ? cIsNsCharOrWhitespace
                : cIsNsCharOrWhitespace && // - c-flow-indicator
                  c !== CHAR_COMMA &&
                  c !== CHAR_LEFT_SQUARE_BRACKET &&
                  c !== CHAR_RIGHT_SQUARE_BRACKET &&
                  c !== CHAR_LEFT_CURLY_BRACKET &&
                  c !== CHAR_RIGHT_CURLY_BRACKET) && // ns-plain-char
                c !== CHAR_SHARP && // false on '#'
                !(prev === CHAR_COLON && !cIsNsChar)) || // false on ': '
              (isNsCharOrWhitespace(prev) &&
                !isWhitespace(prev) &&
                c === CHAR_SHARP) || // change to true on '[^ ]#'
              (prev === CHAR_COLON && cIsNsChar)
            ); // change to true on ':[^ ]'
          } // Simplified test for values allowed as the first character in plain style.
          function isPlainSafeFirst(c) {
            // Uses a subset of ns-char - c-indicator
            // where ns-char = nb-char - s-white.
            // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
            return (
              isPrintable(c) &&
              c !== CHAR_BOM &&
              !isWhitespace(c) && // - s-white
              // - (c-indicator ::=
              // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
              c !== CHAR_MINUS &&
              c !== CHAR_QUESTION &&
              c !== CHAR_COLON &&
              c !== CHAR_COMMA &&
              c !== CHAR_LEFT_SQUARE_BRACKET &&
              c !== CHAR_RIGHT_SQUARE_BRACKET &&
              c !== CHAR_LEFT_CURLY_BRACKET &&
              c !== CHAR_RIGHT_CURLY_BRACKET && // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
              c !== CHAR_SHARP &&
              c !== CHAR_AMPERSAND &&
              c !== CHAR_ASTERISK &&
              c !== CHAR_EXCLAMATION &&
              c !== CHAR_VERTICAL_LINE &&
              c !== CHAR_EQUALS &&
              c !== CHAR_GREATER_THAN &&
              c !== CHAR_SINGLE_QUOTE &&
              c !== CHAR_DOUBLE_QUOTE && // | “%” | “@” | “`”)
              c !== CHAR_PERCENT &&
              c !== CHAR_COMMERCIAL_AT &&
              c !== CHAR_GRAVE_ACCENT
            );
          } // Simplified test for values allowed as the last character in plain style.
          function isPlainSafeLast(c) {
            // just not whitespace or colon, it will be checked to be plain character later
            return !isWhitespace(c) && c !== CHAR_COLON;
          } // Same as 'string'.codePointAt(pos), but works in older browsers.
          function codePointAt(string, pos) {
            var first = string.charCodeAt(pos),
              second;
            if (first >= 0xd800 && first <= 0xdbff && pos + 1 < string.length) {
              second = string.charCodeAt(pos + 1);
              if (second >= 0xdc00 && second <= 0xdfff) {
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                return (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
              }
            }
            return first;
          } // Determines whether block indentation indicator is required.
          function needIndentIndicator(string) {
            var leadingSpaceRe = /^\n* /;
            return leadingSpaceRe.test(string);
          }
          var STYLE_PLAIN = 1,
            STYLE_SINGLE = 2,
            STYLE_LITERAL = 3,
            STYLE_FOLDED = 4,
            STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
          // lineWidth = -1 => no limit.
          // Pre-conditions: str.length > 0.
          // Post-conditions:
          //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
          //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
          //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
          function chooseScalarStyle(
            string,
            singleLineOnly,
            indentPerLevel,
            lineWidth,
            testAmbiguousType,
            quotingType,
            forceQuotes,
            inblock
          ) {
            var i;
            var _char = 0;
            var prevChar = null;
            var hasLineBreak = false;
            var hasFoldableLine = false; // only checked if shouldTrackWidth
            var shouldTrackWidth = lineWidth !== -1;
            var previousLineBreak = -1; // count the first line correctly
            var plain =
              isPlainSafeFirst(codePointAt(string, 0)) &&
              isPlainSafeLast(codePointAt(string, string.length - 1));
            if (singleLineOnly || forceQuotes) {
              // Case: no block styles.
              // Check for disallowed characters to rule out plain and single.
              for (i = 0; i < string.length; _char >= 0x10000 ? (i += 2) : i++) {
                _char = codePointAt(string, i);
                if (!isPrintable(_char)) {
                  return STYLE_DOUBLE;
                }
                plain = plain && isPlainSafe(_char, prevChar, inblock);
                prevChar = _char;
              }
            } else {
              // Case: block styles permitted.
              for (i = 0; i < string.length; _char >= 0x10000 ? (i += 2) : i++) {
                _char = codePointAt(string, i);
                if (_char === CHAR_LINE_FEED) {
                  hasLineBreak = true; // Check if any line can be folded.
                  if (shouldTrackWidth) {
                    hasFoldableLine =
                      hasFoldableLine || // Foldable line = too long, and not more-indented.
                      (i - previousLineBreak - 1 > lineWidth &&
                        string[previousLineBreak + 1] !== " ");
                    previousLineBreak = i;
                  }
                } else if (!isPrintable(_char)) {
                  return STYLE_DOUBLE;
                }
                plain = plain && isPlainSafe(_char, prevChar, inblock);
                prevChar = _char;
              } // in case the end is missing a \n
              hasFoldableLine =
                hasFoldableLine ||
                (shouldTrackWidth &&
                  i - previousLineBreak - 1 > lineWidth &&
                  string[previousLineBreak + 1] !== " ");
            } // Although every style can represent \n without escaping, prefer block styles
            // for multiline, since they're more readable and they don't add empty lines.
            // Also prefer folding a super-long line.
            if (!hasLineBreak && !hasFoldableLine) {
              // Strings interpretable as another type have to be quoted;
              // e.g. the string 'true' vs. the boolean true.
              if (plain && !forceQuotes && !testAmbiguousType(string)) {
                return STYLE_PLAIN;
              }
              return quotingType === QUOTING_TYPE_DOUBLE
                ? STYLE_DOUBLE
                : STYLE_SINGLE;
            } // Edge case: block indentation indicator can only have one digit.
            if (indentPerLevel > 9 && needIndentIndicator(string)) {
              return STYLE_DOUBLE;
            } // At this point we know block styles are valid.
            // Prefer literal style unless we want to fold.
            if (!forceQuotes) {
              return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
            }
            return quotingType === QUOTING_TYPE_DOUBLE
              ? STYLE_DOUBLE
              : STYLE_SINGLE;
          } // Note: line breaking/folding is implemented for only the folded style.
          // NB. We drop the last trailing newline (if any) of a returned block scalar
          //  since the dumper adds its own newline. This always works:
          //    • No ending newline => unaffected; already using strip "-" chomping.
          //    • Ending newline    => removed then restored.
          //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
          function writeScalar(state, string, level, iskey, inblock) {
            state.dump = (function () {
              if (string.length === 0) {
                return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
              }
              if (!state.noCompatMode) {
                if (
                  DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 ||
                  DEPRECATED_BASE60_SYNTAX.test(string)
                ) {
                  return state.quotingType === QUOTING_TYPE_DOUBLE
                    ? '"' + string + '"'
                    : "'" + string + "'";
                }
              }
              var indent = state.indent * Math.max(1, level); // no 0-indent scalars
              // As indentation gets deeper, let the width decrease monotonically
              // to the lower bound min(state.lineWidth, 40).
              // Note that this implies
              //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
              //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
              // This behaves better than a constant minimum width which disallows narrower options,
              // or an indent threshold which causes the width to suddenly increase.
              var lineWidth =
                state.lineWidth === -1
                  ? -1
                  : Math.max(
                      Math.min(state.lineWidth, 40),
                      state.lineWidth - indent
                    ); // Without knowing if keys are implicit/explicit, assume implicit for safety.
              var singleLineOnly =
                iskey || // No block styles in flow mode.
                (state.flowLevel > -1 && level >= state.flowLevel);
              function testAmbiguity(string) {
                return testImplicitResolving(state, string);
              }
              switch (
                chooseScalarStyle(
                  string,
                  singleLineOnly,
                  state.indent,
                  lineWidth,
                  testAmbiguity,
                  state.quotingType,
                  state.forceQuotes && !iskey,
                  inblock
                )
              ) {
                case STYLE_PLAIN:
                  return string;
                case STYLE_SINGLE:
                  return "'" + string.replace(/'/g, "''") + "'";
                case STYLE_LITERAL:
                  return (
                    "|" +
                    blockHeader(string, state.indent) +
                    dropEndingNewline(indentString(string, indent))
                  );
                case STYLE_FOLDED:
                  return (
                    ">" +
                    blockHeader(string, state.indent) +
                    dropEndingNewline(
                      indentString(foldString(string, lineWidth), indent)
                    )
                  );
                case STYLE_DOUBLE:
                  return '"' + escapeString(string, lineWidth) + '"';
                default:
                  throw new YAMLException(
                    "impossible error: invalid scalar style"
                  );
              }
            })();
          } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
          function blockHeader(string, indentPerLevel) {
            var indentIndicator = needIndentIndicator(string)
              ? String(indentPerLevel)
              : ""; // note the special case: the string '\n' counts as a "trailing" empty line.
            var clip = string[string.length - 1] === "\n";
            var keep =
              clip && (string[string.length - 2] === "\n" || string === "\n");
            var chomp = keep ? "+" : clip ? "" : "-";
            return indentIndicator + chomp + "\n";
          } // (See the note for writeScalar.)
          function dropEndingNewline(string) {
            return string[string.length - 1] === "\n"
              ? string.slice(0, -1)
              : string;
          } // Note: a long line without a suitable break point will exceed the width limit.
          // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
          function foldString(string, width) {
            // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
            // unless they're before or after a more-indented line, or at the very
            // beginning or end, in which case $k$ maps to $k$.
            // Therefore, parse each chunk as newline(s) followed by a content line.
            var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)
            var result = (function () {
              var nextLF = string.indexOf("\n");
              nextLF = nextLF !== -1 ? nextLF : string.length;
              lineRe.lastIndex = nextLF;
              return foldLine(string.slice(0, nextLF), width);
            })(); // If we haven't reached the first content line yet, don't add an extra \n.
            var prevMoreIndented = string[0] === "\n" || string[0] === " ";
            var moreIndented; // rest of the lines
            var match;
            while ((match = lineRe.exec(string))) {
              var prefix = match[1],
                line = match[2];
              moreIndented = line[0] === " ";
              result +=
                prefix +
                (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") +
                foldLine(line, width);
              prevMoreIndented = moreIndented;
            }
            return result;
          } // Greedy line breaking.
          // Picks the longest line under the limit each time,
          // otherwise settles for the shortest line over the limit.
          // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
          function foldLine(line, width) {
            if (line === "" || line[0] === " ") return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.
            var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
            var match; // start is an inclusive index. end, curr, and next are exclusive.
            var start = 0,
              end,
              curr = 0,
              next = 0;
            var result = ""; // Invariants: 0 <= start <= length-1.
            //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
            // Inside the loop:
            //   A match implies length >= 2, so curr and next are <= length-2.
            while ((match = breakRe.exec(line))) {
              next = match.index; // maintain invariant: curr - start <= width
              if (next - start > width) {
                end = curr > start ? curr : next; // derive end <= length-2
                result += "\n" + line.slice(start, end); // skip the space that was output as \n
                start = end + 1; // derive start <= length-1
              }
              curr = next;
            } // By the invariants, start <= length-1, so there is something left over.
            // It is either the whole string or a part starting from non-whitespace.
            result += "\n"; // Insert a break if the remainder is too long and there is a break available.
            if (line.length - start > width && curr > start) {
              result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
            } else {
              result += line.slice(start);
            }
            return result.slice(1); // drop extra \n joiner
          } // Escapes a double-quoted string.
          function escapeString(string) {
            var result = "";
            var _char2 = 0;
            var escapeSeq;
            for (
              var i = 0;
              i < string.length;
              _char2 >= 0x10000 ? (i += 2) : i++
            ) {
              _char2 = codePointAt(string, i);
              escapeSeq = ESCAPE_SEQUENCES[_char2];
              if (!escapeSeq && isPrintable(_char2)) {
                result += string[i];
                if (_char2 >= 0x10000) result += string[i + 1];
              } else {
                result += escapeSeq || encodeHex(_char2);
              }
            }
            return result;
          }
          function writeFlowSequence(state, level, object) {
            var _result = "",
              _tag = state.tag,
              index,
              length,
              value;
            for (index = 0, length = object.length; index < length; index += 1) {
              value = object[index];
              if (state.replacer) {
                value = state.replacer.call(object, String(index), value);
              } // Write only valid elements, put null instead of invalid elements.
              if (
                writeNode(state, level, value, false, false) ||
                (typeof value === "undefined" &&
                  writeNode(state, level, null, false, false))
              ) {
                if (_result !== "")
                  _result += "," + (!state.condenseFlow ? " " : "");
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = "[" + _result + "]";
          }
          function writeBlockSequence(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              index,
              length,
              value;
            for (index = 0, length = object.length; index < length; index += 1) {
              value = object[index];
              if (state.replacer) {
                value = state.replacer.call(object, String(index), value);
              } // Write only valid elements, put null instead of invalid elements.
              if (
                writeNode(state, level + 1, value, true, true, false, true) ||
                (typeof value === "undefined" &&
                  writeNode(state, level + 1, null, true, true, false, true))
              ) {
                if (!compact || _result !== "") {
                  _result += generateNextLine(state, level);
                }
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  _result += "-";
                } else {
                  _result += "- ";
                }
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = _result || "[]"; // Empty sequence if no valid values.
          }
          function writeFlowMapping(state, level, object) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              pairBuffer;
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (_result !== "") pairBuffer += ", ";
              if (state.condenseFlow) pairBuffer += '"';
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (state.replacer) {
                objectValue = state.replacer.call(object, objectKey, objectValue);
              }
              if (!writeNode(state, level, objectKey, false, false)) {
                continue; // Skip this pair because of invalid key;
              }
              if (state.dump.length > 1024) pairBuffer += "? ";
              pairBuffer +=
                state.dump +
                (state.condenseFlow ? '"' : "") +
                ":" +
                (state.condenseFlow ? "" : " ");
              if (!writeNode(state, level, objectValue, false, false)) {
                continue; // Skip this pair because of invalid value.
              }
              pairBuffer += state.dump; // Both key and value are valid.
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = "{" + _result + "}";
          }
          function writeBlockMapping(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              explicitPair,
              pairBuffer; // Allow sorting keys so that the output file is deterministic
            if (state.sortKeys === true) {
              // Default sorting
              objectKeyList.sort();
            } else if (typeof state.sortKeys === "function") {
              // Custom sort function
              objectKeyList.sort(state.sortKeys);
            } else if (state.sortKeys) {
              // Something is wrong
              throw new YAMLException("sortKeys must be a boolean or a function");
            }
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (!compact || _result !== "") {
                pairBuffer += generateNextLine(state, level);
              }
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (state.replacer) {
                objectValue = state.replacer.call(object, objectKey, objectValue);
              }
              if (!writeNode(state, level + 1, objectKey, true, true, true)) {
                continue; // Skip this pair because of invalid key.
              }
              explicitPair =
                (state.tag !== null && state.tag !== "?") ||
                (state.dump && state.dump.length > 1024);
              if (explicitPair) {
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += "?";
                } else {
                  pairBuffer += "? ";
                }
              }
              pairBuffer += state.dump;
              if (explicitPair) {
                pairBuffer += generateNextLine(state, level);
              }
              if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                continue; // Skip this pair because of invalid value.
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += ":";
              } else {
                pairBuffer += ": ";
              }
              pairBuffer += state.dump; // Both key and value are valid.
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = _result || "{}"; // Empty mapping if no valid pairs.
          }
          function detectType(state, object, explicit) {
            var _result, typeList, index, length, type, style;
            typeList = explicit ? state.explicitTypes : state.implicitTypes;
            for (
              index = 0, length = typeList.length;
              index < length;
              index += 1
            ) {
              type = typeList[index];
              if (
                (type.instanceOf || type.predicate) &&
                (!type.instanceOf ||
                  (_typeof2(object) === "object" &&
                    object instanceof type.instanceOf)) &&
                (!type.predicate || type.predicate(object))
              ) {
                if (explicit) {
                  if (type.multi && type.representName) {
                    state.tag = type.representName(object);
                  } else {
                    state.tag = type.tag;
                  }
                } else {
                  state.tag = "?";
                }
                if (type.represent) {
                  style = state.styleMap[type.tag] || type.defaultStyle;
                  if (_toString.call(type.represent) === "[object Function]") {
                    _result = type.represent(object, style);
                  } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                  } else {
                    throw new YAMLException(
                      "!<" +
                        type.tag +
                        '> tag resolver accepts not "' +
                        style +
                        '" style'
                    );
                  }
                  state.dump = _result;
                }
                return true;
              }
            }
            return false;
          } // Serializes `object` and writes it to global `result`.
          // Returns true on success, or false on invalid object.
          //
          function writeNode(
            state,
            level,
            object,
            block,
            compact,
            iskey,
            isblockseq
          ) {
            state.tag = null;
            state.dump = object;
            if (!detectType(state, object, false)) {
              detectType(state, object, true);
            }
            var type = _toString.call(state.dump);
            var inblock = block;
            var tagStr;
            if (block) {
              block = state.flowLevel < 0 || state.flowLevel > level;
            }
            var objectOrArray =
                type === "[object Object]" || type === "[object Array]",
              duplicateIndex,
              duplicate;
            if (objectOrArray) {
              duplicateIndex = state.duplicates.indexOf(object);
              duplicate = duplicateIndex !== -1;
            }
            if (
              (state.tag !== null && state.tag !== "?") ||
              duplicate ||
              (state.indent !== 2 && level > 0)
            ) {
              compact = false;
            }
            if (duplicate && state.usedDuplicates[duplicateIndex]) {
              state.dump = "*ref_" + duplicateIndex;
            } else {
              if (
                objectOrArray &&
                duplicate &&
                !state.usedDuplicates[duplicateIndex]
              ) {
                state.usedDuplicates[duplicateIndex] = true;
              }
              if (type === "[object Object]") {
                if (block && Object.keys(state.dump).length !== 0) {
                  writeBlockMapping(state, level, state.dump, compact);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowMapping(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object Array]") {
                if (block && state.dump.length !== 0) {
                  if (state.noArrayIndent && !isblockseq && level > 0) {
                    writeBlockSequence(state, level - 1, state.dump, compact);
                  } else {
                    writeBlockSequence(state, level, state.dump, compact);
                  }
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowSequence(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object String]") {
                if (state.tag !== "?") {
                  writeScalar(state, state.dump, level, iskey, inblock);
                }
              } else if (type === "[object Undefined]") {
                return false;
              } else {
                if (state.skipInvalid) return false;
                throw new YAMLException(
                  "unacceptable kind of an object to dump " + type
                );
              }
              if (state.tag !== null && state.tag !== "?") {
                // Need to encode all characters except those allowed by the spec:
                //
                // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
                // [36] ns-hex-digit    ::=  ns-dec-digit
                //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
                // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
                // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
                // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
                //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
                //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
                //
                // Also need to encode '!' because it has special meaning (end of tag prefix).
                //
                tagStr = encodeURI(
                  state.tag[0] === "!" ? state.tag.slice(1) : state.tag
                ).replace(/!/g, "%21");
                if (state.tag[0] === "!") {
                  tagStr = "!" + tagStr;
                } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
                  tagStr = "!!" + tagStr.slice(18);
                } else {
                  tagStr = "!<" + tagStr + ">";
                }
                state.dump = tagStr + " " + state.dump;
              }
            }
            return true;
          }
          function getDuplicateReferences(object, state) {
            var objects = [],
              duplicatesIndexes = [],
              index,
              length;
            inspectNode(object, objects, duplicatesIndexes);
            for (
              index = 0, length = duplicatesIndexes.length;
              index < length;
              index += 1
            ) {
              state.duplicates.push(objects[duplicatesIndexes[index]]);
            }
            state.usedDuplicates = new Array(length);
          }
          function inspectNode(object, objects, duplicatesIndexes) {
            var objectKeyList, index, length;
            if (object !== null && _typeof2(object) === "object") {
              index = objects.indexOf(object);
              if (index !== -1) {
                if (duplicatesIndexes.indexOf(index) === -1) {
                  duplicatesIndexes.push(index);
                }
              } else {
                objects.push(object);
                if (Array.isArray(object)) {
                  for (
                    index = 0, length = object.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(object[index], objects, duplicatesIndexes);
                  }
                } else {
                  objectKeyList = Object.keys(object);
                  for (
                    index = 0, length = objectKeyList.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(
                      object[objectKeyList[index]],
                      objects,
                      duplicatesIndexes
                    );
                  }
                }
              }
            }
          }
          function dump(input, options) {
            options = options || {};
            var state = new State(options);
            if (!state.noRefs) getDuplicateReferences(input, state);
            var value = input;
            if (state.replacer) {
              value = state.replacer.call({ "": value }, "", value);
            }
            if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
            return "";
          }
          module.exports.dump = dump;
        },
        { "./common": 21, "./exception": 23, "./schema/default": 27 }
      ],
      23: [
        function (require, module, exports) {
          // YAML error class. http://stackoverflow.com/questions/8458984
          //
          "use strict";
          function formatError(exception, compact) {
            var where = "",
              message = exception.reason || "(unknown reason)";
            if (!exception.mark) return message;
            if (exception.mark.name) {
              where += 'in "' + exception.mark.name + '" ';
            }
            where +=
              "(" +
              (exception.mark.line + 1) +
              ":" +
              (exception.mark.column + 1) +
              ")";
            if (!compact && exception.mark.snippet) {
              where += "\n\n" + exception.mark.snippet;
            }
            return message + " " + where;
          }
          function YAMLException(reason, mark) {
            // Super constructor
            Error.call(this);
            this.name = "YAMLException";
            this.reason = reason;
            this.mark = mark;
            this.message = formatError(this, false); // Include stack trace in error object
            if (Error.captureStackTrace) {
              // Chrome and NodeJS
              Error.captureStackTrace(this, this.constructor);
            } else {
              // FF, IE 10+ and Safari 6+. Fallback for others
              this.stack = new Error().stack || "";
            }
          } // Inherit from Error
          YAMLException.prototype = Object.create(Error.prototype);
          YAMLException.prototype.constructor = YAMLException;
          YAMLException.prototype.toString = function toString(compact) {
            return this.name + ": " + formatError(this, compact);
          };
          module.exports = YAMLException;
        },
        {}
      ],
      24: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable max-len,no-use-before-define*/ var common = require("./common");
          var YAMLException = require("./exception");
          var makeSnippet = require("./snippet");
          var DEFAULT_SCHEMA = require("./schema/default");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CONTEXT_FLOW_IN = 1;
          var CONTEXT_FLOW_OUT = 2;
          var CONTEXT_BLOCK_IN = 3;
          var CONTEXT_BLOCK_OUT = 4;
          var CHOMPING_CLIP = 1;
          var CHOMPING_STRIP = 2;
          var CHOMPING_KEEP = 3;
          var PATTERN_NON_PRINTABLE =
            /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
          var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
          var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
          var PATTERN_TAG_URI =
            /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
          function _class(obj) {
            return Object.prototype.toString.call(obj);
          }
          function is_EOL(c) {
            return c === 0x0a /* LF */ || c === 0x0d /* CR */;
          }
          function is_WHITE_SPACE(c) {
            return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
          }
          function is_WS_OR_EOL(c) {
            return (
              c === 0x09 /* Tab */ ||
              c === 0x20 /* Space */ ||
              c === 0x0a /* LF */ ||
              c === 0x0d /* CR */
            );
          }
          function is_FLOW_INDICATOR(c) {
            return (
              c === 0x2c /* , */ ||
              c === 0x5b /* [ */ ||
              c === 0x5d /* ] */ ||
              c === 0x7b /* { */ ||
              c === 0x7d /* } */
            );
          }
          function fromHexCode(c) {
            var lc;
            if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
              return c - 0x30;
            }
            /*eslint-disable no-bitwise*/ lc = c | 0x20;
            if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
              return lc - 0x61 + 10;
            }
            return -1;
          }
          function escapedHexLen(c) {
            if (c === 0x78 /* x */) {
              return 2;
            }
            if (c === 0x75 /* u */) {
              return 4;
            }
            if (c === 0x55 /* U */) {
              return 8;
            }
            return 0;
          }
          function fromDecimalCode(c) {
            if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
              return c - 0x30;
            }
            return -1;
          }
          function simpleEscapeSequence(c) {
            /* eslint-disable indent */ return c === 0x30 /* 0 */
              ? "\x00"
              : c === 0x61 /* a */
              ? "\x07"
              : c === 0x62 /* b */
              ? "\x08"
              : c === 0x74 /* t */
              ? "\x09"
              : c === 0x09 /* Tab */
              ? "\x09"
              : c === 0x6e /* n */
              ? "\x0A"
              : c === 0x76 /* v */
              ? "\x0B"
              : c === 0x66 /* f */
              ? "\x0C"
              : c === 0x72 /* r */
              ? "\x0D"
              : c === 0x65 /* e */
              ? "\x1B"
              : c === 0x20 /* Space */
              ? " "
              : c === 0x22 /* " */
              ? "\x22"
              : c === 0x2f /* / */
              ? "/"
              : c === 0x5c /* \ */
              ? "\x5C"
              : c === 0x4e /* N */
              ? "\x85"
              : c === 0x5f /* _ */
              ? "\xA0"
              : c === 0x4c /* L */
              ? "\u2028"
              : c === 0x50 /* P */
              ? "\u2029"
              : "";
          }
          function charFromCodepoint(c) {
            if (c <= 0xffff) {
              return String.fromCharCode(c);
            } // Encode UTF-16 surrogate pair
            // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
            return String.fromCharCode(
              ((c - 0x010000) >> 10) + 0xd800,
              ((c - 0x010000) & 0x03ff) + 0xdc00
            );
          }
          var simpleEscapeCheck = new Array(256); // integer, for fast access
          var simpleEscapeMap = new Array(256);
          for (var i = 0; i < 256; i++) {
            simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
            simpleEscapeMap[i] = simpleEscapeSequence(i);
          }
          function State(input, options) {
            this.input = input;
            this.filename = options["filename"] || null;
            this.schema = options["schema"] || DEFAULT_SCHEMA;
            this.onWarning = options["onWarning"] || null; // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
            // if such documents have no explicit %YAML directive
            this.legacy = options["legacy"] || false;
            this.json = options["json"] || false;
            this.listener = options["listener"] || null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.typeMap = this.schema.compiledTypeMap;
            this.length = input.length;
            this.position = 0;
            this.line = 0;
            this.lineStart = 0;
            this.lineIndent = 0; // position of first leading tab in the current line,
            // used to make sure there are no tabs in the indentation
            this.firstTabInLine = -1;
            this.documents = []; /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/
          }
          function generateError(state, message) {
            var mark = {
              name: state.filename,
              buffer: state.input.slice(0, -1), // omit trailing \0
              position: state.position,
              line: state.line,
              column: state.position - state.lineStart
            };
            mark.snippet = makeSnippet(mark);
            return new YAMLException(message, mark);
          }
          function throwError(state, message) {
            throw generateError(state, message);
          }
          function throwWarning(state, message) {
            if (state.onWarning) {
              state.onWarning.call(null, generateError(state, message));
            }
          }
          var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (state.version !== null) {
                throwError(state, "duplication of %YAML directive");
              }
              if (args.length !== 1) {
                throwError(state, "YAML directive accepts exactly one argument");
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (match === null) {
                throwError(state, "ill-formed argument of the YAML directive");
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (major !== 1) {
                throwError(state, "unacceptable YAML version of the document");
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (minor !== 1 && minor !== 2) {
                throwWarning(state, "unsupported YAML version of the document");
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (args.length !== 2) {
                throwError(state, "TAG directive accepts exactly two arguments");
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(
                  state,
                  "ill-formed tag handle (first argument) of the TAG directive"
                );
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(
                  state,
                  'there is a previously declared suffix for "' +
                    handle +
                    '" tag handle'
                );
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(
                  state,
                  "ill-formed tag prefix (second argument) of the TAG directive"
                );
              }
              try {
                prefix = decodeURIComponent(prefix);
              } catch (err) {
                throwError(state, "tag prefix is malformed: " + prefix);
              }
              state.tagMap[handle] = prefix;
            }
          };
          function captureSegment(state, start, end, checkJson) {
            var _position, _length, _character, _result;
            if (start < end) {
              _result = state.input.slice(start, end);
              if (checkJson) {
                for (
                  _position = 0, _length = _result.length;
                  _position < _length;
                  _position += 1
                ) {
                  _character = _result.charCodeAt(_position);
                  if (
                    !(
                      _character === 0x09 ||
                      (0x20 <= _character && _character <= 0x10ffff)
                    )
                  ) {
                    throwError(state, "expected valid JSON character");
                  }
                }
              } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                throwError(state, "the stream contains non-printable characters");
              }
              state.result += _result;
            }
          }
          function mergeMappings(state, destination, source, overridableKeys) {
            var sourceKeys, key, index, quantity;
            if (!common.isObject(source)) {
              throwError(
                state,
                "cannot merge mappings; the provided source object is unacceptable"
              );
            }
            sourceKeys = Object.keys(source);
            for (
              index = 0, quantity = sourceKeys.length;
              index < quantity;
              index += 1
            ) {
              key = sourceKeys[index];
              if (!_hasOwnProperty.call(destination, key)) {
                destination[key] = source[key];
                overridableKeys[key] = true;
              }
            }
          }
          function storeMappingPair(
            state,
            _result,
            overridableKeys,
            keyTag,
            keyNode,
            valueNode,
            startLine,
            startLineStart,
            startPos
          ) {
            var index, quantity; // The output is a plain object here, so keys can only be strings.
            // We need to convert keyNode to a string, but doing so can hang the process
            // (deeply nested arrays that explode exponentially using aliases).
            if (Array.isArray(keyNode)) {
              keyNode = Array.prototype.slice.call(keyNode);
              for (
                index = 0, quantity = keyNode.length;
                index < quantity;
                index += 1
              ) {
                if (Array.isArray(keyNode[index])) {
                  throwError(
                    state,
                    "nested arrays are not supported inside keys"
                  );
                }
                if (
                  _typeof2(keyNode) === "object" &&
                  _class(keyNode[index]) === "[object Object]"
                ) {
                  keyNode[index] = "[object Object]";
                }
              }
            } // Avoid code execution in load() via toString property
            // (still use its own toString for arrays, timestamps,
            // and whatever user schema extensions happen to have @@toStringTag)
            if (
              _typeof2(keyNode) === "object" &&
              _class(keyNode) === "[object Object]"
            ) {
              keyNode = "[object Object]";
            }
            keyNode = String(keyNode);
            if (_result === null) {
              _result = {};
            }
            if (keyTag === "tag:yaml.org,2002:merge") {
              if (Array.isArray(valueNode)) {
                for (
                  index = 0, quantity = valueNode.length;
                  index < quantity;
                  index += 1
                ) {
                  mergeMappings(
                    state,
                    _result,
                    valueNode[index],
                    overridableKeys
                  );
                }
              } else {
                mergeMappings(state, _result, valueNode, overridableKeys);
              }
            } else {
              if (
                !state.json &&
                !_hasOwnProperty.call(overridableKeys, keyNode) &&
                _hasOwnProperty.call(_result, keyNode)
              ) {
                state.line = startLine || state.line;
                state.lineStart = startLineStart || state.lineStart;
                state.position = startPos || state.position;
                throwError(state, "duplicated mapping key");
              } // used for this specific key only because Object.defineProperty is slow
              if (keyNode === "__proto__") {
                Object.defineProperty(_result, keyNode, {
                  configurable: true,
                  enumerable: true,
                  writable: true,
                  value: valueNode
                });
              } else {
                _result[keyNode] = valueNode;
              }
              delete overridableKeys[keyNode];
            }
            return _result;
          }
          function readLineBreak(state) {
            var ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x0a /* LF */) {
              state.position++;
            } else if (ch === 0x0d /* CR */) {
              state.position++;
              if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
                state.position++;
              }
            } else {
              throwError(state, "a line break is expected");
            }
            state.line += 1;
            state.lineStart = state.position;
            state.firstTabInLine = -1;
          }
          function skipSeparationSpace(state, allowComments, checkIndent) {
            var lineBreaks = 0,
              ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                if (ch === 0x09 /* Tab */ && state.firstTabInLine === -1) {
                  state.firstTabInLine = state.position;
                }
                ch = state.input.charCodeAt(++state.position);
              }
              if (allowComments && ch === 0x23 /* # */) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (
                  ch !== 0x0a /* LF */ &&
                  ch !== 0x0d /* CR */ &&
                  ch !== 0
                );
              }
              if (is_EOL(ch)) {
                readLineBreak(state);
                ch = state.input.charCodeAt(state.position);
                lineBreaks++;
                state.lineIndent = 0;
                while (ch === 0x20 /* Space */) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
              } else {
                break;
              }
            }
            if (
              checkIndent !== -1 &&
              lineBreaks !== 0 &&
              state.lineIndent < checkIndent
            ) {
              throwWarning(state, "deficient indentation");
            }
            return lineBreaks;
          }
          function testDocumentSeparator(state) {
            var _position = state.position,
              ch;
            ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
            // in parent on each call, for efficiency. No needs to test here again.
            if (
              (ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
              ch === state.input.charCodeAt(_position + 1) &&
              ch === state.input.charCodeAt(_position + 2)
            ) {
              _position += 3;
              ch = state.input.charCodeAt(_position);
              if (ch === 0 || is_WS_OR_EOL(ch)) {
                return true;
              }
            }
            return false;
          }
          function writeFoldedLines(state, count) {
            if (count === 1) {
              state.result += " ";
            } else if (count > 1) {
              state.result += common.repeat("\n", count - 1);
            }
          }
          function readPlainScalar(state, nodeIndent, withinFlowCollection) {
            var preceding,
              following,
              captureStart,
              captureEnd,
              hasPendingContent,
              _line,
              _lineStart,
              _lineIndent,
              _kind = state.kind,
              _result = state.result,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (
              is_WS_OR_EOL(ch) ||
              is_FLOW_INDICATOR(ch) ||
              ch === 0x23 /* # */ ||
              ch === 0x26 /* & */ ||
              ch === 0x2a /* * */ ||
              ch === 0x21 /* ! */ ||
              ch === 0x7c /* | */ ||
              ch === 0x3e /* > */ ||
              ch === 0x27 /* ' */ ||
              ch === 0x22 /* " */ ||
              ch === 0x25 /* % */ ||
              ch === 0x40 /* @ */ ||
              ch === 0x60 /* ` */
            ) {
              return false;
            }
            if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
              following = state.input.charCodeAt(state.position + 1);
              if (
                is_WS_OR_EOL(following) ||
                (withinFlowCollection && is_FLOW_INDICATOR(following))
              ) {
                return false;
              }
            }
            state.kind = "scalar";
            state.result = "";
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
            while (ch !== 0) {
              if (ch === 0x3a /* : */) {
                following = state.input.charCodeAt(state.position + 1);
                if (
                  is_WS_OR_EOL(following) ||
                  (withinFlowCollection && is_FLOW_INDICATOR(following))
                ) {
                  break;
                }
              } else if (ch === 0x23 /* # */) {
                preceding = state.input.charCodeAt(state.position - 1);
                if (is_WS_OR_EOL(preceding)) {
                  break;
                }
              } else if (
                (state.position === state.lineStart &&
                  testDocumentSeparator(state)) ||
                (withinFlowCollection && is_FLOW_INDICATOR(ch))
              ) {
                break;
              } else if (is_EOL(ch)) {
                _line = state.line;
                _lineStart = state.lineStart;
                _lineIndent = state.lineIndent;
                skipSeparationSpace(state, false, -1);
                if (state.lineIndent >= nodeIndent) {
                  hasPendingContent = true;
                  ch = state.input.charCodeAt(state.position);
                  continue;
                } else {
                  state.position = captureEnd;
                  state.line = _line;
                  state.lineStart = _lineStart;
                  state.lineIndent = _lineIndent;
                  break;
                }
              }
              if (hasPendingContent) {
                captureSegment(state, captureStart, captureEnd, false);
                writeFoldedLines(state, state.line - _line);
                captureStart = captureEnd = state.position;
                hasPendingContent = false;
              }
              if (!is_WHITE_SPACE(ch)) {
                captureEnd = state.position + 1;
              }
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, captureEnd, false);
            if (state.result) {
              return true;
            }
            state.kind = _kind;
            state.result = _result;
            return false;
          }
          function readSingleQuotedScalar(state, nodeIndent) {
            var ch, captureStart, captureEnd;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x27 /* ' */) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 0x27 /* ' */) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (ch === 0x27 /* ' */) {
                  captureStart = state.position;
                  state.position++;
                  captureEnd = state.position;
                } else {
                  return true;
                }
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a single quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a single quoted scalar"
            );
          }
          function readDoubleQuotedScalar(state, nodeIndent) {
            var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x22 /* " */) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 0x22 /* " */) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                return true;
              } else if (ch === 0x5c /* \ */) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) {
                  skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
                } else if (ch < 256 && simpleEscapeCheck[ch]) {
                  state.result += simpleEscapeMap[ch];
                  state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                  hexLength = tmp;
                  hexResult = 0;
                  for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                      hexResult = (hexResult << 4) + tmp;
                    } else {
                      throwError(state, "expected hexadecimal character");
                    }
                  }
                  state.result += charFromCodepoint(hexResult);
                  state.position++;
                } else {
                  throwError(state, "unknown escape sequence");
                }
                captureStart = captureEnd = state.position;
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a double quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a double quoted scalar"
            );
          }
          function readFlowCollection(state, nodeIndent) {
            var readNext = true,
              _line,
              _lineStart,
              _pos,
              _tag = state.tag,
              _result,
              _anchor = state.anchor,
              following,
              terminator,
              isPair,
              isExplicitPair,
              isMapping,
              overridableKeys = Object.create(null),
              keyNode,
              keyTag,
              valueNode,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x5b /* [ */) {
              terminator = 0x5d;
              /* ] */ isMapping = false;
              _result = [];
            } else if (ch === 0x7b /* { */) {
              terminator = 0x7d;
              /* } */ isMapping = true;
              _result = {};
            } else {
              return false;
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(++state.position);
            while (ch !== 0) {
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === terminator) {
                state.position++;
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = isMapping ? "mapping" : "sequence";
                state.result = _result;
                return true;
              } else if (!readNext) {
                throwError(state, "missed comma between flow collection entries");
              } else if (ch === 0x2c /* , */) {
                // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
                throwError(state, "expected the node content, but found ','");
              }
              keyTag = keyNode = valueNode = null;
              isPair = isExplicitPair = false;
              if (ch === 0x3f /* ? */) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following)) {
                  isPair = isExplicitPair = true;
                  state.position++;
                  skipSeparationSpace(state, true, nodeIndent);
                }
              }
              _line = state.line; // Save the current line.
              _lineStart = state.lineStart;
              _pos = state.position;
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              keyTag = state.tag;
              keyNode = state.result;
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (
                (isExplicitPair || state.line === _line) &&
                ch === 0x3a /* : */
              ) {
                isPair = true;
                ch = state.input.charCodeAt(++state.position);
                skipSeparationSpace(state, true, nodeIndent);
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                valueNode = state.result;
              }
              if (isMapping) {
                storeMappingPair(
                  state,
                  _result,
                  overridableKeys,
                  keyTag,
                  keyNode,
                  valueNode,
                  _line,
                  _lineStart,
                  _pos
                );
              } else if (isPair) {
                _result.push(
                  storeMappingPair(
                    state,
                    null,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    valueNode,
                    _line,
                    _lineStart,
                    _pos
                  )
                );
              } else {
                _result.push(keyNode);
              }
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === 0x2c /* , */) {
                readNext = true;
                ch = state.input.charCodeAt(++state.position);
              } else {
                readNext = false;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a flow collection"
            );
          }
          function readBlockScalar(state, nodeIndent) {
            var captureStart,
              folding,
              chomping = CHOMPING_CLIP,
              didReadContent = false,
              detectedIndent = false,
              textIndent = nodeIndent,
              emptyLines = 0,
              atMoreIndented = false,
              tmp,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x7c /* | */) {
              folding = false;
            } else if (ch === 0x3e /* > */) {
              folding = true;
            } else {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            while (ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
              if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
                if (CHOMPING_CLIP === chomping) {
                  chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
                } else {
                  throwError(state, "repeat of a chomping mode identifier");
                }
              } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                if (tmp === 0) {
                  throwError(
                    state,
                    "bad explicit indentation width of a block scalar; it cannot be less than one"
                  );
                } else if (!detectedIndent) {
                  textIndent = nodeIndent + tmp - 1;
                  detectedIndent = true;
                } else {
                  throwError(state, "repeat of an indentation width identifier");
                }
              } else {
                break;
              }
            }
            if (is_WHITE_SPACE(ch)) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (is_WHITE_SPACE(ch));
              if (ch === 0x23 /* # */) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (!is_EOL(ch) && ch !== 0);
              }
            }
            while (ch !== 0) {
              readLineBreak(state);
              state.lineIndent = 0;
              ch = state.input.charCodeAt(state.position);
              while (
                (!detectedIndent || state.lineIndent < textIndent) &&
                ch === 0x20 /* Space */
              ) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
              if (!detectedIndent && state.lineIndent > textIndent) {
                textIndent = state.lineIndent;
              }
              if (is_EOL(ch)) {
                emptyLines++;
                continue;
              } // End of the scalar.
              if (state.lineIndent < textIndent) {
                // Perform the chomping.
                if (chomping === CHOMPING_KEEP) {
                  state.result += common.repeat(
                    "\n",
                    didReadContent ? 1 + emptyLines : emptyLines
                  );
                } else if (chomping === CHOMPING_CLIP) {
                  if (didReadContent) {
                    // i.e. only if the scalar is not empty.
                    state.result += "\n";
                  }
                } // Break this `while` cycle and go to the funciton's epilogue.
                break;
              } // Folded style: use fancy rules to handle line breaks.
              if (folding) {
                // Lines starting with white space characters (more-indented lines) are not folded.
                if (is_WHITE_SPACE(ch)) {
                  atMoreIndented = true; // except for the first content line (cf. Example 8.1)
                  state.result += common.repeat(
                    "\n",
                    didReadContent ? 1 + emptyLines : emptyLines
                  ); // End of more-indented block.
                } else if (atMoreIndented) {
                  atMoreIndented = false;
                  state.result += common.repeat("\n", emptyLines + 1); // Just one line break - perceive as the same line.
                } else if (emptyLines === 0) {
                  if (didReadContent) {
                    // i.e. only if we have already read some scalar content.
                    state.result += " ";
                  } // Several line breaks - perceive as different lines.
                } else {
                  state.result += common.repeat("\n", emptyLines);
                } // Literal style: just add exact number of line breaks between content lines.
              } else {
                // Keep all line breaks except the header line break.
                state.result += common.repeat(
                  "\n",
                  didReadContent ? 1 + emptyLines : emptyLines
                );
              }
              didReadContent = true;
              detectedIndent = true;
              emptyLines = 0;
              captureStart = state.position;
              while (!is_EOL(ch) && ch !== 0) {
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, state.position, false);
            }
            return true;
          }
          function readBlockSequence(state, nodeIndent) {
            var _line,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = [],
              following,
              detected = false,
              ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;
            // it can still be flow sequence/mapping or a scalar
            if (state.firstTabInLine !== -1) return false;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              if (state.firstTabInLine !== -1) {
                state.position = state.firstTabInLine;
                throwError(
                  state,
                  "tab characters must not be used in indentation"
                );
              }
              if (ch !== 0x2d /* - */) {
                break;
              }
              following = state.input.charCodeAt(state.position + 1);
              if (!is_WS_OR_EOL(following)) {
                break;
              }
              detected = true;
              state.position++;
              if (skipSeparationSpace(state, true, -1)) {
                if (state.lineIndent <= nodeIndent) {
                  _result.push(null);
                  ch = state.input.charCodeAt(state.position);
                  continue;
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
              _result.push(state.result);
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (
                (state.line === _line || state.lineIndent > nodeIndent) &&
                ch !== 0
              ) {
                throwError(state, "bad indentation of a sequence entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "sequence";
              state.result = _result;
              return true;
            }
            return false;
          }
          function readBlockMapping(state, nodeIndent, flowIndent) {
            var following,
              allowCompact,
              _line,
              _keyLine,
              _keyLineStart,
              _keyPos,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = {},
              overridableKeys = Object.create(null),
              keyTag = null,
              keyNode = null,
              valueNode = null,
              atExplicitKey = false,
              detected = false,
              ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;
            // it can still be flow sequence/mapping or a scalar
            if (state.firstTabInLine !== -1) return false;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              if (!atExplicitKey && state.firstTabInLine !== -1) {
                state.position = state.firstTabInLine;
                throwError(
                  state,
                  "tab characters must not be used in indentation"
                );
              }
              following = state.input.charCodeAt(state.position + 1);
              _line = state.line; // Save the current line.
              //
              // Explicit notation case. There are two separate blocks:
              // first for the key (denoted by "?") and second for the value (denoted by ":")
              //
              if (
                (ch === 0x3f /* ? */ || ch === 0x3a /*: */) &&
                is_WS_OR_EOL(following)
              ) {
                if (ch === 0x3f /* ? */) {
                  if (atExplicitKey) {
                    storeMappingPair(
                      state,
                      _result,
                      overridableKeys,
                      keyTag,
                      keyNode,
                      null,
                      _keyLine,
                      _keyLineStart,
                      _keyPos
                    );
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = true;
                  allowCompact = true;
                } else if (atExplicitKey) {
                  // i.e. 0x3A/* : */ === character after the explicit key.
                  atExplicitKey = false;
                  allowCompact = true;
                } else {
                  throwError(
                    state,
                    "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"
                  );
                }
                state.position += 1;
                ch = following; //
                // Implicit notation case. Flow-style node as the key first, then ":", and the value.
                //
              } else {
                _keyLine = state.line;
                _keyLineStart = state.lineStart;
                _keyPos = state.position;
                if (
                  !composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
                ) {
                  // Neither implicit nor explicit notation.
                  // Reading is done. Go to the epilogue.
                  break;
                }
                if (state.line === _line) {
                  ch = state.input.charCodeAt(state.position);
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (ch === 0x3a /* : */) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                      throwError(
                        state,
                        "a whitespace character is expected after the key-value separator within a block mapping"
                      );
                    }
                    if (atExplicitKey) {
                      storeMappingPair(
                        state,
                        _result,
                        overridableKeys,
                        keyTag,
                        keyNode,
                        null,
                        _keyLine,
                        _keyLineStart,
                        _keyPos
                      );
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                  } else if (detected) {
                    throwError(
                      state,
                      "can not read an implicit mapping pair; a colon is missed"
                    );
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                  }
                } else if (detected) {
                  throwError(
                    state,
                    "can not read a block mapping entry; a multiline key may not be an implicit key"
                  );
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true; // Keep the result of `composeNode`.
                }
              } //
              // Common reading code for both explicit and implicit notations.
              //
              if (state.line === _line || state.lineIndent > nodeIndent) {
                if (atExplicitKey) {
                  _keyLine = state.line;
                  _keyLineStart = state.lineStart;
                  _keyPos = state.position;
                }
                if (
                  composeNode(
                    state,
                    nodeIndent,
                    CONTEXT_BLOCK_OUT,
                    true,
                    allowCompact
                  )
                ) {
                  if (atExplicitKey) {
                    keyNode = state.result;
                  } else {
                    valueNode = state.result;
                  }
                }
                if (!atExplicitKey) {
                  storeMappingPair(
                    state,
                    _result,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    valueNode,
                    _keyLine,
                    _keyLineStart,
                    _keyPos
                  );
                  keyTag = keyNode = valueNode = null;
                }
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
              }
              if (
                (state.line === _line || state.lineIndent > nodeIndent) &&
                ch !== 0
              ) {
                throwError(state, "bad indentation of a mapping entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            } //
            // Epilogue.
            //
            // Special case: last mapping's node contains only the key in explicit notation.
            if (atExplicitKey) {
              storeMappingPair(
                state,
                _result,
                overridableKeys,
                keyTag,
                keyNode,
                null,
                _keyLine,
                _keyLineStart,
                _keyPos
              );
            } // Expose the resulting mapping.
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "mapping";
              state.result = _result;
            }
            return detected;
          }
          function readTagProperty(state) {
            var _position,
              isVerbatim = false,
              isNamed = false,
              tagHandle,
              tagName,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x21 /* ! */) return false;
            if (state.tag !== null) {
              throwError(state, "duplication of a tag property");
            }
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x3c /* < */) {
              isVerbatim = true;
              ch = state.input.charCodeAt(++state.position);
            } else if (ch === 0x21 /* ! */) {
              isNamed = true;
              tagHandle = "!!";
              ch = state.input.charCodeAt(++state.position);
            } else {
              tagHandle = "!";
            }
            _position = state.position;
            if (isVerbatim) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && ch !== 0x3e /* > */);
              if (state.position < state.length) {
                tagName = state.input.slice(_position, state.position);
                ch = state.input.charCodeAt(++state.position);
              } else {
                throwError(
                  state,
                  "unexpected end of the stream within a verbatim tag"
                );
              }
            } else {
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                if (ch === 0x21 /* ! */) {
                  if (!isNamed) {
                    tagHandle = state.input.slice(
                      _position - 1,
                      state.position + 1
                    );
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                      throwError(
                        state,
                        "named tag handle cannot contain such characters"
                      );
                    }
                    isNamed = true;
                    _position = state.position + 1;
                  } else {
                    throwError(
                      state,
                      "tag suffix cannot contain exclamation marks"
                    );
                  }
                }
                ch = state.input.charCodeAt(++state.position);
              }
              tagName = state.input.slice(_position, state.position);
              if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                throwError(
                  state,
                  "tag suffix cannot contain flow indicator characters"
                );
              }
            }
            if (tagName && !PATTERN_TAG_URI.test(tagName)) {
              throwError(
                state,
                "tag name cannot contain such characters: " + tagName
              );
            }
            try {
              tagName = decodeURIComponent(tagName);
            } catch (err) {
              throwError(state, "tag name is malformed: " + tagName);
            }
            if (isVerbatim) {
              state.tag = tagName;
            } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
              state.tag = state.tagMap[tagHandle] + tagName;
            } else if (tagHandle === "!") {
              state.tag = "!" + tagName;
            } else if (tagHandle === "!!") {
              state.tag = "tag:yaml.org,2002:" + tagName;
            } else {
              throwError(state, 'undeclared tag handle "' + tagHandle + '"');
            }
            return true;
          }
          function readAnchorProperty(state) {
            var _position, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x26 /* & */) return false;
            if (state.anchor !== null) {
              throwError(state, "duplication of an anchor property");
            }
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(
                state,
                "name of an anchor node must contain at least one character"
              );
            }
            state.anchor = state.input.slice(_position, state.position);
            return true;
          }
          function readAlias(state) {
            var _position, alias, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x2a /* * */) return false;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(
                state,
                "name of an alias node must contain at least one character"
              );
            }
            alias = state.input.slice(_position, state.position);
            if (!_hasOwnProperty.call(state.anchorMap, alias)) {
              throwError(state, 'unidentified alias "' + alias + '"');
            }
            state.result = state.anchorMap[alias];
            skipSeparationSpace(state, true, -1);
            return true;
          }
          function composeNode(
            state,
            parentIndent,
            nodeContext,
            allowToSeek,
            allowCompact
          ) {
            var allowBlockStyles,
              allowBlockScalars,
              allowBlockCollections,
              indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
              atNewLine = false,
              hasContent = false,
              typeIndex,
              typeQuantity,
              typeList,
              type,
              flowIndent,
              blockIndent;
            if (state.listener !== null) {
              state.listener("open", state);
            }
            state.tag = null;
            state.anchor = null;
            state.kind = null;
            state.result = null;
            allowBlockStyles =
              allowBlockScalars =
              allowBlockCollections =
                CONTEXT_BLOCK_OUT === nodeContext ||
                CONTEXT_BLOCK_IN === nodeContext;
            if (allowToSeek) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              }
            }
            if (indentStatus === 1) {
              while (readTagProperty(state) || readAnchorProperty(state)) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  allowBlockCollections = allowBlockStyles;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                } else {
                  allowBlockCollections = false;
                }
              }
            }
            if (allowBlockCollections) {
              allowBlockCollections = atNewLine || allowCompact;
            }
            if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
              if (
                CONTEXT_FLOW_IN === nodeContext ||
                CONTEXT_FLOW_OUT === nodeContext
              ) {
                flowIndent = parentIndent;
              } else {
                flowIndent = parentIndent + 1;
              }
              blockIndent = state.position - state.lineStart;
              if (indentStatus === 1) {
                if (
                  (allowBlockCollections &&
                    (readBlockSequence(state, blockIndent) ||
                      readBlockMapping(state, blockIndent, flowIndent))) ||
                  readFlowCollection(state, flowIndent)
                ) {
                  hasContent = true;
                } else {
                  if (
                    (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                    readSingleQuotedScalar(state, flowIndent) ||
                    readDoubleQuotedScalar(state, flowIndent)
                  ) {
                    hasContent = true;
                  } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                      throwError(
                        state,
                        "alias node should not have any properties"
                      );
                    }
                  } else if (
                    readPlainScalar(
                      state,
                      flowIndent,
                      CONTEXT_FLOW_IN === nodeContext
                    )
                  ) {
                    hasContent = true;
                    if (state.tag === null) {
                      state.tag = "?";
                    }
                  }
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              } else if (indentStatus === 0) {
                // Special case: block sequences are allowed to have same indentation level as the parent.
                // http://www.yaml.org/spec/1.2/spec.html#id2799784
                hasContent =
                  allowBlockCollections && readBlockSequence(state, blockIndent);
              }
            }
            if (state.tag === null) {
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            } else if (state.tag === "?") {
              // Implicit resolving is not allowed for non-scalar types, and '?'
              // non-specific tag is only automatically assigned to plain scalars.
              //
              // We only need to check kind conformity in case user explicitly assigns '?'
              // tag, for example like this: "!<?> [0]"
              //
              if (state.result !== null && state.kind !== "scalar") {
                throwError(
                  state,
                  'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
                    state.kind +
                    '"'
                );
              }
              for (
                typeIndex = 0, typeQuantity = state.implicitTypes.length;
                typeIndex < typeQuantity;
                typeIndex += 1
              ) {
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                  // `state.result` updated in resolver if matched
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (state.tag !== "!") {
              if (
                _hasOwnProperty.call(
                  state.typeMap[state.kind || "fallback"],
                  state.tag
                )
              ) {
                type = state.typeMap[state.kind || "fallback"][state.tag];
              } else {
                // looking for multi type
                type = null;
                typeList = state.typeMap.multi[state.kind || "fallback"];
                for (
                  typeIndex = 0, typeQuantity = typeList.length;
                  typeIndex < typeQuantity;
                  typeIndex += 1
                ) {
                  if (
                    state.tag.slice(0, typeList[typeIndex].tag.length) ===
                    typeList[typeIndex].tag
                  ) {
                    type = typeList[typeIndex];
                    break;
                  }
                }
              }
              if (!type) {
                throwError(state, "unknown tag !<" + state.tag + ">");
              }
              if (state.result !== null && type.kind !== state.kind) {
                throwError(
                  state,
                  "unacceptable node kind for !<" +
                    state.tag +
                    '> tag; it should be "' +
                    type.kind +
                    '", not "' +
                    state.kind +
                    '"'
                );
              }
              if (!type.resolve(state.result, state.tag)) {
                // `state.result` updated in resolver if matched
                throwError(
                  state,
                  "cannot resolve a node with !<" + state.tag + "> explicit tag"
                );
              } else {
                state.result = type.construct(state.result, state.tag);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            }
            if (state.listener !== null) {
              state.listener("close", state);
            }
            return state.tag !== null || state.anchor !== null || hasContent;
          }
          function readDocument(state) {
            var documentStart = state.position,
              _position,
              directiveName,
              directiveArgs,
              hasDirectives = false,
              ch;
            state.version = null;
            state.checkLineBreaks = state.legacy;
            state.tagMap = Object.create(null);
            state.anchorMap = Object.create(null);
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
                break;
              }
              hasDirectives = true;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveName = state.input.slice(_position, state.position);
              directiveArgs = [];
              if (directiveName.length < 1) {
                throwError(
                  state,
                  "directive name must not be less than one character in length"
                );
              }
              while (ch !== 0) {
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x23 /* # */) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 0 && !is_EOL(ch));
                  break;
                }
                if (is_EOL(ch)) break;
                _position = state.position;
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveArgs.push(state.input.slice(_position, state.position));
              }
              if (ch !== 0) readLineBreak(state);
              if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                directiveHandlers[directiveName](
                  state,
                  directiveName,
                  directiveArgs
                );
              } else {
                throwWarning(
                  state,
                  'unknown document directive "' + directiveName + '"'
                );
              }
            }
            skipSeparationSpace(state, true, -1);
            if (
              state.lineIndent === 0 &&
              state.input.charCodeAt(state.position) === 0x2d /* - */ &&
              state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
              state.input.charCodeAt(state.position + 2) === 0x2d /* - */
            ) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) {
              throwError(state, "directives end mark is expected");
            }
            composeNode(
              state,
              state.lineIndent - 1,
              CONTEXT_BLOCK_OUT,
              false,
              true
            );
            skipSeparationSpace(state, true, -1);
            if (
              state.checkLineBreaks &&
              PATTERN_NON_ASCII_LINE_BREAKS.test(
                state.input.slice(documentStart, state.position)
              )
            ) {
              throwWarning(
                state,
                "non-ASCII line breaks are interpreted as content"
              );
            }
            state.documents.push(state.result);
            if (
              state.position === state.lineStart &&
              testDocumentSeparator(state)
            ) {
              if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              }
              return;
            }
            if (state.position < state.length - 1) {
              throwError(
                state,
                "end of the stream or a document separator is expected"
              );
            } else {
              return;
            }
          }
          function loadDocuments(input, options) {
            input = String(input);
            options = options || {};
            if (input.length !== 0) {
              // Add tailing `\n` if not exists
              if (
                input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
                input.charCodeAt(input.length - 1) !== 0x0d /* CR */
              ) {
                input += "\n";
              } // Strip BOM
              if (input.charCodeAt(0) === 0xfeff) {
                input = input.slice(1);
              }
            }
            var state = new State(input, options);
            var nullpos = input.indexOf("\0");
            if (nullpos !== -1) {
              state.position = nullpos;
              throwError(state, "null byte is not allowed in input");
            } // Use 0 as string terminator. That significantly simplifies bounds check.
            state.input += "\0";
            while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
              state.lineIndent += 1;
              state.position += 1;
            }
            while (state.position < state.length - 1) {
              readDocument(state);
            }
            return state.documents;
          }
          function loadAll(input, iterator, options) {
            if (
              iterator !== null &&
              _typeof2(iterator) === "object" &&
              typeof options === "undefined"
            ) {
              options = iterator;
              iterator = null;
            }
            var documents = loadDocuments(input, options);
            if (typeof iterator !== "function") {
              return documents;
            }
            for (
              var index = 0, length = documents.length;
              index < length;
              index += 1
            ) {
              iterator(documents[index]);
            }
          }
          function load(input, options) {
            var documents = loadDocuments(input, options);
            if (documents.length === 0) {
              /*eslint-disable no-undefined*/ return undefined;
            } else if (documents.length === 1) {
              return documents[0];
            }
            throw new YAMLException(
              "expected a single document in the stream, but found more"
            );
          }
          module.exports.loadAll = loadAll;
          module.exports.load = load;
        },
        {
          "./common": 21,
          "./exception": 23,
          "./schema/default": 27,
          "./snippet": 30
        }
      ],
      25: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable max-len*/ var YAMLException = require("./exception");
          var Type = require("./type");
          function compileList(schema, name) {
            var result = [];
            schema[name].forEach(function (currentType) {
              var newIndex = result.length;
              result.forEach(function (previousType, previousIndex) {
                if (
                  previousType.tag === currentType.tag &&
                  previousType.kind === currentType.kind &&
                  previousType.multi === currentType.multi
                ) {
                  newIndex = previousIndex;
                }
              });
              result[newIndex] = currentType;
            });
            return result;
          }
          function /* lists... */ compileMap() {
            var result = {
                scalar: {},
                sequence: {},
                mapping: {},
                fallback: {},
                multi: { scalar: [], sequence: [], mapping: [], fallback: [] }
              },
              index,
              length;
            function collectType(type) {
              if (type.multi) {
                result.multi[type.kind].push(type);
                result.multi["fallback"].push(type);
              } else {
                result[type.kind][type.tag] = result["fallback"][type.tag] = type;
              }
            }
            for (
              index = 0, length = arguments.length;
              index < length;
              index += 1
            ) {
              arguments[index].forEach(collectType);
            }
            return result;
          }
          function Schema(definition) {
            return this.extend(definition);
          }
          Schema.prototype.extend = function extend(definition) {
            var implicit = [];
            var explicit = [];
            if (definition instanceof Type) {
              // Schema.extend(type)
              explicit.push(definition);
            } else if (Array.isArray(definition)) {
              // Schema.extend([ type1, type2, ... ])
              explicit = explicit.concat(definition);
            } else if (
              definition &&
              (Array.isArray(definition.implicit) ||
                Array.isArray(definition.explicit))
            ) {
              // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
              if (definition.implicit)
                implicit = implicit.concat(definition.implicit);
              if (definition.explicit)
                explicit = explicit.concat(definition.explicit);
            } else {
              throw new YAMLException(
                "Schema.extend argument should be a Type, [ Type ], " +
                  "or a schema definition ({ implicit: [...], explicit: [...] })"
              );
            }
            implicit.forEach(function (type) {
              if (!(type instanceof Type)) {
                throw new YAMLException(
                  "Specified list of YAML types (or a single Type object) contains a non-Type object."
                );
              }
              if (type.loadKind && type.loadKind !== "scalar") {
                throw new YAMLException(
                  "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
                );
              }
              if (type.multi) {
                throw new YAMLException(
                  "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit."
                );
              }
            });
            explicit.forEach(function (type) {
              if (!(type instanceof Type)) {
                throw new YAMLException(
                  "Specified list of YAML types (or a single Type object) contains a non-Type object."
                );
              }
            });
            var result = Object.create(Schema.prototype);
            result.implicit = (this.implicit || []).concat(implicit);
            result.explicit = (this.explicit || []).concat(explicit);
            result.compiledImplicit = compileList(result, "implicit");
            result.compiledExplicit = compileList(result, "explicit");
            result.compiledTypeMap = compileMap(
              result.compiledImplicit,
              result.compiledExplicit
            );
            return result;
          };
          module.exports = Schema;
        },
        { "./exception": 23, "./type": 31 }
      ],
      26: [
        function (require, module, exports) {
          // Standard YAML's Core schema.
          // http://www.yaml.org/spec/1.2/spec.html#id2804923
          //
          // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
          // So, Core schema has no distinctions from JSON schema is JS-YAML.
          "use strict";
          module.exports = require("./json");
        },
        { "./json": 29 }
      ],
      27: [
        function (require, module, exports) {
          // JS-YAML's default schema for `safeLoad` function.
          // It is not described in the YAML specification.
          //
          // This schema is based on standard YAML's Core schema and includes most of
          // extra types described at YAML tag repository. (http://yaml.org/type/)
          "use strict";
          module.exports = require("./core").extend({
            implicit: [require("../type/timestamp"), require("../type/merge")],
            explicit: [
              require("../type/binary"),
              require("../type/omap"),
              require("../type/pairs"),
              require("../type/set")
            ]
          });
        },
        {
          "../type/binary": 32,
          "../type/merge": 37,
          "../type/omap": 39,
          "../type/pairs": 40,
          "../type/set": 42,
          "../type/timestamp": 44,
          "./core": 26
        }
      ],
      28: [
        function (require, module, exports) {
          // Standard YAML's Failsafe schema.
          // http://www.yaml.org/spec/1.2/spec.html#id2802346
          "use strict";
          var Schema = require("../schema");
          module.exports = new Schema({
            explicit: [
              require("../type/str"),
              require("../type/seq"),
              require("../type/map")
            ]
          });
        },
        {
          "../schema": 25,
          "../type/map": 36,
          "../type/seq": 41,
          "../type/str": 43
        }
      ],
      29: [
        function (require, module, exports) {
          // Standard YAML's JSON schema.
          // http://www.yaml.org/spec/1.2/spec.html#id2803231
          //
          // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
          // So, this schema is not such strict as defined in the YAML specification.
          // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
          "use strict";
          module.exports = require("./failsafe").extend({
            implicit: [
              require("../type/null"),
              require("../type/bool"),
              require("../type/int"),
              require("../type/float")
            ]
          });
        },
        {
          "../type/bool": 33,
          "../type/float": 34,
          "../type/int": 35,
          "../type/null": 38,
          "./failsafe": 28
        }
      ],
      30: [
        function (require, module, exports) {
          "use strict";
          var common = require("./common"); // get snippet for a single line, respecting maxLength
          function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
            var head = "";
            var tail = "";
            var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
            if (position - lineStart > maxHalfLength) {
              head = " ... ";
              lineStart = position - maxHalfLength + head.length;
            }
            if (lineEnd - position > maxHalfLength) {
              tail = " ...";
              lineEnd = position + maxHalfLength - tail.length;
            }
            return {
              str:
                head +
                buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") +
                tail,
              pos: position - lineStart + head.length // relative position
            };
          }
          function padStart(string, max) {
            return common.repeat(" ", max - string.length) + string;
          }
          function makeSnippet(mark, options) {
            options = Object.create(options || null);
            if (!mark.buffer) return null;
            if (!options.maxLength) options.maxLength = 79;
            if (typeof options.indent !== "number") options.indent = 1;
            if (typeof options.linesBefore !== "number") options.linesBefore = 3;
            if (typeof options.linesAfter !== "number") options.linesAfter = 2;
            var re = /\r?\n|\r|\0/g;
            var lineStarts = [0];
            var lineEnds = [];
            var match;
            var foundLineNo = -1;
            while ((match = re.exec(mark.buffer))) {
              lineEnds.push(match.index);
              lineStarts.push(match.index + match[0].length);
              if (mark.position <= match.index && foundLineNo < 0) {
                foundLineNo = lineStarts.length - 2;
              }
            }
            if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
            var result = "",
              i,
              line;
            var lineNoLength = Math.min(
              mark.line + options.linesAfter,
              lineEnds.length
            ).toString().length;
            var maxLineLength =
              options.maxLength - (options.indent + lineNoLength + 3);
            for (i = 1; i <= options.linesBefore; i++) {
              if (foundLineNo - i < 0) break;
              line = getLine(
                mark.buffer,
                lineStarts[foundLineNo - i],
                lineEnds[foundLineNo - i],
                mark.position -
                  (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
                maxLineLength
              );
              result =
                common.repeat(" ", options.indent) +
                padStart((mark.line - i + 1).toString(), lineNoLength) +
                " | " +
                line.str +
                "\n" +
                result;
            }
            line = getLine(
              mark.buffer,
              lineStarts[foundLineNo],
              lineEnds[foundLineNo],
              mark.position,
              maxLineLength
            );
            result +=
              common.repeat(" ", options.indent) +
              padStart((mark.line + 1).toString(), lineNoLength) +
              " | " +
              line.str +
              "\n";
            result +=
              common.repeat("-", options.indent + lineNoLength + 3 + line.pos) +
              "^" +
              "\n";
            for (i = 1; i <= options.linesAfter; i++) {
              if (foundLineNo + i >= lineEnds.length) break;
              line = getLine(
                mark.buffer,
                lineStarts[foundLineNo + i],
                lineEnds[foundLineNo + i],
                mark.position -
                  (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
                maxLineLength
              );
              result +=
                common.repeat(" ", options.indent) +
                padStart((mark.line + i + 1).toString(), lineNoLength) +
                " | " +
                line.str +
                "\n";
            }
            return result.replace(/\n$/, "");
          }
          module.exports = makeSnippet;
        },
        { "./common": 21 }
      ],
      31: [
        function (require, module, exports) {
          "use strict";
          var YAMLException = require("./exception");
          var TYPE_CONSTRUCTOR_OPTIONS = [
            "kind",
            "multi",
            "resolve",
            "construct",
            "instanceOf",
            "predicate",
            "represent",
            "representName",
            "defaultStyle",
            "styleAliases"
          ];
          var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
          function compileStyleAliases(map) {
            var result = {};
            if (map !== null) {
              Object.keys(map).forEach(function (style) {
                map[style].forEach(function (alias) {
                  result[String(alias)] = style;
                });
              });
            }
            return result;
          }
          function Type(tag, options) {
            options = options || {};
            Object.keys(options).forEach(function (name) {
              if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
                throw new YAMLException(
                  'Unknown option "' +
                    name +
                    '" is met in definition of "' +
                    tag +
                    '" YAML type.'
                );
              }
            }); // TODO: Add tag format check.
            this.options = options; // keep original options in case user wants to extend this type later
            this.tag = tag;
            this.kind = options["kind"] || null;
            this.resolve =
              options["resolve"] ||
              function () {
                return true;
              };
            this.construct =
              options["construct"] ||
              function (data) {
                return data;
              };
            this.instanceOf = options["instanceOf"] || null;
            this.predicate = options["predicate"] || null;
            this.represent = options["represent"] || null;
            this.representName = options["representName"] || null;
            this.defaultStyle = options["defaultStyle"] || null;
            this.multi = options["multi"] || false;
            this.styleAliases = compileStyleAliases(
              options["styleAliases"] || null
            );
            if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
              throw new YAMLException(
                'Unknown kind "' +
                  this.kind +
                  '" is specified for "' +
                  tag +
                  '" YAML type.'
              );
            }
          }
          module.exports = Type;
        },
        { "./exception": 23 }
      ],
      32: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable no-bitwise*/ var Type = require("../type"); // [ 64, 65, 66 ] -> [ padding, CR, LF ]
          var BASE64_MAP =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
          function resolveYamlBinary(data) {
            if (data === null) return false;
            var code,
              idx,
              bitlen = 0,
              max = data.length,
              map = BASE64_MAP; // Convert one by one.
            for (idx = 0; idx < max; idx++) {
              code = map.indexOf(data.charAt(idx)); // Skip CR/LF
              if (code > 64) continue; // Fail on illegal characters
              if (code < 0) return false;
              bitlen += 6;
            } // If there are any bits left, source was corrupted
            return bitlen % 8 === 0;
          }
          function constructYamlBinary(data) {
            var idx,
              tailbits,
              input = data.replace(/[\r\n=]/g, ""), // remove CR/LF & padding to simplify scan
              max = input.length,
              map = BASE64_MAP,
              bits = 0,
              result = []; // Collect by 6*4 bits (3 bytes)
            for (idx = 0; idx < max; idx++) {
              if (idx % 4 === 0 && idx) {
                result.push((bits >> 16) & 0xff);
                result.push((bits >> 8) & 0xff);
                result.push(bits & 0xff);
              }
              bits = (bits << 6) | map.indexOf(input.charAt(idx));
            } // Dump tail
            tailbits = (max % 4) * 6;
            if (tailbits === 0) {
              result.push((bits >> 16) & 0xff);
              result.push((bits >> 8) & 0xff);
              result.push(bits & 0xff);
            } else if (tailbits === 18) {
              result.push((bits >> 10) & 0xff);
              result.push((bits >> 2) & 0xff);
            } else if (tailbits === 12) {
              result.push((bits >> 4) & 0xff);
            }
            return new Uint8Array(result);
          }
          function representYamlBinary(object /*, style*/) {
            var result = "",
              bits = 0,
              idx,
              tail,
              max = object.length,
              map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.
            for (idx = 0; idx < max; idx++) {
              if (idx % 3 === 0 && idx) {
                result += map[(bits >> 18) & 0x3f];
                result += map[(bits >> 12) & 0x3f];
                result += map[(bits >> 6) & 0x3f];
                result += map[bits & 0x3f];
              }
              bits = (bits << 8) + object[idx];
            } // Dump tail
            tail = max % 3;
            if (tail === 0) {
              result += map[(bits >> 18) & 0x3f];
              result += map[(bits >> 12) & 0x3f];
              result += map[(bits >> 6) & 0x3f];
              result += map[bits & 0x3f];
            } else if (tail === 2) {
              result += map[(bits >> 10) & 0x3f];
              result += map[(bits >> 4) & 0x3f];
              result += map[(bits << 2) & 0x3f];
              result += map[64];
            } else if (tail === 1) {
              result += map[(bits >> 2) & 0x3f];
              result += map[(bits << 4) & 0x3f];
              result += map[64];
              result += map[64];
            }
            return result;
          }
          function isBinary(obj) {
            return Object.prototype.toString.call(obj) === "[object Uint8Array]";
          }
          module.exports = new Type("tag:yaml.org,2002:binary", {
            kind: "scalar",
            resolve: resolveYamlBinary,
            construct: constructYamlBinary,
            predicate: isBinary,
            represent: representYamlBinary
          });
        },
        { "../type": 31 }
      ],
      33: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          function resolveYamlBoolean(data) {
            if (data === null) return false;
            var max = data.length;
            return (
              (max === 4 &&
                (data === "true" || data === "True" || data === "TRUE")) ||
              (max === 5 &&
                (data === "false" || data === "False" || data === "FALSE"))
            );
          }
          function constructYamlBoolean(data) {
            return data === "true" || data === "True" || data === "TRUE";
          }
          function isBoolean(object) {
            return Object.prototype.toString.call(object) === "[object Boolean]";
          }
          module.exports = new Type("tag:yaml.org,2002:bool", {
            kind: "scalar",
            resolve: resolveYamlBoolean,
            construct: constructYamlBoolean,
            predicate: isBoolean,
            represent: {
              lowercase: function lowercase(object) {
                return object ? "true" : "false";
              },
              uppercase: function uppercase(object) {
                return object ? "TRUE" : "FALSE";
              },
              camelcase: function camelcase(object) {
                return object ? "True" : "False";
              }
            },
            defaultStyle: "lowercase"
          });
        },
        { "../type": 31 }
      ],
      34: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var Type = require("../type");
          var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
            "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + // .2e4, .2
              // special case, seems not from spec
              "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + // .inf
              "|[-+]?\\.(?:inf|Inf|INF)" + // .nan
              "|\\.(?:nan|NaN|NAN))$"
          );
          function resolveYamlFloat(data) {
            if (data === null) return false;
            if (
              !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
              // Probably should update regexp & check speed
              data[data.length - 1] === "_"
            ) {
              return false;
            }
            return true;
          }
          function constructYamlFloat(data) {
            var value, sign;
            value = data.replace(/_/g, "").toLowerCase();
            sign = value[0] === "-" ? -1 : 1;
            if ("+-".indexOf(value[0]) >= 0) {
              value = value.slice(1);
            }
            if (value === ".inf") {
              return sign === 1
                ? Number.POSITIVE_INFINITY
                : Number.NEGATIVE_INFINITY;
            } else if (value === ".nan") {
              return NaN;
            }
            return sign * parseFloat(value, 10);
          }
          var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
          function representYamlFloat(object, style) {
            var res;
            if (isNaN(object)) {
              switch (style) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            } else if (Number.POSITIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            } else if (Number.NEGATIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            } else if (common.isNegativeZero(object)) {
              return "-0.0";
            }
            res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
            // while YAML requres dot: 5.e-100. Fix it with simple hack
            return SCIENTIFIC_WITHOUT_DOT.test(res)
              ? res.replace("e", ".e")
              : res;
          }
          function isFloat(object) {
            return (
              Object.prototype.toString.call(object) === "[object Number]" &&
              (object % 1 !== 0 || common.isNegativeZero(object))
            );
          }
          module.exports = new Type("tag:yaml.org,2002:float", {
            kind: "scalar",
            resolve: resolveYamlFloat,
            construct: constructYamlFloat,
            predicate: isFloat,
            represent: representYamlFloat,
            defaultStyle: "lowercase"
          });
        },
        { "../common": 21, "../type": 31 }
      ],
      35: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var Type = require("../type");
          function isHexCode(c) {
            return (
              (0x30 /* 0 */ <= c && c <= 0x39) /* 9 */ ||
              (0x41 /* A */ <= c && c <= 0x46) /* F */ ||
              (0x61 /* a */ <= c && c <= 0x66) /* f */
            );
          }
          function isOctCode(c) {
            return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
          }
          function isDecCode(c) {
            return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
          }
          function resolveYamlInteger(data) {
            if (data === null) return false;
            var max = data.length,
              index = 0,
              hasDigits = false,
              ch;
            if (!max) return false;
            ch = data[index]; // sign
            if (ch === "-" || ch === "+") {
              ch = data[++index];
            }
            if (ch === "0") {
              // 0
              if (index + 1 === max) return true;
              ch = data[++index]; // base 2, base 8, base 16
              if (ch === "b") {
                // base 2
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (ch !== "0" && ch !== "1") return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
              if (ch === "x") {
                // base 16
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (!isHexCode(data.charCodeAt(index))) return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
              if (ch === "o") {
                // base 8
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (!isOctCode(data.charCodeAt(index))) return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
            } // base 10 (except 0)
            // value should not start with `_`;
            if (ch === "_") return false;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isDecCode(data.charCodeAt(index))) {
                return false;
              }
              hasDigits = true;
            } // Should have digits and should not end with `_`
            if (!hasDigits || ch === "_") return false;
            return true;
          }
          function constructYamlInteger(data) {
            var value = data,
              sign = 1,
              ch;
            if (value.indexOf("_") !== -1) {
              value = value.replace(/_/g, "");
            }
            ch = value[0];
            if (ch === "-" || ch === "+") {
              if (ch === "-") sign = -1;
              value = value.slice(1);
              ch = value[0];
            }
            if (value === "0") return 0;
            if (ch === "0") {
              if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
              if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
              if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
            }
            return sign * parseInt(value, 10);
          }
          function isInteger(object) {
            return (
              Object.prototype.toString.call(object) === "[object Number]" &&
              object % 1 === 0 &&
              !common.isNegativeZero(object)
            );
          }
          module.exports = new Type("tag:yaml.org,2002:int", {
            kind: "scalar",
            resolve: resolveYamlInteger,
            construct: constructYamlInteger,
            predicate: isInteger,
            represent: {
              binary: function binary(obj) {
                return obj >= 0
                  ? "0b" + obj.toString(2)
                  : "-0b" + obj.toString(2).slice(1);
              },
              octal: function octal(obj) {
                return obj >= 0
                  ? "0o" + obj.toString(8)
                  : "-0o" + obj.toString(8).slice(1);
              },
              decimal: function decimal(obj) {
                return obj.toString(10);
              },
              /* eslint-disable max-len */ hexadecimal: function hexadecimal(
                obj
              ) {
                return obj >= 0
                  ? "0x" + obj.toString(16).toUpperCase()
                  : "-0x" + obj.toString(16).toUpperCase().slice(1);
              }
            },
            defaultStyle: "decimal",
            styleAliases: {
              binary: [2, "bin"],
              octal: [8, "oct"],
              decimal: [10, "dec"],
              hexadecimal: [16, "hex"]
            }
          });
        },
        { "../common": 21, "../type": 31 }
      ],
      36: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          module.exports = new Type("tag:yaml.org,2002:map", {
            kind: "mapping",
            construct: function construct(data) {
              return data !== null ? data : {};
            }
          });
        },
        { "../type": 31 }
      ],
      37: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          function resolveYamlMerge(data) {
            return data === "<<" || data === null;
          }
          module.exports = new Type("tag:yaml.org,2002:merge", {
            kind: "scalar",
            resolve: resolveYamlMerge
          });
        },
        { "../type": 31 }
      ],
      38: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          function resolveYamlNull(data) {
            if (data === null) return true;
            var max = data.length;
            return (
              (max === 1 && data === "~") ||
              (max === 4 &&
                (data === "null" || data === "Null" || data === "NULL"))
            );
          }
          function constructYamlNull() {
            return null;
          }
          function isNull(object) {
            return object === null;
          }
          module.exports = new Type("tag:yaml.org,2002:null", {
            kind: "scalar",
            resolve: resolveYamlNull,
            construct: constructYamlNull,
            predicate: isNull,
            represent: {
              canonical: function canonical() {
                return "~";
              },
              lowercase: function lowercase() {
                return "null";
              },
              uppercase: function uppercase() {
                return "NULL";
              },
              camelcase: function camelcase() {
                return "Null";
              },
              empty: function empty() {
                return "";
              }
            },
            defaultStyle: "lowercase"
          });
        },
        { "../type": 31 }
      ],
      39: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var _toString = Object.prototype.toString;
          function resolveYamlOmap(data) {
            if (data === null) return true;
            var objectKeys = [],
              index,
              length,
              pair,
              pairKey,
              pairHasKey,
              object = data;
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              pairHasKey = false;
              if (_toString.call(pair) !== "[object Object]") return false;
              for (pairKey in pair) {
                if (_hasOwnProperty.call(pair, pairKey)) {
                  if (!pairHasKey) pairHasKey = true;
                  else return false;
                }
              }
              if (!pairHasKey) return false;
              if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
              else return false;
            }
            return true;
          }
          function constructYamlOmap(data) {
            return data !== null ? data : [];
          }
          module.exports = new Type("tag:yaml.org,2002:omap", {
            kind: "sequence",
            resolve: resolveYamlOmap,
            construct: constructYamlOmap
          });
        },
        { "../type": 31 }
      ],
      40: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          var _toString = Object.prototype.toString;
          function resolveYamlPairs(data) {
            if (data === null) return true;
            var index,
              length,
              pair,
              keys,
              result,
              object = data;
            result = new Array(object.length);
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              if (_toString.call(pair) !== "[object Object]") return false;
              keys = Object.keys(pair);
              if (keys.length !== 1) return false;
              result[index] = [keys[0], pair[keys[0]]];
            }
            return true;
          }
          function constructYamlPairs(data) {
            if (data === null) return [];
            var index,
              length,
              pair,
              keys,
              result,
              object = data;
            result = new Array(object.length);
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              keys = Object.keys(pair);
              result[index] = [keys[0], pair[keys[0]]];
            }
            return result;
          }
          module.exports = new Type("tag:yaml.org,2002:pairs", {
            kind: "sequence",
            resolve: resolveYamlPairs,
            construct: constructYamlPairs
          });
        },
        { "../type": 31 }
      ],
      41: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          module.exports = new Type("tag:yaml.org,2002:seq", {
            kind: "sequence",
            construct: function construct(data) {
              return data !== null ? data : [];
            }
          });
        },
        { "../type": 31 }
      ],
      42: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          function resolveYamlSet(data) {
            if (data === null) return true;
            var key,
              object = data;
            for (key in object) {
              if (_hasOwnProperty.call(object, key)) {
                if (object[key] !== null) return false;
              }
            }
            return true;
          }
          function constructYamlSet(data) {
            return data !== null ? data : {};
          }
          module.exports = new Type("tag:yaml.org,2002:set", {
            kind: "mapping",
            resolve: resolveYamlSet,
            construct: constructYamlSet
          });
        },
        { "../type": 31 }
      ],
      43: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          module.exports = new Type("tag:yaml.org,2002:str", {
            kind: "scalar",
            construct: function construct(data) {
              return data !== null ? data : "";
            }
          });
        },
        { "../type": 31 }
      ],
      44: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          var YAML_DATE_REGEXP = new RegExp(
            "^([0-9][0-9][0-9][0-9])" + // [1] year
              "-([0-9][0-9])" + // [2] month
              "-([0-9][0-9])$"
          ); // [3] day
          var YAML_TIMESTAMP_REGEXP = new RegExp(
            "^([0-9][0-9][0-9][0-9])" + // [1] year
              "-([0-9][0-9]?)" + // [2] month
              "-([0-9][0-9]?)" + // [3] day
              "(?:[Tt]|[ \\t]+)" + // ...
              "([0-9][0-9]?)" + // [4] hour
              ":([0-9][0-9])" + // [5] minute
              ":([0-9][0-9])" + // [6] second
              "(?:\\.([0-9]*))?" + // [7] fraction
              "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + // [8] tz [9] tz_sign [10] tz_hour
              "(?::([0-9][0-9]))?))?$"
          ); // [11] tz_minute
          function resolveYamlTimestamp(data) {
            if (data === null) return false;
            if (YAML_DATE_REGEXP.exec(data) !== null) return true;
            if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
            return false;
          }
          function constructYamlTimestamp(data) {
            var match,
              year,
              month,
              day,
              hour,
              minute,
              second,
              fraction = 0,
              delta = null,
              tz_hour,
              tz_minute,
              date;
            match = YAML_DATE_REGEXP.exec(data);
            if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
            if (match === null) throw new Error("Date resolve error"); // match: [1] year [2] month [3] day
            year = +match[1];
            month = +match[2] - 1; // JS month starts with 0
            day = +match[3];
            if (!match[4]) {
              // no hour
              return new Date(Date.UTC(year, month, day));
            } // match: [4] hour [5] minute [6] second [7] fraction
            hour = +match[4];
            minute = +match[5];
            second = +match[6];
            if (match[7]) {
              fraction = match[7].slice(0, 3);
              while (fraction.length < 3) {
                // milli-seconds
                fraction += "0";
              }
              fraction = +fraction;
            } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
            if (match[9]) {
              tz_hour = +match[10];
              tz_minute = +(match[11] || 0);
              delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
              if (match[9] === "-") delta = -delta;
            }
            date = new Date(
              Date.UTC(year, month, day, hour, minute, second, fraction)
            );
            if (delta) date.setTime(date.getTime() - delta);
            return date;
          }
          function representYamlTimestamp(object /*, style*/) {
            return object.toISOString();
          }
          module.exports = new Type("tag:yaml.org,2002:timestamp", {
            kind: "scalar",
            resolve: resolveYamlTimestamp,
            construct: constructYamlTimestamp,
            instanceOf: Date,
            represent: representYamlTimestamp
          });
        },
        { "../type": 31 }
      ],
      45: [
        function (require, module, exports) {
          var _require22 = require("./constants"),
            xParserMessageName = _require22.xParserMessageName,
            xParserSchemaId = _require22.xParserSchemaId;
          var _require23 = require("./iterators"),
            traverseAsyncApiDocument = _require23.traverseAsyncApiDocument;
          /**
           * Assign message keys as message name to all the component messages.
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignNameToComponentMessages(doc) {
            if (doc.hasComponents()) {
              for (
                var _i7 = 0,
                  _Object$entries = Object.entries(doc.components().messages());
                _i7 < _Object$entries.length;
                _i7++
              ) {
                var _Object$entries$_i = _slicedToArray(_Object$entries[_i7], 2),
                  key = _Object$entries$_i[0],
                  m = _Object$entries$_i[1];
                if (m.name() === undefined) {
                  m.json()[String(xParserMessageName)] = key;
                }
              }
            }
          }
          /**
           * Assign ids based on parameter keys.
           *
           * @private
           * @param {Record<string,Schema>} parameterObject
           */ function assignIdToParameters(parameterObject) {
            for (
              var _i8 = 0, _Object$entries2 = Object.entries(parameterObject);
              _i8 < _Object$entries2.length;
              _i8++
            ) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),
                parameterKey = _Object$entries2$_i[0],
                parameter = _Object$entries2$_i[1];
              if (parameter.schema()) {
                parameter.schema().json()[String(xParserSchemaId)] = parameterKey;
              }
            }
          }
          /**
           * Assign parameter keys as uid for the parameter schema.
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignUidToParameterSchemas(doc) {
            doc.channelNames().forEach(function (channelName) {
              var channel = doc.channel(channelName);
              assignIdToParameters(channel.parameters());
            });
          }
          /**
           * Assign uid to component schemas.
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignUidToComponentSchemas(doc) {
            if (doc.hasComponents()) {
              for (
                var _i9 = 0,
                  _Object$entries3 = Object.entries(doc.components().schemas());
                _i9 < _Object$entries3.length;
                _i9++
              ) {
                var _Object$entries3$_i = _slicedToArray(
                    _Object$entries3[_i9],
                    2
                  ),
                  key = _Object$entries3$_i[0],
                  s = _Object$entries3$_i[1];
                s.json()[String(xParserSchemaId)] = key;
              }
            }
          }
          /**
           * Assign uid to component parameters schemas
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignUidToComponentParameterSchemas(doc) {
            if (doc.hasComponents()) {
              assignIdToParameters(doc.components().parameters());
            }
          }
          /**
           * Assign anonymous names to nameless messages.
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignNameToAnonymousMessages(doc) {
            var anonymousMessageCounter = 0;
            if (doc.hasChannels()) {
              doc.channelNames().forEach(function (channelName) {
                var channel = doc.channel(channelName);
                if (channel.hasPublish())
                  addNameToKey(
                    channel.publish().messages(),
                    ++anonymousMessageCounter
                  );
                if (channel.hasSubscribe())
                  addNameToKey(
                    channel.subscribe().messages(),
                    ++anonymousMessageCounter
                  );
              });
            }
          }
          /**
           * Add anonymous name to key if no name provided.
           *
           * @private
           * @param {Message} map of messages
           */ function addNameToKey(messages, number) {
            messages.forEach(function (m) {
              if (
                m.name() === undefined &&
                m.ext(xParserMessageName) === undefined
              ) {
                m.json()[String(xParserMessageName)] =
                  "<anonymous-message-".concat(number, ">");
              }
            });
          }
          /**
           * Gives schemas id to all anonymous schemas.
           *
           * @private
           * @param {AsyncAPIDocument} doc
           */ function assignIdToAnonymousSchemas(doc) {
            var anonymousSchemaCounter = 0;
            var callback = function callback(schema) {
              if (!schema.uid()) {
                schema.json()[String(xParserSchemaId)] =
                  "<anonymous-schema-".concat(++anonymousSchemaCounter, ">");
              }
            };
            traverseAsyncApiDocument(doc, callback);
          }
          module.exports = {
            assignNameToComponentMessages: assignNameToComponentMessages,
            assignUidToParameterSchemas: assignUidToParameterSchemas,
            assignUidToComponentSchemas: assignUidToComponentSchemas,
            assignUidToComponentParameterSchemas:
              assignUidToComponentParameterSchemas,
            assignNameToAnonymousMessages: assignNameToAnonymousMessages,
            assignIdToAnonymousSchemas: assignIdToAnonymousSchemas
          };
        },
        { "./constants": 48, "./iterators": 52 }
      ],
      46: [
        function (require, module, exports) {
          var Ajv = require("ajv");
          var ParserError = require("./errors/parser-error");
          var asyncapi = require("@asyncapi/specs");
          var _require24 = require("./utils"),
            improveAjvErrors = _require24.improveAjvErrors;
          var cloneDeep = require("lodash.clonedeep");
          var ajv = new Ajv({
            jsonPointers: true,
            allErrors: true,
            schemaId: "id",
            logger: false
          });
          ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-04.json"));
          module.exports = { parse: parse, getMimeTypes: getMimeTypes };
          /**
           * @private
           */ /*async*/ function parse(_ref3) {
            var message = _ref3.message,
              originalAsyncAPIDocument = _ref3.originalAsyncAPIDocument,
              fileFormat = _ref3.fileFormat,
              parsedAsyncAPIDocument = _ref3.parsedAsyncAPIDocument,
              pathToPayload = _ref3.pathToPayload,
              defaultSchemaFormat = _ref3.defaultSchemaFormat;
            var payload = message.payload;
            if (!payload) return;
            message["x-parser-original-schema-format"] =
              message.schemaFormat || defaultSchemaFormat;
            message["x-parser-original-payload"] = cloneDeep(message.payload);
            var validate = getValidator(parsedAsyncAPIDocument.asyncapi);
            var valid = validate(payload);
            var errors = validate.errors && _toConsumableArray(validate.errors);
            if (!valid)
              throw new ParserError({
                type: "schema-validation-errors",
                title: "This is not a valid AsyncAPI Schema Object.",
                parsedJSON: parsedAsyncAPIDocument,
                validationErrors: improveAjvErrors(
                  addFullPathToDataPath(errors, pathToPayload),
                  originalAsyncAPIDocument,
                  fileFormat
                )
              });
          }
          /**
           * @private
           */ function getMimeTypes() {
            var mimeTypes = [
              "application/schema;version=draft-07",
              "application/schema+json;version=draft-07",
              "application/schema+yaml;version=draft-07"
            ];
            ["2.0.0", "2.1.0", "2.2.0", "2.3.0", "2.4.0"].forEach(function (
              version
            ) {
              mimeTypes.push(
                "application/vnd.aai.asyncapi;version=".concat(version),
                "application/vnd.aai.asyncapi+json;version=".concat(version),
                "application/vnd.aai.asyncapi+yaml;version=".concat(version)
              );
            });
            return mimeTypes;
          }
          /**
           * Creates (or reuses) a function that validates an AsyncAPI Schema Object based on the passed AsyncAPI version.
           *
           * @private
           * @param {Object} version AsyncAPI version.
           * @returns {Function} Function that validates an AsyncAPI Schema Object based on the passed AsyncAPI version.
           */ function getValidator(version) {
            var validate = ajv.getSchema(version);
            if (!validate) {
              ajv.addSchema(
                preparePayloadSchema(asyncapi[String(version)]),
                version
              );
              validate = ajv.getSchema(version);
            }
            return validate;
          }
          /**
           * To validate schema of the payload we just need a small portion of official AsyncAPI spec JSON Schema, the definition of the schema must be
           * a main part of the JSON Schema
           *
           * @private
           * @param {Object} asyncapiSchema AsyncAPI specification JSON Schema
           * @returns {Object} valid JSON Schema document describing format of AsyncAPI-valid schema for message payload
           */ function preparePayloadSchema(asyncapiSchema) {
            return {
              $ref: "#/definitions/schema",
              definitions: asyncapiSchema.definitions
            };
          }
          /**
           * Errors from Ajv contain dataPath information about parameter relative to parsed payload message.
           * This function enriches dataPath with additional information on where is the parameter located in AsyncAPI document
           *
           * @private
           * @param  {Array<Object>} errors Ajv errors
           * @param  {String} path Path to location of the payload schema in AsyncAPI Document
           * @returns {Array<Object>} same object as received in input but with modified datePath property so it contain full path relative to AsyncAPI document
           */ function addFullPathToDataPath(errors, path) {
            return errors.map(function (err) {
              return _objectSpread2(_objectSpread2({}, err), {
                dataPath: "".concat(path).concat(err.dataPath)
              });
            });
          }
        },
        {
          "./errors/parser-error": 50,
          "./utils": 87,
          "@asyncapi/specs": 88,
          ajv: 109,
          "ajv/lib/refs/json-schema-draft-04.json": 150,
          "lodash.clonedeep": 187
        }
      ],
      47: [
        function (require, module, exports) {
          window.AsyncAPIParser = require("./index");
        },
        { "./index": 51 }
      ],
      48: [
        function (require, module, exports) {
          var xParserSpecParsed = "x-parser-spec-parsed";
          var xParserSpecStringified = "x-parser-spec-stringified";
          var xParserMessageName = "x-parser-message-name";
          var xParserSchemaId = "x-parser-schema-id";
          var xParserCircle = "x-parser-circular";
          var xParserCircleProps = "x-parser-circular-props";
          module.exports = {
            xParserSpecParsed: xParserSpecParsed,
            xParserSpecStringified: xParserSpecStringified,
            xParserMessageName: xParserMessageName,
            xParserSchemaId: xParserSchemaId,
            xParserCircle: xParserCircle,
            xParserCircleProps: xParserCircleProps
          };
        },
        {}
      ],
      49: [
        function (require, module, exports) {
          var ParserError = require("./errors/parser-error"); // eslint-disable-next-line no-unused-vars
          var Operation = require("./models/operation");
          var _require25 = require("./utils"),
            parseUrlVariables = _require25.parseUrlVariables,
            getMissingProps = _require25.getMissingProps,
            groupValidationErrors = _require25.groupValidationErrors,
            tilde = _require25.tilde,
            parseUrlQueryParameters = _require25.parseUrlQueryParameters,
            setNotProvidedParams = _require25.setNotProvidedParams,
            getUnknownServers = _require25.getUnknownServers;
          var validationError = "validation-errors";
          /**
           * Validates if variables provided in the url have corresponding variable object defined and if example is correct
           * @private
           * @param  {Object} parsedJSON parsed AsyncAPI document
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was originally JSON or YAML
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateServerVariables(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var srvs = parsedJSON.servers;
            if (!srvs) return true;
            var srvsMap = new Map(Object.entries(srvs));
            var notProvidedVariables = new Map();
            var notProvidedExamplesInEnum = new Map();
            srvsMap.forEach(function (srvr, srvrName) {
              var variables = parseUrlVariables(srvr.url);
              var variablesObj = srvr.variables;
              var notProvidedServerVars = notProvidedVariables.get(
                tilde(srvrName)
              );
              if (!variables) return;
              var missingServerVariables = getMissingProps(
                variables,
                variablesObj
              );
              if (missingServerVariables.length) {
                notProvidedVariables.set(
                  tilde(srvrName),
                  notProvidedServerVars
                    ? notProvidedServerVars.concat(missingServerVariables)
                    : missingServerVariables
                );
              }
              if (variablesObj) {
                setNotValidExamples(
                  variablesObj,
                  srvrName,
                  notProvidedExamplesInEnum
                );
              }
            });
            if (notProvidedVariables.size) {
              throw new ParserError({
                type: validationError,
                title:
                  "Not all server variables are described with variable object",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  "servers",
                  "server does not have a corresponding variable object for",
                  notProvidedVariables,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            if (notProvidedExamplesInEnum.size) {
              throw new ParserError({
                type: validationError,
                title:
                  "Check your server variables. The example does not match the enum list",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  "servers",
                  "server variable provides an example that does not match the enum list",
                  notProvidedExamplesInEnum,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            return true;
          }
          /**
           * extend map with info about examples that are not part of the enum
           *
           * @function setNotValidExamples
           * @private
           * @param  {Array<Object>} variables server variables object
           * @param  {String} srvrName name of the server where variables object is located
           * @param  {Map} notProvidedExamplesInEnum result map of all wrong examples and what variable they belong to
           */ function setNotValidExamples(
            variables,
            srvrName,
            notProvidedExamplesInEnum
          ) {
            var variablesMap = new Map(Object.entries(variables));
            variablesMap.forEach(function (variable, variableName) {
              if (variable["enum"] && variable.examples) {
                var wrongExamples = variable.examples.filter(function (r) {
                  return !variable["enum"].includes(r);
                });
                if (wrongExamples.length) {
                  notProvidedExamplesInEnum.set(
                    ""
                      .concat(tilde(srvrName), "/variables/")
                      .concat(tilde(variableName)),
                    wrongExamples
                  );
                }
              }
            });
          }
          /**
           * Validates if operationIds are duplicated in the document
           *
           * @private
           * @param  {Object} parsedJSON parsed AsyncAPI document
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was originally JSON or YAML
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateOperationId(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat,
            operations
          ) {
            var chnls = parsedJSON.channels;
            if (!chnls) return true;
            var chnlsMap = new Map(Object.entries(chnls)); //it is a map of paths, the one that is a duplicate and the one that is duplicated
            var duplicatedOperations = new Map(); //is is a 2-dimensional array that holds information with operationId value and its path
            var allOperations = [];
            var addDuplicateToMap = function addDuplicateToMap(
              op,
              channelName,
              opName
            ) {
              var operationId = op.operationId;
              if (!operationId) return;
              var operationPath = ""
                .concat(tilde(channelName), "/")
                .concat(opName, "/operationId");
              var isOperationIdDuplicated = allOperations.filter(function (v) {
                return v[0] === operationId;
              });
              if (!isOperationIdDuplicated.length)
                return allOperations.push([operationId, operationPath]); //isOperationIdDuplicated always holds one record and it is an array of paths, the one that is a duplicate and the one that is duplicated
              duplicatedOperations.set(
                operationPath,
                isOperationIdDuplicated[0][1]
              );
            };
            chnlsMap.forEach(function (chnlObj, chnlName) {
              operations.forEach(function (opName) {
                var op = chnlObj[String(opName)];
                if (op) addDuplicateToMap(op, chnlName, opName);
              });
            });
            if (duplicatedOperations.size) {
              throw new ParserError({
                type: validationError,
                title: "operationId must be unique across all the operations.",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  "channels",
                  "is a duplicate of",
                  duplicatedOperations,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            return true;
          }
          /**
           * Validates if messageIds are duplicated in the document
           *
           * @private
           * @param  {Object} parsedJSON parsed AsyncAPI document
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was originally JSON or YAML
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateMessageId(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat,
            operations
          ) {
            var chnls = parsedJSON.channels;
            if (!chnls) return true;
            var chnlsMap = new Map(Object.entries(chnls)); //it is a map of paths, the one that is a duplicate and the one that is duplicated
            var duplicatedMessages = new Map(); //is is a 2-dimensional array that holds information with messageId value and its path
            var allMessages = [];
            var addDuplicateToMap = function addDuplicateToMap(
              msg,
              channelName,
              opName
            ) {
              var oneOf =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : "";
              var messageId = msg.messageId;
              if (!messageId) return;
              var messagePath = ""
                .concat(tilde(channelName), "/")
                .concat(opName, "/message")
                .concat(oneOf, "/messageId");
              var isMessageIdDuplicated = allMessages.find(function (v) {
                return v[0] === messageId;
              });
              if (!isMessageIdDuplicated)
                return allMessages.push([messageId, messagePath]); //isMessageIdDuplicated always holds one record and it is an array of paths, the one that is a duplicate and the one that is duplicated
              duplicatedMessages.set(messagePath, isMessageIdDuplicated[1]);
            };
            chnlsMap.forEach(function (chnlObj, chnlName) {
              operations.forEach(function (opName) {
                var op = chnlObj[String(opName)];
                if (op && op.message) {
                  if (op.message.oneOf)
                    op.message.oneOf.forEach(function (msg, index) {
                      return addDuplicateToMap(
                        msg,
                        chnlName,
                        opName,
                        "/oneOf/".concat(index)
                      );
                    });
                  else addDuplicateToMap(op.message, chnlName, opName);
                }
              });
            });
            if (duplicatedMessages.size) {
              throw new ParserError({
                type: validationError,
                title: "messageId must be unique across all the messages.",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  "channels",
                  "is a duplicate of",
                  duplicatedMessages,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            return true;
          }
          /**
           * Validates if server security is declared properly and the name has a corresponding security schema definition in components with the same name
           *
           * @private
           * @param  {Object} parsedJSON parsed AsyncAPI document
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was originally JSON or YAML
           * @param  {String[]} specialSecTypes list of security types that can have data in array
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateServerSecurity(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat,
            specialSecTypes
          ) {
            var srvs = parsedJSON.servers;
            if (!srvs) return true;
            var root = "servers";
            var srvsMap = new Map(Object.entries(srvs));
            var missingSecSchema = new Map(),
              invalidSecurityValues = new Map(); //we need to validate every server specified in the document
            srvsMap.forEach(function (server, serverName) {
              var serverSecInfo = server.security;
              if (!serverSecInfo) return true; //server security info is an array of many possible values
              serverSecInfo.forEach(function (secObj) {
                Object.keys(secObj).forEach(function (secName) {
                  //security schema is located in components object, we need to find if there is security schema with the same name as the server security info object
                  var schema = findSecuritySchema(secName, parsedJSON.components);
                  var srvrSecurityPath = ""
                    .concat(serverName, "/security/")
                    .concat(secName);
                  if (!schema.length)
                    return missingSecSchema.set(srvrSecurityPath); //findSecuritySchema returns type always on index 1. Type is needed further to validate if server security info can be or not an empty array
                  var schemaType = schema[1];
                  if (
                    !isSrvrSecProperArray(
                      schemaType,
                      specialSecTypes,
                      secObj,
                      secName
                    )
                  )
                    invalidSecurityValues.set(srvrSecurityPath, schemaType);
                });
              });
            });
            if (missingSecSchema.size) {
              throw new ParserError({
                type: validationError,
                title:
                  "Server security name must correspond to a security scheme which is declared in the security schemes under the components object.",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  root,
                  "doesn't have a corresponding security schema under the components object",
                  missingSecSchema,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            if (invalidSecurityValues.size) {
              throw new ParserError({
                type: validationError,
                title:
                  "Server security value must be an empty array if corresponding security schema type is not oauth2 or openIdConnect.",
                parsedJSON: parsedJSON,
                validationErrors: groupValidationErrors(
                  root,
                  "security info must have an empty array because its corresponding security schema type is",
                  invalidSecurityValues,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            }
            return true;
          }
          /**
           * Searches for server security corresponding object in security schema object
           * @private
           * @param  {String} securityName name of the server security element that you want to localize in the security schema object
           * @param  {Object} components components object from the AsyncAPI document
           * @returns {String[]} there are 2 elements in array, index 0 is the name of the security schema object and index 1 is it's type
           */ function findSecuritySchema(securityName, components) {
            var secSchemes = components && components.securitySchemes;
            var secSchemesMap = secSchemes
              ? new Map(Object.entries(secSchemes))
              : new Map();
            var schemaInfo = []; //using for loop here as there is no point to iterate over all entries as it is enough to find first matching element
            var _iterator8 = _createForOfIteratorHelper(secSchemesMap.entries()),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                var _step8$value = _slicedToArray(_step8.value, 2),
                  schemaName = _step8$value[0],
                  schema = _step8$value[1];
                if (schemaName === securityName) {
                  schemaInfo.push(schemaName, schema.type);
                  return schemaInfo;
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            return schemaInfo;
          }
          /**
           * Validates if given server security is a proper empty array when security type requires it
           * @private
           * @param  {String} schemaType security type, like httpApiKey or userPassword
           * @param  {String[]} specialSecTypes list of special types that do not have to be an empty array
           * @param  {Object} secObj server security object
           * @param  {String} secName name os server security object
           * @returns {String[]} there are 2 elements in array, index 0 is the name of the security schema object and index 1 is it's type
           */ function isSrvrSecProperArray(
            schemaType,
            specialSecTypes,
            secObj,
            secName
          ) {
            if (!specialSecTypes.includes(schemaType)) {
              var securityObjValue = secObj[String(secName)];
              return !securityObjValue.length;
            }
            return true;
          }
          /**
           * Validates if parameters specified in the channel have corresponding parameters object defined and if name does not contain url parameters.
           * Also validates that all servers listed for this channel are declared in the top-level servers object.
           *
           * @private
           * @param  {Object} parsedJSON parsed AsyncAPI document
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was originally JSON or YAML
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateChannels(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var chnls = parsedJSON.channels;
            if (!chnls) return true;
            var chnlsMap = new Map(Object.entries(chnls));
            var notProvidedParams = new Map(); //return object for missing parameters
            var invalidChannelName = new Map(); //return object for invalid channel names with query parameters
            var unknownServers = new Map(); //return object for server names not declared in top-level servers object
            chnlsMap.forEach(function (val, key) {
              var variables = parseUrlVariables(key);
              var notProvidedChannelParams = notProvidedParams.get(tilde(key));
              var queryParameters = parseUrlQueryParameters(key);
              var unknownServerNames = getUnknownServers(parsedJSON, val); //channel variable validation: fill return object with missing parameters
              if (variables) {
                setNotProvidedParams(
                  variables,
                  val,
                  key,
                  notProvidedChannelParams,
                  notProvidedParams
                );
              } //channel name validation: fill return object with channels containing query parameters
              if (queryParameters) {
                invalidChannelName.set(tilde(key), queryParameters);
              } //server validation: fill return object with unknown server names
              if (unknownServerNames.length > 0) {
                unknownServers.set(tilde(key), unknownServerNames);
              }
            }); //combine validation errors of both checks and output them as one array
            var parameterValidationErrors = groupValidationErrors(
              "channels",
              "channel does not have a corresponding parameter object for",
              notProvidedParams,
              asyncapiYAMLorJSON,
              initialFormat
            );
            var nameValidationErrors = groupValidationErrors(
              "channels",
              "channel contains invalid name with url query parameters",
              invalidChannelName,
              asyncapiYAMLorJSON,
              initialFormat
            );
            var serverValidationErrors = groupValidationErrors(
              "channels",
              "channel contains servers that are not on the servers list in the root of the document",
              unknownServers,
              asyncapiYAMLorJSON,
              initialFormat
            );
            var allValidationErrors = parameterValidationErrors
              .concat(nameValidationErrors)
              .concat(serverValidationErrors); //channel variable validation: throw exception if channel validation fails
            if (
              notProvidedParams.size ||
              invalidChannelName.size ||
              unknownServers.size
            ) {
              throw new ParserError({
                type: validationError,
                title: "Channel validation failed",
                parsedJSON: parsedJSON,
                validationErrors: allValidationErrors
              });
            }
            return true;
          }
          /**
           * Validates if tags specified in the following objects have no duplicates: root, operations, operation traits, channels,
           * messages and message traits.
           *
           * @private
           * @param {Object} parsedJSON parsed AsyncAPI document
           * @param {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param {String} initialFormat information of the document was originally JSON or YAML
           * @returns {Boolean} true in case the document is valid, otherwise throws {@link ParserError}
           */ function validateTags(
            parsedJSON,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var invalidRoot = validateRootTags(parsedJSON);
            var invalidChannels = validateAllChannelsTags(parsedJSON);
            var invalidOperationTraits = validateOperationTraitTags(parsedJSON);
            var invalidMessages = validateMessageTags(parsedJSON);
            var invalidMessageTraits = validateMessageTraitsTags(parsedJSON);
            var errorMessage = "contains duplicate tag names";
            var invalidRootValidationErrors = [];
            var invalidChannelsValidationErrors = [];
            var invalidOperationTraitsValidationErrors = [];
            var invalidMessagesValidationErrors = [];
            var invalidMessageTraitsValidationErrors = [];
            if (invalidRoot.size) {
              invalidRootValidationErrors = groupValidationErrors(
                null,
                errorMessage,
                invalidRoot,
                asyncapiYAMLorJSON,
                initialFormat
              );
            }
            if (invalidChannels.size) {
              invalidChannelsValidationErrors = groupValidationErrors(
                "channels",
                errorMessage,
                invalidChannels,
                asyncapiYAMLorJSON,
                initialFormat
              );
            }
            if (invalidOperationTraits.size) {
              invalidOperationTraitsValidationErrors = groupValidationErrors(
                "components",
                errorMessage,
                invalidOperationTraits,
                asyncapiYAMLorJSON,
                initialFormat
              );
            }
            if (invalidMessages.size) {
              invalidMessagesValidationErrors = groupValidationErrors(
                "components",
                errorMessage,
                invalidMessages,
                asyncapiYAMLorJSON,
                initialFormat
              );
            }
            if (invalidMessageTraits.size) {
              invalidMessageTraitsValidationErrors = groupValidationErrors(
                "components",
                errorMessage,
                invalidMessageTraits,
                asyncapiYAMLorJSON,
                initialFormat
              );
            }
            var allValidationErrors = invalidRootValidationErrors
              .concat(invalidChannelsValidationErrors)
              .concat(invalidOperationTraitsValidationErrors)
              .concat(invalidMessagesValidationErrors)
              .concat(invalidMessageTraitsValidationErrors);
            if (allValidationErrors.length) {
              throw new ParserError({
                type: validationError,
                title: "Tags validation failed",
                parsedJSON: parsedJSON,
                validationErrors: allValidationErrors
              });
            }
            return true;
          }
          function validateRootTags(parsedJSON) {
            var invalidRoot = new Map();
            var duplicateNames =
              parsedJSON.tags && getDuplicateTagNames(parsedJSON.tags);
            if (duplicateNames && duplicateNames.length) {
              invalidRoot.set("tags", duplicateNames.toString());
            }
            return invalidRoot;
          }
          function validateOperationTraitTags(parsedJSON) {
            var invalidOperationTraits = new Map();
            if (
              parsedJSON &&
              parsedJSON.components &&
              parsedJSON.components.operationTraits
            ) {
              Object.keys(parsedJSON.components.operationTraits).forEach(
                function (operationTrait) {
                  // eslint-disable-next-line security/detect-object-injection
                  var duplicateNames = getDuplicateTagNames(
                    parsedJSON.components.operationTraits[operationTrait].tags
                  );
                  if (duplicateNames && duplicateNames.length) {
                    var operationTraitsPath = "operationTraits/".concat(
                      operationTrait,
                      "/tags"
                    );
                    invalidOperationTraits.set(
                      operationTraitsPath,
                      duplicateNames.toString()
                    );
                  }
                }
              );
            }
            return invalidOperationTraits;
          }
          function validateAllChannelsTags(parsedJSON) {
            var chnls = parsedJSON.channels;
            if (!chnls) return true;
            var chnlsMap = new Map(Object.entries(chnls));
            var invalidChannels = new Map();
            chnlsMap.forEach(function (channel, channelName) {
              return validateChannelTags(invalidChannels, channel, channelName);
            });
            return invalidChannels;
          }
          function validateChannelTags(invalidChannels, channel, channelName) {
            if (channel.publish) {
              validateOperationTags(
                invalidChannels,
                channel.publish,
                "".concat(tilde(channelName), "/publish")
              );
            }
            if (channel.subscribe) {
              validateOperationTags(
                invalidChannels,
                channel.subscribe,
                "".concat(tilde(channelName), "/subscribe")
              );
            }
          }
          /**
           * Check tags in operation and in message.
           *
           * @private
           * @param {Map} invalidChannels map with invalid channel entries
           * @param {Operation} operation operation object
           * @param {String} operationPath operation path
           */ function validateOperationTags(
            invalidChannels,
            operation,
            operationPath
          ) {
            if (!operation) return;
            tryAddInvalidEntries(
              invalidChannels,
              "".concat(operationPath, "/tags"),
              operation.tags
            );
            if (operation.message) {
              if (operation.message.oneOf) {
                operation.message.oneOf.forEach(function (message, idx) {
                  tryAddInvalidEntries(
                    invalidChannels,
                    ""
                      .concat(operationPath, "/message/oneOf/")
                      .concat(idx, "/tags"),
                    message.tags
                  );
                });
              } else {
                tryAddInvalidEntries(
                  invalidChannels,
                  "".concat(operationPath, "/message/tags"),
                  operation.message.tags
                );
              }
            }
          }
          function tryAddInvalidEntries(invalidChannels, key, tags) {
            var duplicateNames = tags && getDuplicateTagNames(tags);
            if (duplicateNames && duplicateNames.length) {
              invalidChannels.set(key, duplicateNames.toString());
            }
          }
          function validateMessageTraitsTags(parsedJSON) {
            var invalidMessageTraits = new Map();
            if (
              parsedJSON &&
              parsedJSON.components &&
              parsedJSON.components.messageTraits
            ) {
              Object.keys(parsedJSON.components.messageTraits).forEach(function (
                messageTrait
              ) {
                // eslint-disable-next-line security/detect-object-injection
                var duplicateNames = getDuplicateTagNames(
                  parsedJSON.components.messageTraits[messageTrait].tags
                );
                if (duplicateNames && duplicateNames.length) {
                  var messageTraitsPath = "messageTraits/".concat(
                    messageTrait,
                    "/tags"
                  );
                  invalidMessageTraits.set(
                    messageTraitsPath,
                    duplicateNames.toString()
                  );
                }
              });
            }
            return invalidMessageTraits;
          }
          function validateMessageTags(parsedJSON) {
            var invalidMessages = new Map();
            if (
              parsedJSON &&
              parsedJSON.components &&
              parsedJSON.components.messages
            ) {
              Object.keys(parsedJSON.components.messages).forEach(function (
                message
              ) {
                // eslint-disable-next-line security/detect-object-injection
                var duplicateNames = getDuplicateTagNames(
                  parsedJSON.components.messages[message].tags
                );
                if (duplicateNames && duplicateNames.length) {
                  var messagePath = "messages/".concat(message, "/tags");
                  invalidMessages.set(messagePath, duplicateNames.toString());
                }
              });
            }
            return invalidMessages;
          }
          function getDuplicateTagNames(tags) {
            if (!tags) return null;
            var tagNames = tags.map(function (item) {
              return item.name;
            });
            return tagNames.reduce(function (acc, item, idx, arr) {
              if (arr.indexOf(item) !== idx && acc.indexOf(item) < 0) {
                acc.push(item);
              }
              return acc;
            }, []);
          }
          module.exports = {
            validateServerVariables: validateServerVariables,
            validateOperationId: validateOperationId,
            validateMessageId: validateMessageId,
            validateServerSecurity: validateServerSecurity,
            validateChannels: validateChannels,
            validateTags: validateTags
          };
        },
        { "./errors/parser-error": 50, "./models/operation": 76, "./utils": 87 }
      ],
      50: [
        function (require, module, exports) {
          var ERROR_URL_PREFIX = "https://github.com/asyncapi/parser-js/";
          var buildError = function buildError(from, to) {
            to.type = from.type.startsWith(ERROR_URL_PREFIX)
              ? from.type
              : "".concat(ERROR_URL_PREFIX).concat(from.type);
            to.title = from.title;
            if (from.detail) to.detail = from.detail;
            if (from.validationErrors)
              to.validationErrors = from.validationErrors;
            if (from.parsedJSON) to.parsedJSON = from.parsedJSON;
            if (from.location) to.location = from.location;
            if (from.refs) to.refs = from.refs;
            return to;
          };
          /**
           * Represents an error while trying to parse an AsyncAPI document.
           * @alias module:@asyncapi/parser#ParserError
           * @extends Error
           */ var ParserError = /*#__PURE__*/ (function (_Error3) {
            "use strict";
            _inherits(ParserError, _Error3);
            var _super9 = _createSuper(ParserError);
            /**
             * Instantiates an error
             * @param {Object} definition
             * @param {String} definition.type The type of the error.
             * @param {String} definition.title The message of the error.
             * @param {String} [definition.detail] A string containing more detailed information about the error.
             * @param {Object} [definition.parsedJSON] The resulting JSON after YAML transformation. Or the JSON object if the this was the initial format.
             * @param {Object[]} [definition.validationErrors] The errors resulting from the validation. For more information, see https://www.npmjs.com/package/better-ajv-errors.
             * @param {String} definition.validationErrors.title A validation error message.
             * @param {String} definition.validationErrors.jsonPointer The path to the field that contains the error. Uses JSON Pointer format.
             * @param {Number} definition.validationErrors.startLine The line where the error starts in the AsyncAPI document.
             * @param {Number} definition.validationErrors.startColumn The column where the error starts in the AsyncAPI document.
             * @param {Number} definition.validationErrors.startOffset The offset (starting from the beginning of the document) where the error starts in the AsyncAPI document.
             * @param {Number} definition.validationErrors.endLine The line where the error ends in the AsyncAPI document.
             * @param {Number} definition.validationErrors.endColumn The column where the error ends in the AsyncAPI document.
             * @param {Number} definition.validationErrors.endOffset The offset (starting from the beginning of the document) where the error ends in the AsyncAPI document.
             * @param {Object} [definition.location] Error location details after trying to parse an invalid JSON or YAML document.
             * @param {Number} definition.location.startLine The line of the YAML/JSON document where the error starts.
             * @param {Number} definition.location.startColumn The column of the YAML/JSON document where the error starts.
             * @param {Number} definition.location.startOffset The offset (starting from the beginning of the document) where the error starts in the YAML/JSON AsyncAPI document.
             * @param {Object[]} [definition.refs] Error details after trying to resolve $ref's.
             * @param {String} definition.refs.title A validation error message.
             * @param {String} definition.refs.jsonPointer The path to the field that contains the error. Uses JSON Pointer format.
             * @param {Number} definition.refs.startLine The line where the error starts in the AsyncAPI document.
             * @param {Number} definition.refs.startColumn The column where the error starts in the AsyncAPI document.
             * @param {Number} definition.refs.startOffset The offset (starting from the beginning of the document) where the error starts in the AsyncAPI document.
             * @param {Number} definition.refs.endLine The line where the error ends in the AsyncAPI document.
             * @param {Number} definition.refs.endColumn The column where the error ends in the AsyncAPI document.
             * @param {Number} definition.refs.endOffset The offset (starting from the beginning of the document) where the error ends in the AsyncAPI document.
             */ function ParserError(def) {
              var _this11;
              _classCallCheck2(this, ParserError);
              _this11 = _super9.call(this);
              buildError(def, _assertThisInitialized(_this11));
              _this11.message = def.title;
              return _this11;
            }
            /**
             * Returns a JS object representation of the error.
             */ _createClass2(ParserError, [
              {
                key: "toJS",
                value: function toJS() {
                  return buildError(this, {});
                }
              }
            ]);
            return ParserError;
          })(/*#__PURE__*/ _wrapNativeSuper(Error));
          module.exports = ParserError;
        },
        {}
      ],
      51: [
        function (require, module, exports) {
          var parser = require("./parser");
          var defaultAsyncAPISchemaParser = require("./asyncapiSchemaFormatParser");
          parser.registerSchemaParser(defaultAsyncAPISchemaParser);
          module.exports = parser;
        },
        { "./asyncapiSchemaFormatParser": 46, "./parser": 86 }
      ],
      52: [
        function (require, module, exports) {
          /**
           * @readonly
           * @enum {SchemaIteratorCallbackType}
           */ /**
           * The different kind of stages when crawling a schema.
           *
           * @typedef SchemaIteratorCallbackType
           * @property {string} NEW_SCHEMA The crawler just started crawling a schema.
           * @property {string} END_SCHEMA The crawler just finished crawling a schema.
           */ var SchemaIteratorCallbackType = Object.freeze({
            NEW_SCHEMA: "NEW_SCHEMA",
            END_SCHEMA: "END_SCHEMA"
          });
          /**
           *
           * @readonly
           * @enum {SchemaTypesToIterate}
           */ /**
           * The different types of schemas you can iterate
           *
           * @typedef SchemaTypesToIterate
           * @property {string} parameters Crawl all schemas in parameters
           * @property {string} payloads Crawl all schemas in payloads
           * @property {string} headers Crawl all schemas in headers
           * @property {string} components Crawl all schemas in components
           * @property {string} objects Crawl all schemas of type object
           * @property {string} arrays Crawl all schemas of type array
           * @property {string} oneOfs Crawl all schemas in oneOf's
           * @property {string} allOfs Crawl all schemas in allOf's
           * @property {string} anyOfs Crawl all schemas in anyOf's
           * @property {string} nots Crawl all schemas in not field
           * @property {string} propertyNames Crawl all schemas in propertyNames field
           * @property {string} patternProperties Crawl all schemas in patternProperties field
           * @property {string} contains Crawl all schemas in contains field
           * @property {string} ifs Crawl all schemas in if field
           * @property {string} thenes Crawl all schemas in then field
           * @property {string} elses Crawl all schemas in else field
           * @property {string} dependencies Crawl all schemas in dependencies field
           * @property {string} definitions Crawl all schemas in definitions field
           */ var SchemaTypesToIterate = Object.freeze({
            parameters: "parameters",
            payloads: "payloads",
            headers: "headers",
            components: "components",
            objects: "objects",
            arrays: "arrays",
            oneOfs: "oneOfs",
            allOfs: "allOfs",
            anyOfs: "anyOfs",
            nots: "nots",
            propertyNames: "propertyNames",
            patternProperties: "patternProperties",
            contains: "contains",
            ifs: "ifs",
            thenes: "thenes",
            elses: "elses",
            dependencies: "dependencies",
            definitions: "definitions"
          });
          /* eslint-disable sonarjs/cognitive-complexity */ /**
           * Traverse current schema and all nested schemas.
           *
           * @private
           * @param {Schema} schema which is being crawled.
           * @param {(String | Number)} propOrIndex if the schema is from a property/index get the name/number of such.
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function traverseSchema(schema, propOrIndex, options) {
            // NOSONAR
            if (!schema) return;
            var callback = options.callback,
              schemaTypesToIterate = options.schemaTypesToIterate,
              seenSchemas = options.seenSchemas; // handle circular references
            var jsonSchema = schema.json();
            if (seenSchemas.has(jsonSchema)) return;
            seenSchemas.add(jsonSchema); // `type` isn't required so save type as array in the fallback
            var types = schema.type() || []; // change primitive type to array of types for easier handling
            if (!Array.isArray(types)) {
              types = [types];
            }
            if (
              !schemaTypesToIterate.includes(SchemaTypesToIterate.objects) &&
              types.includes("object")
            )
              return;
            if (
              !schemaTypesToIterate.includes(SchemaTypesToIterate.arrays) &&
              types.includes("array")
            )
              return; // check callback `NEW_SCHEMA` case
            if (
              callback(
                schema,
                propOrIndex,
                SchemaIteratorCallbackType.NEW_SCHEMA
              ) === false
            )
              return;
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.objects) &&
              types.includes("object")
            ) {
              recursiveSchemaObject(schema, options);
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.arrays) &&
              types.includes("array")
            ) {
              recursiveSchemaArray(schema, options);
            }
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.oneOfs)) {
              (schema.oneOf() || []).forEach(function (combineSchema, idx) {
                traverseSchema(combineSchema, idx, options);
              });
            }
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.anyOfs)) {
              (schema.anyOf() || []).forEach(function (combineSchema, idx) {
                traverseSchema(combineSchema, idx, options);
              });
            }
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.allOfs)) {
              (schema.allOf() || []).forEach(function (combineSchema, idx) {
                traverseSchema(combineSchema, idx, options);
              });
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.nots) &&
              schema.not()
            ) {
              traverseSchema(schema.not(), null, options);
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.ifs) &&
              schema["if"]()
            ) {
              traverseSchema(schema["if"](), null, options);
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.thenes) &&
              schema.then()
            ) {
              traverseSchema(schema.then(), null, options);
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.elses) &&
              schema["else"]()
            ) {
              traverseSchema(schema["else"](), null, options);
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.dependencies)
            ) {
              Object.entries(schema.dependencies() || {}).forEach(function (
                _ref4
              ) {
                var _ref5 = _slicedToArray(_ref4, 2),
                  depName = _ref5[0],
                  dep = _ref5[1]; // do not iterate dependent required
                if (dep && !Array.isArray(dep)) {
                  traverseSchema(dep, depName, options);
                }
              });
            }
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.definitions)) {
              Object.entries(schema.definitions() || {}).forEach(function (
                _ref6
              ) {
                var _ref7 = _slicedToArray(_ref6, 2),
                  defName = _ref7[0],
                  def = _ref7[1];
                traverseSchema(def, defName, options);
              });
            }
            callback(schema, propOrIndex, SchemaIteratorCallbackType.END_SCHEMA);
            seenSchemas["delete"](jsonSchema);
          }
          /* eslint-enable sonarjs/cognitive-complexity */ /**
           * Recursively go through schema of object type and execute callback.
           *
           * @private
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function recursiveSchemaObject(schema, options) {
            Object.entries(schema.properties() || {}).forEach(function (_ref8) {
              var _ref9 = _slicedToArray(_ref8, 2),
                propertyName = _ref9[0],
                property = _ref9[1];
              traverseSchema(property, propertyName, options);
            });
            var additionalProperties = schema.additionalProperties();
            if (_typeof2(additionalProperties) === "object") {
              traverseSchema(additionalProperties, null, options);
            }
            var schemaTypesToIterate = options.schemaTypesToIterate;
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.propertyNames) &&
              schema.propertyNames()
            ) {
              traverseSchema(schema.propertyNames(), null, options);
            }
            if (
              schemaTypesToIterate.includes(
                SchemaTypesToIterate.patternProperties
              )
            ) {
              Object.entries(schema.patternProperties() || {}).forEach(function (
                _ref10
              ) {
                var _ref11 = _slicedToArray(_ref10, 2),
                  propertyName = _ref11[0],
                  property = _ref11[1];
                traverseSchema(property, propertyName, options);
              });
            }
          }
          /**
           * Recursively go through schema of array type and execute callback.
           *
           * @private
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function recursiveSchemaArray(schema, options) {
            var items = schema.items();
            if (items) {
              if (Array.isArray(items)) {
                items.forEach(function (item, idx) {
                  traverseSchema(item, idx, options);
                });
              } else {
                traverseSchema(items, null, options);
              }
            }
            var additionalItems = schema.additionalItems();
            if (_typeof2(additionalItems) === "object") {
              traverseSchema(additionalItems, null, options);
            }
            if (
              options.schemaTypesToIterate.includes(
                SchemaTypesToIterate.contains
              ) &&
              schema.contains()
            ) {
              traverseSchema(schema.contains(), null, options);
            }
          }
          /**
           * Go through each channel and for each parameter, and message payload and headers recursively call the callback for each schema.
           *
           * @private
           * @param {AsyncAPIDocument} doc parsed AsyncAPI Document
           * @param {FoundSchemaCallback} callback callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} schemaTypesToIterate list of schema types to crawl.
           */ function traverseAsyncApiDocument(
            doc,
            callback,
            schemaTypesToIterate
          ) {
            if (!schemaTypesToIterate) {
              schemaTypesToIterate = Object.values(SchemaTypesToIterate);
            }
            var options = {
              callback: callback,
              schemaTypesToIterate: schemaTypesToIterate,
              seenSchemas: new Set()
            };
            if (doc.hasChannels()) {
              Object.values(doc.channels()).forEach(function (channel) {
                traverseChannel(channel, options);
              });
            }
            if (
              schemaTypesToIterate.includes(SchemaTypesToIterate.components) &&
              doc.hasComponents()
            ) {
              var components = doc.components();
              Object.values(components.messages() || {}).forEach(function (
                message
              ) {
                traverseMessage(message, options);
              });
              Object.values(components.schemas() || {}).forEach(function (
                schema
              ) {
                traverseSchema(schema, null, options);
              });
              if (
                schemaTypesToIterate.includes(SchemaTypesToIterate.parameters)
              ) {
                Object.values(components.parameters() || {}).forEach(function (
                  parameter
                ) {
                  traverseSchema(parameter.schema(), null, options);
                });
              }
              Object.values(components.messageTraits() || {}).forEach(function (
                messageTrait
              ) {
                traverseMessageTrait(messageTrait, options);
              });
            }
          }
          /**
           * Go through each schema in channel
           *
           * @private
           * @param {Channel} channel
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function traverseChannel(channel, options) {
            if (!channel) return;
            var schemaTypesToIterate = options.schemaTypesToIterate;
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.parameters)) {
              Object.values(channel.parameters() || {}).forEach(function (
                parameter
              ) {
                traverseSchema(parameter.schema(), null, options);
              });
            }
            if (channel.hasPublish()) {
              channel
                .publish()
                .messages()
                .forEach(function (message) {
                  traverseMessage(message, options);
                });
            }
            if (channel.hasSubscribe()) {
              channel
                .subscribe()
                .messages()
                .forEach(function (message) {
                  traverseMessage(message, options);
                });
            }
          }
          /**
           * Go through each schema in a message
           *
           * @private
           * @param {Message} message
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function traverseMessage(message, options) {
            if (!message) return;
            var schemaTypesToIterate = options.schemaTypesToIterate;
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.headers)) {
              traverseSchema(message.headers(), null, options);
            }
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.payloads)) {
              traverseSchema(message.payload(), null, options);
            }
          }
          /**
           * Go through each schema in a messageTrait
           *
           * @private
           * @param {MessageTrait} messageTrait
           * @param {Object} options
           * @param {SchemaIteratorCallbackType} [options.callback] callback used when crawling a schema.
           * @param {SchemaTypesToIterate[]} [options.schemaTypesToIterate] list of schema types to crawl.
           * @param {Set<Object>} [options.seenSchemas] Set which holds all defined schemas in the tree - it is mainly used to check circular references
           */ function traverseMessageTrait(messageTrait, options) {
            if (!messageTrait) return;
            var schemaTypesToIterate = options.schemaTypesToIterate;
            if (schemaTypesToIterate.includes(SchemaTypesToIterate.headers)) {
              traverseSchema(messageTrait.headers(), null, options);
            }
          }
          module.exports = {
            SchemaIteratorCallbackType: SchemaIteratorCallbackType,
            SchemaTypesToIterate: SchemaTypesToIterate,
            traverseAsyncApiDocument: traverseAsyncApiDocument
          };
        },
        {}
      ],
      53: [
        function (require, module, exports) {
          module.exports = function (txt, reviver) {
            var context =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : 20;
            try {
              return JSON.parse(txt, reviver);
            } catch (e) {
              handleJsonNotString(txt);
              var syntaxErr = e.message.match(
                /^Unexpected token.*position\s+(\d+)/i
              );
              var errIdxBrokenJson = e.message.match(/^Unexpected end of JSON.*/i)
                ? txt.length - 1
                : null;
              var errIdx = syntaxErr ? +syntaxErr[1] : errIdxBrokenJson;
              handleErrIdxNotNull(e, txt, errIdx, context);
              e.offset = errIdx;
              var lines = txt.substr(0, errIdx).split("\n");
              e.startLine = lines.length;
              e.startColumn = lines[lines.length - 1].length;
              throw e;
            }
          };
          function handleJsonNotString(txt) {
            if (typeof txt !== "string") {
              var isEmptyArray = Array.isArray(txt) && txt.length === 0;
              var errorMessage = "Cannot parse ".concat(
                isEmptyArray ? "an empty array" : String(txt)
              );
              throw new TypeError(errorMessage);
            }
          }
          function handleErrIdxNotNull(e, txt, errIdx, context) {
            if (errIdx !== null) {
              var start = errIdx <= context ? 0 : errIdx - context;
              var end =
                errIdx + context >= txt.length ? txt.length : errIdx + context;
              e.message += " while parsing near '"
                .concat(start === 0 ? "" : "...")
                .concat(txt.slice(start, end))
                .concat(end === txt.length ? "" : "...", "'");
            } else {
              e.message += " while parsing '".concat(
                txt.slice(0, context * 2),
                "'"
              );
            }
          }
        },
        {}
      ],
      54: [
        function (require, module, exports) {
          var _require26 = require("../models/utils"),
            getMapValueByKey = _require26.getMapValueByKey;
          /**
           * Implements functions to deal with the common Bindings object.
           * @mixin
           */ var MixinBindings = {
            /**
             * @returns {boolean}
             */ hasBindings: function hasBindings() {
              return !!(
                this._json.bindings && Object.keys(this._json.bindings).length
              );
            },
            /**
             * @returns {Object}
             */ bindings: function bindings() {
              return this.hasBindings() ? this._json.bindings : {};
            },
            /**
             * @returns {string[]}
             */ bindingProtocols: function bindingProtocols() {
              return Object.keys(this.bindings());
            },
            /**
             * @param {string} name - Name of the binding.
             * @returns {boolean}
             */ hasBinding: function hasBinding(name) {
              return this.hasBindings() && !!this._json.bindings[String(name)];
            },
            /**
             * @param {string} name - Name of the binding.
             * @returns {(Object | null)}
             */ binding: function binding(name) {
              return getMapValueByKey(this._json.bindings, name);
            }
          };
          module.exports = MixinBindings;
        },
        { "../models/utils": 85 }
      ],
      55: [
        function (require, module, exports) {
          var _require27 = require("../models/utils"),
            getMapValueByKey = _require27.getMapValueByKey;
          /**
           * Implements functions to deal with the description field.
           * @mixin
           */ var MixinDescription = {
            /**
             * @returns {boolean}
             */ hasDescription: function hasDescription() {
              return !!this._json.description;
            },
            /**
             * @returns {(string | null)}
             */ description: function description() {
              return getMapValueByKey(this._json, "description");
            }
          };
          module.exports = MixinDescription;
        },
        { "../models/utils": 85 }
      ],
      56: [
        function (require, module, exports) {
          var _require28 = require("../models/utils"),
            getMapValueOfType = _require28.getMapValueOfType;
          var ExternalDocs = require("../models/external-docs");
          /**
           * Implements functions to deal with the ExternalDocs object.
           * @mixin
           */ var MixinExternalDocs = {
            /**
             * @returns {boolean}
             */ hasExternalDocs: function hasExternalDocs() {
              return !!(
                this._json.externalDocs &&
                Object.keys(this._json.externalDocs).length
              );
            },
            /**
             * @returns {(ExternalDocs | null)}
             */ externalDocs: function externalDocs() {
              return getMapValueOfType(this._json, "externalDocs", ExternalDocs);
            }
          };
          module.exports = MixinExternalDocs;
        },
        { "../models/external-docs": 66, "../models/utils": 85 }
      ],
      57: [
        function (require, module, exports) {
          /**
           * Implements functions to deal with the SpecificationExtensions object.
           * @mixin
           */ var MixinSpecificationExtensions = {
            /**
             * @returns {boolean}
             */ hasExtensions: function hasExtensions() {
              return !!this.extensionKeys().length;
            },
            /**
             * @returns {Object<string, any>}
             */ extensions: function extensions() {
              var result = {};
              Object.entries(this._json).forEach(function (_ref12) {
                var _ref13 = _slicedToArray(_ref12, 2),
                  key = _ref13[0],
                  value = _ref13[1];
                if (/^x-[\w\d\.\-\_]+$/.test(key)) {
                  result[String(key)] = value;
                }
              });
              return result;
            },
            /**
             * @returns {string[]}
             */ extensionKeys: function extensionKeys() {
              return Object.keys(this.extensions());
            },
            /**
             * @returns {string[]}
             */ extKeys: function extKeys() {
              return this.extensionKeys();
            },
            /**
             * @param {string} key - Extension key.
             * @returns {boolean}
             */ hasExtension: function hasExtension(key) {
              if (!key.startsWith("x-")) {
                return false;
              }
              return !!this._json[String(key)];
            },
            /**
             * @param {string} key - Extension key.
             * @returns {any}
             */ extension: function extension(key) {
              if (!key.startsWith("x-")) {
                return null;
              }
              return this._json[String(key)];
            },
            /**
             * @param {string} key - Extension key.
             * @returns {boolean}
             */ hasExt: function hasExt(key) {
              return this.hasExtension(key);
            },
            /**
             * @param {string} key - Extension key.
             * @returns {any}
             */ ext: function ext(key) {
              return this.extension(key);
            }
          };
          module.exports = MixinSpecificationExtensions;
        },
        {}
      ],
      58: [
        function (require, module, exports) {
          var Tag = require("../models/tag");
          /**
           * Implements functions to deal with the Tags object.
           * @mixin
           */ var MixinTags = {
            /**
             * @returns {boolean}
             */ hasTags: function hasTags() {
              return !!(Array.isArray(this._json.tags) && this._json.tags.length);
            },
            /**
             * @returns {Tag[]}
             */ tags: function tags() {
              return this.hasTags()
                ? this._json.tags.map(function (t) {
                    return new Tag(t);
                  })
                : [];
            },
            /**
             * @returns {string[]}
             */ tagNames: function tagNames() {
              return this.hasTags()
                ? this._json.tags.map(function (t) {
                    return t.name;
                  })
                : [];
            },
            /**
             * @param {string} name - Name of the tag.
             * @returns {boolean}
             */ hasTag: function hasTag(name) {
              return (
                this.hasTags() &&
                this._json.tags.some(function (t) {
                  return t.name === name;
                })
              );
            },
            /**
             * @param {string} name - Name of the tag.
             * @returns {(Tag | null)}
             */ tag: function tag(name) {
              var tg =
                this.hasTags() &&
                this._json.tags.find(function (t) {
                  return t.name === name;
                });
              return tg ? new Tag(tg) : null;
            }
          };
          module.exports = MixinTags;
        },
        { "../models/tag": 84 }
      ],
      59: [
        function (require, module, exports) {
          var _require29 = require("./utils"),
            createMapOfType = _require29.createMapOfType,
            getMapValueOfType = _require29.getMapValueOfType,
            mix = _require29.mix;
          var Base = require("./base");
          var Info = require("./info");
          var Server = require("./server");
          var Channel = require("./channel");
          var Components = require("./components");
          var MixinExternalDocs = require("../mixins/external-docs");
          var MixinTags = require("../mixins/tags");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          var _require30 = require("../constants"),
            xParserSpecParsed = _require30.xParserSpecParsed,
            xParserSpecStringified = _require30.xParserSpecStringified,
            xParserCircle = _require30.xParserCircle;
          var _require31 = require("../anonymousNaming"),
            assignNameToAnonymousMessages =
              _require31.assignNameToAnonymousMessages,
            assignNameToComponentMessages =
              _require31.assignNameToComponentMessages,
            assignUidToComponentSchemas = _require31.assignUidToComponentSchemas,
            assignUidToParameterSchemas = _require31.assignUidToParameterSchemas,
            assignIdToAnonymousSchemas = _require31.assignIdToAnonymousSchemas,
            assignUidToComponentParameterSchemas =
              _require31.assignUidToComponentParameterSchemas;
          var _require32 = require("../iterators"),
            traverseAsyncApiDocument = _require32.traverseAsyncApiDocument;
          /**
           * Implements functions to deal with the AsyncAPI document.
           * @class
           * @alias module:@asyncapi/parser#AsyncAPIDocument
           * @extends Base
           * @mixes MixinTags
           * @mixes MixinExternalDocs
           * @mixes MixinSpecificationExtensions
           * @returns {AsyncAPIDocument}
           */ var AsyncAPIDocument = /*#__PURE__*/ (function (_Base2) {
            "use strict";
            _inherits(AsyncAPIDocument, _Base2);
            var _super10 = _createSuper(AsyncAPIDocument);
            /**
             * @constructor
             */ function AsyncAPIDocument() {
              var _this12;
              _classCallCheck2(this, AsyncAPIDocument);
              for (
                var _len2 = arguments.length, args = new Array(_len2), _key4 = 0;
                _key4 < _len2;
                _key4++
              ) {
                args[_key4] = arguments[_key4];
              }
              _this12 = _super10.call.apply(_super10, [this].concat(args));
              if (_this12.ext(xParserSpecParsed) === true) {
                return _possibleConstructorReturn(_this12);
              }
              assignNameToComponentMessages(_assertThisInitialized(_this12));
              assignNameToAnonymousMessages(_assertThisInitialized(_this12));
              assignUidToComponentSchemas(_assertThisInitialized(_this12));
              assignUidToComponentParameterSchemas(
                _assertThisInitialized(_this12)
              );
              assignUidToParameterSchemas(_assertThisInitialized(_this12));
              assignIdToAnonymousSchemas(_assertThisInitialized(_this12)); // We add `x-parser-spec-parsed=true` extension to determine that the specification is parsed and validated
              // and when the specification is re-passed to the AsyncAPIDocument constructor,
              // there is no need to perform the same operations.
              _this12.json()[String(xParserSpecParsed)] = true;
              return _this12;
            }
            /**
             * @returns {string}
             */ _createClass2(
              AsyncAPIDocument,
              [
                {
                  key: "version",
                  value: function version() {
                    return this._json.asyncapi;
                  }
                  /**
                   * @returns {Info}
                   */
                },
                {
                  key: "info",
                  value: function info() {
                    return new Info(this._json.info);
                  }
                  /**
                   * @returns {string}
                   */
                },
                {
                  key: "id",
                  value: function id() {
                    return this._json.id;
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasServers",
                  value: function hasServers() {
                    return !!this._json.servers;
                  }
                  /**
                   * @returns {Object<string, Server>}
                   */
                },
                {
                  key: "servers",
                  value: function servers() {
                    return createMapOfType(this._json.servers, Server);
                  }
                  /**
                   * @returns {string[]}
                   */
                },
                {
                  key: "serverNames",
                  value: function serverNames() {
                    if (!this._json.servers) return [];
                    return Object.keys(this._json.servers);
                  }
                  /**
                   * @param {string} name - Name of the server.
                   * @returns {Server}
                   */
                },
                {
                  key: "server",
                  value: function server(name) {
                    return getMapValueOfType(this._json.servers, name, Server);
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasDefaultContentType",
                  value: function hasDefaultContentType() {
                    return !!this._json.defaultContentType;
                  }
                  /**
                   * @returns {string|null}
                   */
                },
                {
                  key: "defaultContentType",
                  value: function defaultContentType() {
                    return this._json.defaultContentType || null;
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasChannels",
                  value: function hasChannels() {
                    return !!this._json.channels;
                  }
                  /**
                   * @returns {Object<string, Channel>}
                   */
                },
                {
                  key: "channels",
                  value: function channels() {
                    return createMapOfType(this._json.channels, Channel, this);
                  }
                  /**
                   * @returns {string[]}
                   */
                },
                {
                  key: "channelNames",
                  value: function channelNames() {
                    if (!this._json.channels) return [];
                    return Object.keys(this._json.channels);
                  }
                  /**
                   * @param {string} name - Name of the channel.
                   * @returns {Channel}
                   */
                },
                {
                  key: "channel",
                  value: function channel(name) {
                    return getMapValueOfType(
                      this._json.channels,
                      name,
                      Channel,
                      this
                    );
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasComponents",
                  value: function hasComponents() {
                    return !!this._json.components;
                  }
                  /**
                   * @returns {Components}
                   */
                },
                {
                  key: "components",
                  value: function components() {
                    if (!this._json.components) return null;
                    return new Components(this._json.components);
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasMessages",
                  value: function hasMessages() {
                    return !!this.allMessages().size;
                  }
                  /**
                   * @returns {Map<string, Message>}
                   */
                },
                {
                  key: "allMessages",
                  value: function allMessages() {
                    var _this13 = this;
                    var messages = new Map();
                    if (this.hasChannels()) {
                      this.channelNames().forEach(function (channelName) {
                        var channel = _this13.channel(channelName);
                        if (channel.hasPublish()) {
                          channel
                            .publish()
                            .messages()
                            .forEach(function (m) {
                              messages.set(m.uid(), m);
                            });
                        }
                        if (channel.hasSubscribe()) {
                          channel
                            .subscribe()
                            .messages()
                            .forEach(function (m) {
                              messages.set(m.uid(), m);
                            });
                        }
                      });
                    }
                    if (this.hasComponents()) {
                      Object.values(this.components().messages()).forEach(
                        function (m) {
                          messages.set(m.uid(), m);
                        }
                      );
                    }
                    return messages;
                  }
                  /**
                   * @returns {Map<string, Schema>}
                   */
                },
                {
                  key: "allSchemas",
                  value: function allSchemas() {
                    var schemas = new Map();
                    var allSchemasCallback = function allSchemasCallback(schema) {
                      if (schema.uid()) {
                        schemas.set(schema.uid(), schema);
                      }
                    };
                    traverseAsyncApiDocument(this, allSchemasCallback);
                    return schemas;
                  }
                  /**
                   * @returns {boolean}
                   */
                },
                {
                  key: "hasCircular",
                  value: function hasCircular() {
                    return !!this._json[String(xParserCircle)];
                  }
                  /**
                   * Callback used when crawling a schema.
                   * @callback module:@asyncapi/parser.TraverseSchemas
                   * @param {Schema} schema which is being crawled
                   * @param {String} propName if the schema is from a property get the name of such
                   * @param {SchemaIteratorCallbackType} callbackType is the schema a new one or is the crawler finishing one.
                   * @returns {boolean} should the crawler continue crawling the schema?
                   */
                  /**
                   * Traverse schemas in the document and select which types of schemas to include.
                   * By default all schemas are iterated
                   * @param {TraverseSchemas} callback
                   * @param {SchemaTypesToIterate[]} schemaTypesToIterate
                   */
                },
                {
                  key: "traverseSchemas",
                  value: function traverseSchemas(
                    callback,
                    schemaTypesToIterate
                  ) {
                    traverseAsyncApiDocument(
                      this,
                      callback,
                      schemaTypesToIterate
                    );
                  }
                  /**
                   * Converts a valid AsyncAPI document to a JavaScript Object Notation (JSON) string.
                   * A stringified AsyncAPI document using this function should be parsed via the AsyncAPIDocument.parse() function - the JSON.parse() function is not compatible.
                   *
                   * @param {AsyncAPIDocument} doc A valid AsyncAPIDocument instance.
                   * @param {(number | string)=} space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
                   * @returns {string}
                   */
                }
              ],
              [
                {
                  key: "stringify",
                  value: function stringify(doc, space) {
                    var rawDoc = doc.json();
                    var copiedDoc = _objectSpread2({}, rawDoc);
                    copiedDoc[String(xParserSpecStringified)] = true;
                    return JSON.stringify(copiedDoc, refReplacer(), space);
                  }
                  /**
                   * Converts a valid stringified AsyncAPIDocument instance into an AsyncAPIDocument instance.
                   *
                   * @param {string} doc A valid stringified AsyncAPIDocument instance.
                   * @returns {AsyncAPIDocument}
                   */
                },
                {
                  key: "parse",
                  value: function parse(doc) {
                    var parsedJSON = doc;
                    if (typeof doc === "string") {
                      parsedJSON = JSON.parse(doc);
                    } else if (_typeof2(doc) === "object") {
                      // shall copy
                      parsedJSON = _objectSpread2({}, parsedJSON);
                    } // the `doc` must be an AsyncAPI parsed document
                    if (
                      _typeof2(parsedJSON) !== "object" ||
                      !parsedJSON[String(xParserSpecParsed)]
                    ) {
                      throw new Error("Cannot parse invalid AsyncAPI document");
                    } // if the `doc` is not stringified via the `stringify` static method then immediately return a model.
                    if (!parsedJSON[String(xParserSpecStringified)]) {
                      return new AsyncAPIDocument(parsedJSON);
                    } // remove `x-parser-spec-stringified` extension
                    delete parsedJSON[String(xParserSpecStringified)];
                    var objToPath = new Map();
                    var pathToObj = new Map();
                    traverseStringifiedDoc(
                      parsedJSON,
                      undefined,
                      parsedJSON,
                      objToPath,
                      pathToObj
                    );
                    return new AsyncAPIDocument(parsedJSON);
                  }
                }
              ]
            );
            return AsyncAPIDocument;
          })(Base);
          /**
           * Replacer function (that transforms the result) for AsyncAPI.stringify() function.
           * Handles circular references by replacing it by JSONPath notation.
           *
           * @private
           */ function refReplacer() {
            var modelPaths = new Map();
            var paths = new Map();
            var init = null;
            return function (field, value) {
              // `this` points to parent object of given value - some object or array
              var pathPart =
                modelPaths.get(this) +
                (Array.isArray(this)
                  ? "[".concat(field, "]")
                  : ".".concat(field)); // check if `objOrPath` has "reference"
              var isComplex = value === Object(value);
              if (isComplex) {
                modelPaths.set(value, pathPart);
              }
              var savedPath = paths.get(value) || "";
              if (!savedPath && isComplex) {
                var valuePath = pathPart.replace(/undefined\.\.?/, "");
                paths.set(value, valuePath);
              }
              var prefixPath = savedPath[0] === "[" ? "$" : "$.";
              var val = savedPath
                ? "$ref:".concat(prefixPath).concat(savedPath)
                : value;
              if (init === null) {
                init = value;
              } else if (val === init) {
                val = "$ref:$";
              }
              return val;
            };
          }
          /**
           * Traverses stringified AsyncAPIDocument and replaces all JSON Pointer instance with real object reference.
           *
           * @private
           * @param {Object} parent object
           * @param {string} field of parent object
           * @param {Object} root reference to the original object
           * @param {Map} objToPath
           * @param {Map} pathToObj
           */ function traverseStringifiedDoc(
            parent,
            field,
            root,
            objToPath,
            pathToObj
          ) {
            var objOrPath = parent;
            var path = "$ref:$";
            if (field !== undefined) {
              // here can be string with `$ref` prefix or normal value
              objOrPath = parent[String(field)];
              var concatenatedPath = field ? ".".concat(field) : "";
              path =
                objToPath.get(parent) +
                (Array.isArray(parent)
                  ? "[".concat(field, "]")
                  : concatenatedPath);
            }
            objToPath.set(objOrPath, path);
            pathToObj.set(path, objOrPath);
            var ref = pathToObj.get(objOrPath);
            if (ref) {
              parent[String(field)] = ref;
            }
            if (objOrPath === "$ref:$" || ref === "$ref:$") {
              // NOSONAR
              parent[String(field)] = root;
            } // traverse all keys, only if object is array/object
            if (objOrPath === Object(objOrPath)) {
              for (var f in objOrPath) {
                traverseStringifiedDoc(objOrPath, f, root, objToPath, pathToObj);
              }
            }
          }
          module.exports = mix(
            AsyncAPIDocument,
            MixinTags,
            MixinExternalDocs,
            MixinSpecificationExtensions
          );
        },
        {
          "../anonymousNaming": 45,
          "../constants": 48,
          "../iterators": 52,
          "../mixins/external-docs": 56,
          "../mixins/specification-extensions": 57,
          "../mixins/tags": 58,
          "./base": 60,
          "./channel": 62,
          "./components": 63,
          "./info": 67,
          "./server": 82,
          "./utils": 85
        }
      ],
      60: [
        function (require, module, exports) {
          var ParserError = require("../errors/parser-error");
          /**
           * Implements common functionality for all the models.
           * @class
           * @alias module:@asyncapi/parser#Base
           * @returns {Base}
           */ var Base = /*#__PURE__*/ (function () {
            "use strict";
            function Base(json) {
              _classCallCheck2(this, Base);
              if (json === undefined || json === null)
                throw new ParserError(
                  "Invalid JSON to instantiate the ".concat(
                    this.constructor.name,
                    " object."
                  )
                );
              this._json = json;
            }
            /**
             * @param {string} [key] A key to retrieve from the JSON object.
             * @returns {any}
             */ _createClass2(Base, [
              {
                key: "json",
                value: function json(key) {
                  if (key === undefined) return this._json;
                  if (!this._json) return;
                  return this._json[String(key)];
                }
              }
            ]);
            return Base;
          })();
          module.exports = Base;
        },
        { "../errors/parser-error": 50 }
      ],
      61: [
        function (require, module, exports) {
          var _require33 = require("./utils"),
            mix = _require33.mix;
          var Base = require("./base");
          var Schema = require("./schema");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a ChannelParameter object.
           * @class
           * @alias module:@asyncapi/parser#ChannelParameter
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {ChannelParameter}
           */ var ChannelParameter = /*#__PURE__*/ (function (_Base3) {
            "use strict";
            _inherits(ChannelParameter, _Base3);
            var _super11 = _createSuper(ChannelParameter);
            function ChannelParameter() {
              _classCallCheck2(this, ChannelParameter);
              return _super11.apply(this, arguments);
            }
            _createClass2(ChannelParameter, [
              {
                key: "location",
                value: /**
                 * @returns {string}
                 */ function location() {
                  return this._json.location;
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "schema",
                value: function schema() {
                  if (!this._json.schema) return null;
                  return new Schema(this._json.schema);
                }
              }
            ]);
            return ChannelParameter;
          })(Base);
          module.exports = mix(
            ChannelParameter,
            MixinDescription,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./schema": 78,
          "./utils": 85
        }
      ],
      62: [
        function (require, module, exports) {
          var _require34 = require("./utils"),
            createMapOfType = _require34.createMapOfType,
            getMapValueOfType = _require34.getMapValueOfType,
            mix = _require34.mix;
          var Base = require("./base");
          var ChannelParameter = require("./channel-parameter");
          var PublishOperation = require("./publish-operation");
          var SubscribeOperation = require("./subscribe-operation");
          var MixinDescription = require("../mixins/description");
          var MixinBindings = require("../mixins/bindings");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a Channel object.
           * @class
           * @alias module:@asyncapi/parser#Channel
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinBindings
           * @mixes MixinSpecificationExtensions
           * @returns {Channel}
           */ var Channel = /*#__PURE__*/ (function (_Base4) {
            "use strict";
            _inherits(Channel, _Base4);
            var _super12 = _createSuper(Channel);
            function Channel() {
              _classCallCheck2(this, Channel);
              return _super12.apply(this, arguments);
            }
            _createClass2(Channel, [
              {
                key: "parameters",
                value: /**
                 * @returns {Object<string, ChannelParameter>}
                 */ function parameters() {
                  return createMapOfType(this._json.parameters, ChannelParameter);
                }
                /**
                 * @param {string} name - Name of the parameter.
                 * @returns {ChannelParameter}
                 */
              },
              {
                key: "parameter",
                value: function parameter(name) {
                  return getMapValueOfType(
                    this._json.parameters,
                    name,
                    ChannelParameter
                  );
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasParameters",
                value: function hasParameters() {
                  return !!this._json.parameters;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasServers",
                value: function hasServers() {
                  return !!this._json.servers;
                }
                /**
                 * @returns {String[]}
                 */
              },
              {
                key: "servers",
                value: function servers() {
                  if (!this._json.servers) return [];
                  return this._json.servers;
                }
                /**
                 * @param {number} index - Index of the server.
                 * @returns {String}
                 */
              },
              {
                key: "server",
                value: function server(index) {
                  if (!this._json.servers) return null;
                  if (typeof index !== "number") return null;
                  if (index > this._json.servers.length - 1) return null;
                  return this._json.servers[+index];
                }
                /**
                 * @returns {PublishOperation}
                 */
              },
              {
                key: "publish",
                value: function publish() {
                  if (!this._json.publish) return null;
                  return new PublishOperation(this._json.publish);
                }
                /**
                 * @returns {SubscribeOperation}
                 */
              },
              {
                key: "subscribe",
                value: function subscribe() {
                  if (!this._json.subscribe) return null;
                  return new SubscribeOperation(this._json.subscribe);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasPublish",
                value: function hasPublish() {
                  return !!this._json.publish;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasSubscribe",
                value: function hasSubscribe() {
                  return !!this._json.subscribe;
                }
              }
            ]);
            return Channel;
          })(Base);
          module.exports = mix(
            Channel,
            MixinDescription,
            MixinBindings,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/bindings": 54,
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./channel-parameter": 61,
          "./publish-operation": 77,
          "./subscribe-operation": 83,
          "./utils": 85
        }
      ],
      63: [
        function (require, module, exports) {
          var _require35 = require("./utils"),
            createMapOfType = _require35.createMapOfType,
            getMapValueOfType = _require35.getMapValueOfType,
            mix = _require35.mix;
          var Base = require("./base");
          var Channel = require("./channel");
          var Message = require("./message");
          var Schema = require("./schema");
          var SecurityScheme = require("./security-scheme");
          var Server = require("./server");
          var ChannelParameter = require("./channel-parameter");
          var CorrelationId = require("./correlation-id");
          var OperationTrait = require("./operation-trait");
          var MessageTrait = require("./message-trait");
          var ServerVariable = require("./server-variable");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a Components object.
           * @class
           * @alias module:@asyncapi/parser#Components
           * @extends Base
           * @mixes MixinSpecificationExtensions
           * @returns {Components}
           */ var Components = /*#__PURE__*/ (function (_Base5) {
            "use strict";
            _inherits(Components, _Base5);
            var _super13 = _createSuper(Components);
            function Components() {
              _classCallCheck2(this, Components);
              return _super13.apply(this, arguments);
            }
            _createClass2(Components, [
              {
                key: "channels",
                value: /**
                 * @returns {Object<string, Channel>}
                 */ function channels() {
                  return createMapOfType(this._json.channels, Channel);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasChannels",
                value: function hasChannels() {
                  return !!this._json.channels;
                }
                /**
                 * @param {string} name - Name of the channel.
                 * @returns {Channel}
                 */
              },
              {
                key: "channel",
                value: function channel(name) {
                  return getMapValueOfType(this._json.channels, name, Channel);
                }
                /**
                 * @returns {Object<string, Message>}
                 */
              },
              {
                key: "messages",
                value: function messages() {
                  return createMapOfType(this._json.messages, Message);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasMessages",
                value: function hasMessages() {
                  return !!this._json.messages;
                }
                /**
                 * @param {string} name - Name of the message.
                 * @returns {Message}
                 */
              },
              {
                key: "message",
                value: function message(name) {
                  return getMapValueOfType(this._json.messages, name, Message);
                }
                /**
                 * @returns {Object<string, Schema>}
                 */
              },
              {
                key: "schemas",
                value: function schemas() {
                  return createMapOfType(this._json.schemas, Schema);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasSchemas",
                value: function hasSchemas() {
                  return !!this._json.schemas;
                }
                /**
                 * @param {string} name - Name of the schema.
                 * @returns {Schema}
                 */
              },
              {
                key: "schema",
                value: function schema(name) {
                  return getMapValueOfType(this._json.schemas, name, Schema);
                }
                /**
                 * @returns {Object<string, SecurityScheme>}
                 */
              },
              {
                key: "securitySchemes",
                value: function securitySchemes() {
                  return createMapOfType(
                    this._json.securitySchemes,
                    SecurityScheme
                  );
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasSecuritySchemes",
                value: function hasSecuritySchemes() {
                  return !!this._json.securitySchemes;
                }
                /**
                 * @param {string} name - Name of the security schema.
                 * @returns {SecurityScheme}
                 */
              },
              {
                key: "securityScheme",
                value: function securityScheme(name) {
                  return getMapValueOfType(
                    this._json.securitySchemes,
                    name,
                    SecurityScheme
                  );
                }
                /**
                 * @returns {Object<string, Server>}
                 */
              },
              {
                key: "servers",
                value: function servers() {
                  return createMapOfType(this._json.servers, Server);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasServers",
                value: function hasServers() {
                  return !!this._json.servers;
                }
                /**
                 * @param {string} name - Name of the server.
                 * @returns {Server}
                 */
              },
              {
                key: "server",
                value: function server(name) {
                  return getMapValueOfType(this._json.servers, name, Server);
                }
                /**
                 * @returns {Object<string, ChannelParameter>}
                 */
              },
              {
                key: "parameters",
                value: function parameters() {
                  return createMapOfType(this._json.parameters, ChannelParameter);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasParameters",
                value: function hasParameters() {
                  return !!this._json.parameters;
                }
                /**
                 * @param {string} name - Name of the channel parameter.
                 * @returns {ChannelParameter}
                 */
              },
              {
                key: "parameter",
                value: function parameter(name) {
                  return getMapValueOfType(
                    this._json.parameters,
                    name,
                    ChannelParameter
                  );
                }
                /**
                 * @returns {Object<string, CorrelationId>}
                 */
              },
              {
                key: "correlationIds",
                value: function correlationIds() {
                  return createMapOfType(
                    this._json.correlationIds,
                    CorrelationId
                  );
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasCorrelationIds",
                value: function hasCorrelationIds() {
                  return !!this._json.correlationIds;
                }
                /**
                 * @param {string} name - Name of the correlationId.
                 * @returns {CorrelationId}
                 */
              },
              {
                key: "correlationId",
                value: function correlationId(name) {
                  return getMapValueOfType(
                    this._json.correlationIds,
                    name,
                    CorrelationId
                  );
                }
                /**
                 * @returns {Object<string, OperationTrait>}
                 */
              },
              {
                key: "operationTraits",
                value: function operationTraits() {
                  return createMapOfType(
                    this._json.operationTraits,
                    OperationTrait
                  );
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasOperationTraits",
                value: function hasOperationTraits() {
                  return !!this._json.operationTraits;
                }
                /**
                 * @param {string} name - Name of the operation trait.
                 * @returns {OperationTrait}
                 */
              },
              {
                key: "operationTrait",
                value: function operationTrait(name) {
                  return getMapValueOfType(
                    this._json.operationTraits,
                    name,
                    OperationTrait
                  );
                }
                /**
                 * @returns {Object<string, MessageTrait>}
                 */
              },
              {
                key: "messageTraits",
                value: function messageTraits() {
                  return createMapOfType(this._json.messageTraits, MessageTrait);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasMessageTraits",
                value: function hasMessageTraits() {
                  return !!this._json.messageTraits;
                }
                /**
                 * @param {string} name - Name of the message trait.
                 * @returns {MessageTrait}
                 */
              },
              {
                key: "messageTrait",
                value: function messageTrait(name) {
                  return getMapValueOfType(
                    this._json.messageTraits,
                    name,
                    MessageTrait
                  );
                }
                /**
                 *
                 * @returns {Object<string, ServerVariable>}
                 */
              },
              {
                key: "serverVariables",
                value: function serverVariables() {
                  return createMapOfType(
                    this._json.serverVariables,
                    ServerVariable
                  );
                }
                /**
                 *
                 * @returns {boolean}
                 */
              },
              {
                key: "hasServerVariables",
                value: function hasServerVariables() {
                  return !!this._json.serverVariables;
                }
                /**
                 *
                 * @param {string} name - Name of the server variable.
                 * @returns {ServerVariable}
                 */
              },
              {
                key: "serverVariable",
                value: function serverVariable(name) {
                  return getMapValueOfType(
                    this._json.serverVariables,
                    name,
                    ServerVariable
                  );
                }
              }
            ]);
            return Components;
          })(Base);
          module.exports = mix(Components, MixinSpecificationExtensions);
        },
        {
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./channel": 62,
          "./channel-parameter": 61,
          "./correlation-id": 65,
          "./message": 71,
          "./message-trait": 69,
          "./operation-trait": 74,
          "./schema": 78,
          "./security-scheme": 79,
          "./server": 82,
          "./server-variable": 81,
          "./utils": 85
        }
      ],
      64: [
        function (require, module, exports) {
          var _require36 = require("./utils"),
            mix = _require36.mix;
          var Base = require("./base");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with the Contact object.
           * @class
           * @alias module:@asyncapi/parser#Contact
           * @extends Base
           * @mixes MixinSpecificationExtensions
           * @returns {Contact}
           */ var Contact = /*#__PURE__*/ (function (_Base6) {
            "use strict";
            _inherits(Contact, _Base6);
            var _super14 = _createSuper(Contact);
            function Contact() {
              _classCallCheck2(this, Contact);
              return _super14.apply(this, arguments);
            }
            _createClass2(Contact, [
              {
                key: "name",
                value: /**
                 * @returns {string}
                 */ function name() {
                  return this._json.name;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "url",
                value: function url() {
                  return this._json.url;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "email",
                value: function email() {
                  return this._json.email;
                }
              }
            ]);
            return Contact;
          })(Base);
          module.exports = mix(Contact, MixinSpecificationExtensions);
        },
        { "../mixins/specification-extensions": 57, "./base": 60, "./utils": 85 }
      ],
      65: [
        function (require, module, exports) {
          var _require37 = require("./utils"),
            mix = _require37.mix;
          var Base = require("./base");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a CorrelationId object.
           * @class
           * @alias module:@asyncapi/parser#CorrelationId
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {CorrelationId}
           */ var CorrelationId = /*#__PURE__*/ (function (_Base7) {
            "use strict";
            _inherits(CorrelationId, _Base7);
            var _super15 = _createSuper(CorrelationId);
            function CorrelationId() {
              _classCallCheck2(this, CorrelationId);
              return _super15.apply(this, arguments);
            }
            _createClass2(CorrelationId, [
              {
                key: "location",
                value: /**
                 * @returns {string}
                 */ function location() {
                  return this._json.location;
                }
              }
            ]);
            return CorrelationId;
          })(Base);
          module.exports = mix(
            CorrelationId,
            MixinSpecificationExtensions,
            MixinDescription
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./utils": 85
        }
      ],
      66: [
        function (require, module, exports) {
          var _require38 = require("./utils"),
            mix = _require38.mix;
          var Base = require("./base");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with an ExternalDocs object.
           * @class
           * @alias module:@asyncapi/parser#ExternalDocs
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {ExternalDocs}
           */ var ExternalDocs = /*#__PURE__*/ (function (_Base8) {
            "use strict";
            _inherits(ExternalDocs, _Base8);
            var _super16 = _createSuper(ExternalDocs);
            function ExternalDocs() {
              _classCallCheck2(this, ExternalDocs);
              return _super16.apply(this, arguments);
            }
            _createClass2(ExternalDocs, [
              {
                key: "url",
                value: /**
                 * @returns {string}
                 */ function url() {
                  return this._json.url;
                }
              }
            ]);
            return ExternalDocs;
          })(Base);
          module.exports = mix(
            ExternalDocs,
            MixinDescription,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./utils": 85
        }
      ],
      67: [
        function (require, module, exports) {
          var _require39 = require("./utils"),
            mix = _require39.mix;
          var Base = require("./base");
          var License = require("./license");
          var Contact = require("./contact");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with the Info object.
           * @class
           * @alias module:@asyncapi/parser#Info
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {Info}
           */ var Info = /*#__PURE__*/ (function (_Base9) {
            "use strict";
            _inherits(Info, _Base9);
            var _super17 = _createSuper(Info);
            function Info() {
              _classCallCheck2(this, Info);
              return _super17.apply(this, arguments);
            }
            _createClass2(Info, [
              {
                key: "title",
                value: /**
                 * @returns {string}
                 */ function title() {
                  return this._json.title;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "version",
                value: function version() {
                  return this._json.version;
                }
                /**
                 * @returns {(string | undefined)}
                 */
              },
              {
                key: "termsOfService",
                value: function termsOfService() {
                  return this._json.termsOfService;
                }
                /**
                 * @returns {License}
                 */
              },
              {
                key: "license",
                value: function license() {
                  if (!this._json.license) return null;
                  return new License(this._json.license);
                }
                /**
                 * @returns {Contact}
                 */
              },
              {
                key: "contact",
                value: function contact() {
                  if (!this._json.contact) return null;
                  return new Contact(this._json.contact);
                }
              }
            ]);
            return Info;
          })(Base);
          module.exports = mix(
            Info,
            MixinDescription,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./contact": 64,
          "./license": 68,
          "./utils": 85
        }
      ],
      68: [
        function (require, module, exports) {
          var _require40 = require("./utils"),
            mix = _require40.mix;
          var Base = require("./base");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with the License object.
           * @class
           * @alias module:@asyncapi/parser#License
           * @extends Base
           * @mixes MixinSpecificationExtensions
           * @returns {License}
           */ var License = /*#__PURE__*/ (function (_Base10) {
            "use strict";
            _inherits(License, _Base10);
            var _super18 = _createSuper(License);
            function License() {
              _classCallCheck2(this, License);
              return _super18.apply(this, arguments);
            }
            _createClass2(License, [
              {
                key: "name",
                value: /**
                 * @returns {string}
                 */ function name() {
                  return this._json.name;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "url",
                value: function url() {
                  return this._json.url;
                }
              }
            ]);
            return License;
          })(Base);
          module.exports = mix(License, MixinSpecificationExtensions);
        },
        { "../mixins/specification-extensions": 57, "./base": 60, "./utils": 85 }
      ],
      69: [
        function (require, module, exports) {
          var MessageTraitable = require("./message-traitable");
          /**
           * Implements functions to deal with a MessageTrait object.
           * @class
           * @alias module:@asyncapi/parser#MessageTrait
           * @extends MessageTraitable
           * @returns {MessageTrait}
           */ var MessageTrait = /*#__PURE__*/ (function (_MessageTraitable) {
            "use strict";
            _inherits(MessageTrait, _MessageTraitable);
            var _super19 = _createSuper(MessageTrait);
            function MessageTrait() {
              _classCallCheck2(this, MessageTrait);
              return _super19.apply(this, arguments);
            }
            return _createClass2(MessageTrait);
          })(MessageTraitable);
          module.exports = MessageTrait;
        },
        { "./message-traitable": 70 }
      ],
      70: [
        function (require, module, exports) {
          var _require41 = require("./utils"),
            getMapValueOfType = _require41.getMapValueOfType,
            mix = _require41.mix;
          var Base = require("./base");
          var Schema = require("./schema");
          var CorrelationId = require("./correlation-id");
          var MixinDescription = require("../mixins/description");
          var MixinExternalDocs = require("../mixins/external-docs");
          var MixinTags = require("../mixins/tags");
          var MixinBindings = require("../mixins/bindings");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a the common properties that Message and MessageTrait objects have.
           * @class
           * @alias module:@asyncapi/parser#MessageTraitable
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinTags
           * @mixes MixinExternalDocs
           * @mixes MixinBindings
           * @mixes MixinSpecificationExtensions
           * @returns {MessageTraitable}
           */ var MessageTraitable = /*#__PURE__*/ (function (_Base11) {
            "use strict";
            _inherits(MessageTraitable, _Base11);
            var _super20 = _createSuper(MessageTraitable);
            function MessageTraitable() {
              _classCallCheck2(this, MessageTraitable);
              return _super20.apply(this, arguments);
            }
            _createClass2(MessageTraitable, [
              {
                key: "headers",
                value: /**
                 * @returns {Schema}
                 */ function headers() {
                  if (!this._json.headers) return null;
                  return new Schema(this._json.headers);
                }
                /**
                 * @param {string} name - Name of the header.
                 * @returns {Schema}
                 */
              },
              {
                key: "header",
                value: function header(name) {
                  if (!this._json.headers) return null;
                  return getMapValueOfType(
                    this._json.headers.properties,
                    name,
                    Schema
                  );
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "id",
                value: function id() {
                  return this._json.messageId;
                }
                /**
                 * @returns {CorrelationId}
                 */
              },
              {
                key: "correlationId",
                value: function correlationId() {
                  if (!this._json.correlationId) return null;
                  return new CorrelationId(this._json.correlationId);
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "schemaFormat",
                value: function schemaFormat() {
                  return this._json.schemaFormat;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "contentType",
                value: function contentType() {
                  return this._json.contentType;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "name",
                value: function name() {
                  return this._json.name;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "title",
                value: function title() {
                  return this._json.title;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "summary",
                value: function summary() {
                  return this._json.summary;
                }
                /**
                 * @returns {any[]}
                 */
              },
              {
                key: "examples",
                value: function examples() {
                  return this._json.examples;
                }
              }
            ]);
            return MessageTraitable;
          })(Base);
          module.exports = mix(
            MessageTraitable,
            MixinDescription,
            MixinTags,
            MixinExternalDocs,
            MixinBindings,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/bindings": 54,
          "../mixins/description": 55,
          "../mixins/external-docs": 56,
          "../mixins/specification-extensions": 57,
          "../mixins/tags": 58,
          "./base": 60,
          "./correlation-id": 65,
          "./schema": 78,
          "./utils": 85
        }
      ],
      71: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              var MessageTrait = require("./message-trait");
              var MessageTraitable = require("./message-traitable");
              var Schema = require("./schema");
              /**
               * Implements functions to deal with a Message object.
               * @class
               * @alias module:@asyncapi/parser#Message
               * @extends MessageTraitable
               * @returns {Message}
               */ var Message = /*#__PURE__*/ (function (_MessageTraitable2) {
                "use strict";
                _inherits(Message, _MessageTraitable2);
                var _super21 = _createSuper(Message);
                function Message() {
                  _classCallCheck2(this, Message);
                  return _super21.apply(this, arguments);
                }
                _createClass2(Message, [
                  {
                    key: "uid",
                    value: /**
                     * @returns {string}
                     */ function uid() {
                      return (
                        this.id() ||
                        this.name() ||
                        this.ext("x-parser-message-name") ||
                        Buffer.from(JSON.stringify(this._json)).toString("base64")
                      );
                    }
                    /**
                     * @returns {Schema}
                     */
                  },
                  {
                    key: "payload",
                    value: function payload() {
                      if (!this._json.payload) return null;
                      return new Schema(this._json.payload);
                    }
                    /**
                     * @returns {MessageTrait[]}
                     */
                  },
                  {
                    key: "traits",
                    value: function traits() {
                      var traits =
                        this._json["x-parser-original-traits"] ||
                        this._json.traits;
                      if (!traits) return [];
                      return traits.map(function (t) {
                        return new MessageTrait(t);
                      });
                    }
                    /**
                     * @returns {boolean}
                     */
                  },
                  {
                    key: "hasTraits",
                    value: function hasTraits() {
                      return (
                        !!this._json["x-parser-original-traits"] ||
                        !!this._json.traits
                      );
                    }
                    /**
                     * @returns {any}
                     */
                  },
                  {
                    key: "originalPayload",
                    value: function originalPayload() {
                      return (
                        this._json["x-parser-original-payload"] || this.payload()
                      );
                    }
                    /**
                     * @returns {string}
                     */
                  },
                  {
                    key: "originalSchemaFormat",
                    value: function originalSchemaFormat() {
                      return (
                        this._json["x-parser-original-schema-format"] ||
                        this.schemaFormat()
                      );
                    }
                  }
                ]);
                return Message;
              })(MessageTraitable);
              module.exports = Message;
            }.call(this));
          }.call(this, require("buffer").Buffer));
        },
        {
          "./message-trait": 69,
          "./message-traitable": 70,
          "./schema": 78,
          buffer: 223
        }
      ],
      72: [
        function (require, module, exports) {
          var _require42 = require("./utils"),
            mix = _require42.mix;
          var Base = require("./base");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a OAuthFlow object.
           * @class
           * @alias module:@asyncapi/parser#OAuthFlow
           * @extends Base
           * @mixes MixinSpecificationExtensions
           * @returns {OAuthFlow}
           */ var OAuthFlow = /*#__PURE__*/ (function (_Base12) {
            "use strict";
            _inherits(OAuthFlow, _Base12);
            var _super22 = _createSuper(OAuthFlow);
            function OAuthFlow() {
              _classCallCheck2(this, OAuthFlow);
              return _super22.apply(this, arguments);
            }
            _createClass2(OAuthFlow, [
              {
                key: "authorizationUrl",
                value: /**
                 * @returns {string}
                 */ function authorizationUrl() {
                  return this._json.authorizationUrl;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "tokenUrl",
                value: function tokenUrl() {
                  return this._json.tokenUrl;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "refreshUrl",
                value: function refreshUrl() {
                  return this._json.refreshUrl;
                }
                /**
                 * @returns {Object<string, string>}
                 */
              },
              {
                key: "scopes",
                value: function scopes() {
                  return this._json.scopes;
                }
              }
            ]);
            return OAuthFlow;
          })(Base);
          module.exports = mix(OAuthFlow, MixinSpecificationExtensions);
        },
        { "../mixins/specification-extensions": 57, "./base": 60, "./utils": 85 }
      ],
      73: [
        function (require, module, exports) {
          var Base = require("./base");
          /**
           * Implements functions to deal with a OperationSecurityRequirement object.
           * @class
           * @alias module:@asyncapi/parser#OperationSecurityRequirement
           * @extends Base
           * @returns {OperationSecurityRequirement}
           */ var OperationSecurityRequirement = /*#__PURE__*/ (function (
            _Base13
          ) {
            "use strict";
            _inherits(OperationSecurityRequirement, _Base13);
            var _super23 = _createSuper(OperationSecurityRequirement);
            function OperationSecurityRequirement() {
              _classCallCheck2(this, OperationSecurityRequirement);
              return _super23.apply(this, arguments);
            }
            return _createClass2(OperationSecurityRequirement);
          })(Base);
          module.exports = OperationSecurityRequirement;
        },
        { "./base": 60 }
      ],
      74: [
        function (require, module, exports) {
          var OperationTraitable = require("./operation-traitable");
          /**
           * Implements functions to deal with a OperationTrait object.
           * @class
           * @alias module:@asyncapi/parser#OperationTrait
           * @extends OperationTraitable
           * @returns {OperationTrait}
           */ var OperationTrait = /*#__PURE__*/ (function (_OperationTraitable) {
            "use strict";
            _inherits(OperationTrait, _OperationTraitable);
            var _super24 = _createSuper(OperationTrait);
            function OperationTrait() {
              _classCallCheck2(this, OperationTrait);
              return _super24.apply(this, arguments);
            }
            return _createClass2(OperationTrait);
          })(OperationTraitable);
          module.exports = OperationTrait;
        },
        { "./operation-traitable": 75 }
      ],
      75: [
        function (require, module, exports) {
          var _require43 = require("./utils"),
            mix = _require43.mix;
          var Base = require("./base");
          var MixinDescription = require("../mixins/description");
          var MixinTags = require("../mixins/tags");
          var MixinExternalDocs = require("../mixins/external-docs");
          var MixinBindings = require("../mixins/bindings");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with the common properties Operation and OperationTrait object have.
           * @class
           * @alias module:@asyncapi/parser#OperationTraitable
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinTags
           * @mixes MixinExternalDocs
           * @mixes MixinBindings
           * @mixes MixinSpecificationExtensions
           * @returns {OperationTraitable}
           */ var OperationTraitable = /*#__PURE__*/ (function (_Base14) {
            "use strict";
            _inherits(OperationTraitable, _Base14);
            var _super25 = _createSuper(OperationTraitable);
            function OperationTraitable() {
              _classCallCheck2(this, OperationTraitable);
              return _super25.apply(this, arguments);
            }
            _createClass2(OperationTraitable, [
              {
                key: "id",
                value: /**
                 * @returns {string}
                 */ function id() {
                  return this._json.operationId;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "summary",
                value: function summary() {
                  return this._json.summary;
                }
              }
            ]);
            return OperationTraitable;
          })(Base);
          module.exports = mix(
            OperationTraitable,
            MixinDescription,
            MixinTags,
            MixinExternalDocs,
            MixinBindings,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/bindings": 54,
          "../mixins/description": 55,
          "../mixins/external-docs": 56,
          "../mixins/specification-extensions": 57,
          "../mixins/tags": 58,
          "./base": 60,
          "./utils": 85
        }
      ],
      76: [
        function (require, module, exports) {
          var OperationTraitable = require("./operation-traitable");
          var Message = require("./message");
          var OperationTrait = require("./operation-trait");
          var OperationSecurityRequirement = require("./operation-security-requirement");
          /**
           * Implements functions to deal with an Operation object.
           * @class
           * @alias module:@asyncapi/parser#Operation
           * @extends OperationTraitable
           * @returns {Operation}
           */ var Operation = /*#__PURE__*/ (function (_OperationTraitable2) {
            "use strict";
            _inherits(Operation, _OperationTraitable2);
            var _super26 = _createSuper(Operation);
            function Operation() {
              _classCallCheck2(this, Operation);
              return _super26.apply(this, arguments);
            }
            _createClass2(Operation, [
              {
                key: "hasMultipleMessages",
                value: /**
                 * @returns {boolean}
                 */ function hasMultipleMessages() {
                  if (
                    this._json.message &&
                    this._json.message.oneOf &&
                    this._json.message.oneOf.length > 1
                  )
                    return true;
                  if (!this._json.message) return false;
                  return false;
                }
                /**
                 * @returns {OperationTrait[]}
                 */
              },
              {
                key: "traits",
                value: function traits() {
                  var traits =
                    this._json["x-parser-original-traits"] || this._json.traits;
                  if (!traits) return [];
                  return traits.map(function (t) {
                    return new OperationTrait(t);
                  });
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasTraits",
                value: function hasTraits() {
                  return (
                    !!this._json["x-parser-original-traits"] ||
                    !!this._json.traits
                  );
                }
                /**
                 * @returns {Message[]}
                 */
              },
              {
                key: "messages",
                value: function messages() {
                  if (!this._json.message) return [];
                  if (this._json.message.oneOf)
                    return this._json.message.oneOf.map(function (m) {
                      return new Message(m);
                    });
                  return [new Message(this._json.message)];
                }
                /**
                 * @returns {Message}
                 */
              },
              {
                key: "message",
                value: function message(index) {
                  if (!this._json.message) return null;
                  if (
                    this._json.message.oneOf &&
                    this._json.message.oneOf.length === 1
                  )
                    return new Message(this._json.message.oneOf[0]);
                  if (!this._json.message.oneOf)
                    return new Message(this._json.message);
                  if (typeof index !== "number") return null;
                  if (index > this._json.message.oneOf.length - 1) return null;
                  return new Message(this._json.message.oneOf[+index]);
                }
                /**
                 * @returns {OperationSecurityRequirement[]}
                 */
              },
              {
                key: "security",
                value: function security() {
                  if (!this._json.security) return null;
                  return this._json.security.map(function (sec) {
                    return new OperationSecurityRequirement(sec);
                  });
                }
              }
            ]);
            return Operation;
          })(OperationTraitable);
          module.exports = Operation;
        },
        {
          "./message": 71,
          "./operation-security-requirement": 73,
          "./operation-trait": 74,
          "./operation-traitable": 75
        }
      ],
      77: [
        function (require, module, exports) {
          var Operation = require("./operation");
          /**
           * Implements functions to deal with a PublishOperation object.
           * @class
           * @alias module:@asyncapi/parser#PublishOperation
           * @extends Operation
           * @returns {PublishOperation}
           */ var PublishOperation = /*#__PURE__*/ (function (_Operation) {
            "use strict";
            _inherits(PublishOperation, _Operation);
            var _super27 = _createSuper(PublishOperation);
            function PublishOperation() {
              _classCallCheck2(this, PublishOperation);
              return _super27.apply(this, arguments);
            }
            _createClass2(PublishOperation, [
              {
                key: "isPublish",
                value: /**
                 * @returns {boolean}
                 */ function isPublish() {
                  return true;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "isSubscribe",
                value: function isSubscribe() {
                  return false;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "kind",
                value: function kind() {
                  return "publish";
                }
              }
            ]);
            return PublishOperation;
          })(Operation);
          module.exports = PublishOperation;
        },
        { "./operation": 76 }
      ],
      78: [
        function (require, module, exports) {
          var _require44 = require("./utils"),
            createMapOfType = _require44.createMapOfType,
            getMapValueOfType = _require44.getMapValueOfType,
            mix = _require44.mix;
          var Base = require("./base");
          var _require45 = require("../constants"),
            xParserCircle = _require45.xParserCircle,
            xParserCircleProps = _require45.xParserCircleProps;
          var MixinDescription = require("../mixins/description");
          var MixinExternalDocs = require("../mixins/external-docs");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a Schema object.
           * @class
           * @alias module:@asyncapi/parser#Schema
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinExternalDocs
           * @mixes MixinSpecificationExtensions
           * @returns {Schema}
           */ var Schema = /*#__PURE__*/ (function (_Base15) {
            "use strict";
            _inherits(Schema, _Base15);
            var _super28 = _createSuper(Schema);
            /**
             * Instantiates a schema object
             *
             * @constructor
             * @param {any} json Schema definition
             * @param {Object=} options
             * @param {Schema=} options.parent Parent schema definition
             */ function Schema(json, options) {
              var _this14;
              _classCallCheck2(this, Schema);
              _this14 = _super28.call(this, json);
              _this14.options = options || {};
              return _this14;
            }
            /**
             * @returns {string}
             */ _createClass2(Schema, [
              {
                key: "uid",
                value: function uid() {
                  return this.$id() || this.ext("x-parser-schema-id");
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "$id",
                value: function $id() {
                  return this._json.$id;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "multipleOf",
                value: function multipleOf() {
                  return this._json.multipleOf;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "maximum",
                value: function maximum() {
                  return this._json.maximum;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "exclusiveMaximum",
                value: function exclusiveMaximum() {
                  return this._json.exclusiveMaximum;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "minimum",
                value: function minimum() {
                  return this._json.minimum;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "exclusiveMinimum",
                value: function exclusiveMinimum() {
                  return this._json.exclusiveMinimum;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "maxLength",
                value: function maxLength() {
                  return this._json.maxLength;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "minLength",
                value: function minLength() {
                  return this._json.minLength;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "pattern",
                value: function pattern() {
                  return this._json.pattern;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "maxItems",
                value: function maxItems() {
                  return this._json.maxItems;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "minItems",
                value: function minItems() {
                  return this._json.minItems;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "uniqueItems",
                value: function uniqueItems() {
                  return !!this._json.uniqueItems;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "maxProperties",
                value: function maxProperties() {
                  return this._json.maxProperties;
                }
                /**
                 * @returns {number}
                 */
              },
              {
                key: "minProperties",
                value: function minProperties() {
                  return this._json.minProperties;
                }
                /**
                 * @returns {string[]}
                 */
              },
              {
                key: "required",
                value: function required() {
                  return this._json.required;
                }
                /**
                 * @returns {any[]}
                 */
              },
              {
                key: "enum",
                value: function _enum() {
                  return this._json["enum"];
                }
                /**
                 * @returns {string|string[]}
                 */
              },
              {
                key: "type",
                value: function type() {
                  return this._json.type;
                }
                /**
                 * @returns {Schema[]}
                 */
              },
              {
                key: "allOf",
                value: function allOf() {
                  var _this15 = this;
                  if (!this._json.allOf) return null;
                  return this._json.allOf.map(function (s) {
                    return new Schema(s, { parent: _this15 });
                  });
                }
                /**
                 * @returns {Schema[]}
                 */
              },
              {
                key: "oneOf",
                value: function oneOf() {
                  var _this16 = this;
                  if (!this._json.oneOf) return null;
                  return this._json.oneOf.map(function (s) {
                    return new Schema(s, { parent: _this16 });
                  });
                }
                /**
                 * @returns {Schema[]}
                 */
              },
              {
                key: "anyOf",
                value: function anyOf() {
                  var _this17 = this;
                  if (!this._json.anyOf) return null;
                  return this._json.anyOf.map(function (s) {
                    return new Schema(s, { parent: _this17 });
                  });
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "not",
                value: function not() {
                  if (!this._json.not) return null;
                  return new Schema(this._json.not, { parent: this });
                }
                /**
                 * @returns {Schema|Schema[]}
                 */
              },
              {
                key: "items",
                value: function items() {
                  var _this18 = this;
                  if (!this._json.items) return null;
                  if (Array.isArray(this._json.items)) {
                    return this._json.items.map(function (s) {
                      return new Schema(s, { parent: _this18 });
                    });
                  }
                  return new Schema(this._json.items, { parent: this });
                }
                /**
                 * @returns {Object<string, Schema>}
                 */
              },
              {
                key: "properties",
                value: function properties() {
                  return createMapOfType(this._json.properties, Schema, {
                    parent: this
                  });
                }
                /**
                 * @param {string} name - Name of the property.
                 * @returns {Schema}
                 */
              },
              {
                key: "property",
                value: function property(name) {
                  return getMapValueOfType(this._json.properties, name, Schema, {
                    parent: this
                  });
                }
                /**
                 * @returns {boolean|Schema}
                 */
              },
              {
                key: "additionalProperties",
                value: function additionalProperties() {
                  var ap = this._json.additionalProperties;
                  if (ap === undefined || ap === null) return;
                  if (typeof ap === "boolean") return ap;
                  return new Schema(ap, { parent: this });
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "additionalItems",
                value: function additionalItems() {
                  var ai = this._json.additionalItems;
                  if (ai === undefined || ai === null) return;
                  return new Schema(ai, { parent: this });
                }
                /**
                 * @returns {Object<string, Schema>}
                 */
              },
              {
                key: "patternProperties",
                value: function patternProperties() {
                  return createMapOfType(this._json.patternProperties, Schema, {
                    parent: this
                  });
                }
                /**
                 * @returns {any}
                 */
              },
              {
                key: "const",
                value: function _const() {
                  return this._json["const"];
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "contains",
                value: function contains() {
                  if (!this._json.contains) return null;
                  return new Schema(this._json.contains, { parent: this });
                }
                /**
                 * @returns {Object<string, Schema|string[]>}
                 */
              },
              {
                key: "dependencies",
                value: function dependencies() {
                  var _this19 = this;
                  if (!this._json.dependencies) return null;
                  var result = {};
                  Object.entries(this._json.dependencies).forEach(function (
                    _ref14
                  ) {
                    var _ref15 = _slicedToArray(_ref14, 2),
                      key = _ref15[0],
                      value = _ref15[1];
                    result[String(key)] = !Array.isArray(value)
                      ? new Schema(value, { parent: _this19 })
                      : value;
                  });
                  return result;
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "propertyNames",
                value: function propertyNames() {
                  if (!this._json.propertyNames) return null;
                  return new Schema(this._json.propertyNames, { parent: this });
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "if",
                value: function _if() {
                  if (!this._json["if"]) return null;
                  return new Schema(this._json["if"], { parent: this });
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "then",
                value: function then() {
                  if (!this._json.then) return null;
                  return new Schema(this._json.then, { parent: this });
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "else",
                value: function _else() {
                  if (!this._json["else"]) return null;
                  return new Schema(this._json["else"], { parent: this });
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "format",
                value: function format() {
                  return this._json.format;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "contentEncoding",
                value: function contentEncoding() {
                  return this._json.contentEncoding;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "contentMediaType",
                value: function contentMediaType() {
                  return this._json.contentMediaType;
                }
                /**
                 * @returns {Object<string, Schema>}
                 */
              },
              {
                key: "definitions",
                value: function definitions() {
                  return createMapOfType(this._json.definitions, Schema, {
                    parent: this
                  });
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "title",
                value: function title() {
                  return this._json.title;
                }
                /**
                 * @returns {any}
                 */
              },
              {
                key: "default",
                value: function _default() {
                  return this._json["default"];
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "deprecated",
                value: function deprecated() {
                  return this._json.deprecated;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "discriminator",
                value: function discriminator() {
                  return this._json.discriminator;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "readOnly",
                value: function readOnly() {
                  return !!this._json.readOnly;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "writeOnly",
                value: function writeOnly() {
                  return !!this._json.writeOnly;
                }
                /**
                 * @returns {any[]}
                 */
              },
              {
                key: "examples",
                value: function examples() {
                  return this._json.examples;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "isBooleanSchema",
                value: function isBooleanSchema() {
                  return typeof this._json === "boolean";
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "isCircular",
                value: function isCircular() {
                  if (!!this.ext(xParserCircle)) {
                    return true;
                  }
                  var parent = this.options.parent;
                  while (parent) {
                    if (parent._json === this._json) return true;
                    parent = parent.options && parent.options.parent;
                  }
                  return false;
                }
                /**
                 * @returns {Schema}
                 */
              },
              {
                key: "circularSchema",
                value: function circularSchema() {
                  var parent = this.options.parent;
                  while (parent) {
                    if (parent._json === this._json) return parent;
                    parent = parent.options && parent.options.parent;
                  }
                }
                /**
                 * @deprecated
                 * @returns {boolean}
                 */
              },
              {
                key: "hasCircularProps",
                value: function hasCircularProps() {
                  if (Array.isArray(this.ext(xParserCircleProps))) {
                    return this.ext(xParserCircleProps).length > 0;
                  }
                  return (
                    Object.entries(this.properties() || {})
                      .map(function (_ref16) {
                        var _ref17 = _slicedToArray(_ref16, 2),
                          propertyName = _ref17[0],
                          property = _ref17[1];
                        if (property.isCircular()) return propertyName;
                      })
                      .filter(Boolean).length > 0
                  );
                }
                /**
                 * @deprecated
                 * @returns {string[]}
                 */
              },
              {
                key: "circularProps",
                value: function circularProps() {
                  if (Array.isArray(this.ext(xParserCircleProps))) {
                    return this.ext(xParserCircleProps);
                  }
                  return Object.entries(this.properties() || {})
                    .map(function (_ref18) {
                      var _ref19 = _slicedToArray(_ref18, 2),
                        propertyName = _ref19[0],
                        property = _ref19[1];
                      if (property.isCircular()) return propertyName;
                    })
                    .filter(Boolean);
                }
              }
            ]);
            return Schema;
          })(Base);
          module.exports = mix(
            Schema,
            MixinDescription,
            MixinExternalDocs,
            MixinSpecificationExtensions
          );
        },
        {
          "../constants": 48,
          "../mixins/description": 55,
          "../mixins/external-docs": 56,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./utils": 85
        }
      ],
      79: [
        function (require, module, exports) {
          var _require46 = require("./utils"),
            createMapOfType = _require46.createMapOfType,
            mix = _require46.mix;
          var Base = require("./base");
          var OAuthFlow = require("./oauth-flow");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a SecurityScheme object.
           * @class
           * @alias module:@asyncapi/parser#SecurityScheme
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {SecurityScheme}
           */ var SecurityScheme = /*#__PURE__*/ (function (_Base16) {
            "use strict";
            _inherits(SecurityScheme, _Base16);
            var _super29 = _createSuper(SecurityScheme);
            function SecurityScheme() {
              _classCallCheck2(this, SecurityScheme);
              return _super29.apply(this, arguments);
            }
            _createClass2(SecurityScheme, [
              {
                key: "type",
                value: /**
                 * @returns {string}
                 */ function type() {
                  return this._json.type;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "name",
                value: function name() {
                  return this._json.name;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "in",
                value: function _in() {
                  return this._json["in"];
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "scheme",
                value: function scheme() {
                  return this._json.scheme;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "bearerFormat",
                value: function bearerFormat() {
                  return this._json.bearerFormat;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "openIdConnectUrl",
                value: function openIdConnectUrl() {
                  return this._json.openIdConnectUrl;
                }
                /**
                 * @returns {Object<string, OAuthFlow>}
                 */
              },
              {
                key: "flows",
                value: function flows() {
                  return createMapOfType(this._json.flows, OAuthFlow);
                }
              }
            ]);
            return SecurityScheme;
          })(Base);
          module.exports = mix(
            SecurityScheme,
            MixinDescription,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./oauth-flow": 72,
          "./utils": 85
        }
      ],
      80: [
        function (require, module, exports) {
          var Base = require("./base");
          /**
           * Implements functions to deal with a ServerSecurityRequirement object.
           * @class
           * @alias module:@asyncapi/parser#ServerSecurityRequirement
           * @extends Base
           * @returns {ServerSecurityRequirement}
           */ var ServerSecurityRequirement = /*#__PURE__*/ (function (_Base17) {
            "use strict";
            _inherits(ServerSecurityRequirement, _Base17);
            var _super30 = _createSuper(ServerSecurityRequirement);
            function ServerSecurityRequirement() {
              _classCallCheck2(this, ServerSecurityRequirement);
              return _super30.apply(this, arguments);
            }
            return _createClass2(ServerSecurityRequirement);
          })(Base);
          module.exports = ServerSecurityRequirement;
        },
        { "./base": 60 }
      ],
      81: [
        function (require, module, exports) {
          var _require47 = require("./utils"),
            mix = _require47.mix;
          var Base = require("./base");
          var MixinDescription = require("../mixins/description");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a ServerVariable object.
           * @class
           * @alias module:@asyncapi/parser#ServerVariable
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinSpecificationExtensions
           * @returns {ServerVariable}
           */ var ServerVariable = /*#__PURE__*/ (function (_Base18) {
            "use strict";
            _inherits(ServerVariable, _Base18);
            var _super31 = _createSuper(ServerVariable);
            function ServerVariable() {
              _classCallCheck2(this, ServerVariable);
              return _super31.apply(this, arguments);
            }
            _createClass2(ServerVariable, [
              {
                key: "allowedValues",
                value: /**
                 * @returns {any[]}
                 */ function allowedValues() {
                  return this._json["enum"];
                }
                /**
                 * @param {string} name - Name of the variable.
                 * @returns {boolean}
                 */
              },
              {
                key: "allows",
                value: function allows(name) {
                  if (this._json["enum"] === undefined) return true;
                  return this._json["enum"].includes(name);
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasAllowedValues",
                value: function hasAllowedValues() {
                  return this._json["enum"] !== undefined;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "defaultValue",
                value: function defaultValue() {
                  return this._json["default"];
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasDefaultValue",
                value: function hasDefaultValue() {
                  return this._json["default"] !== undefined;
                }
                /**
                 * @returns {string[]}
                 */
              },
              {
                key: "examples",
                value: function examples() {
                  return this._json.examples;
                }
              }
            ]);
            return ServerVariable;
          })(Base);
          module.exports = mix(
            ServerVariable,
            MixinDescription,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./utils": 85
        }
      ],
      82: [
        function (require, module, exports) {
          var _require48 = require("./utils"),
            createMapOfType = _require48.createMapOfType,
            getMapValueOfType = _require48.getMapValueOfType,
            mix = _require48.mix;
          var Base = require("./base");
          var ServerVariable = require("./server-variable");
          var ServerSecurityRequirement = require("./server-security-requirement");
          var MixinDescription = require("../mixins/description");
          var MixinBindings = require("../mixins/bindings");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a Server object.
           * @class
           * @alias module:@asyncapi/parser#Server
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinBindings
           * @mixes MixinSpecificationExtensions
           * @returns {Server}
           */ var Server = /*#__PURE__*/ (function (_Base19) {
            "use strict";
            _inherits(Server, _Base19);
            var _super32 = _createSuper(Server);
            function Server() {
              _classCallCheck2(this, Server);
              return _super32.apply(this, arguments);
            }
            _createClass2(Server, [
              {
                key: "url",
                value: /**
                 * @returns {string}
                 */ function url() {
                  return this._json.url;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "protocol",
                value: function protocol() {
                  return this._json.protocol;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "protocolVersion",
                value: function protocolVersion() {
                  return this._json.protocolVersion;
                }
                /**
                 * @returns {Object<string, ServerVariable>}
                 */
              },
              {
                key: "variables",
                value: function variables() {
                  return createMapOfType(this._json.variables, ServerVariable);
                }
                /**
                 * @param {string} name - Name of the server variable.
                 * @returns {ServerVariable}
                 */
              },
              {
                key: "variable",
                value: function variable(name) {
                  return getMapValueOfType(
                    this._json.variables,
                    name,
                    ServerVariable
                  );
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "hasVariables",
                value: function hasVariables() {
                  return !!this._json.variables;
                }
                /**
                 * @returns {ServerSecurityRequirement[]}
                 */
              },
              {
                key: "security",
                value: function security() {
                  if (!this._json.security) return null;
                  return this._json.security.map(function (sec) {
                    return new ServerSecurityRequirement(sec);
                  });
                }
              }
            ]);
            return Server;
          })(Base);
          module.exports = mix(
            Server,
            MixinDescription,
            MixinBindings,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/bindings": 54,
          "../mixins/description": 55,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./server-security-requirement": 80,
          "./server-variable": 81,
          "./utils": 85
        }
      ],
      83: [
        function (require, module, exports) {
          var Operation = require("./operation");
          /**
           * Implements functions to deal with a SubscribeOperation object.
           * @class
           * @alias module:@asyncapi/parser#SubscribeOperation
           * @extends Operation
           * @returns {SubscribeOperation}
           */ var SubscribeOperation = /*#__PURE__*/ (function (_Operation2) {
            "use strict";
            _inherits(SubscribeOperation, _Operation2);
            var _super33 = _createSuper(SubscribeOperation);
            function SubscribeOperation() {
              _classCallCheck2(this, SubscribeOperation);
              return _super33.apply(this, arguments);
            }
            _createClass2(SubscribeOperation, [
              {
                key: "isPublish",
                value: /**
                 * @returns {boolean}
                 */ function isPublish() {
                  return false;
                }
                /**
                 * @returns {boolean}
                 */
              },
              {
                key: "isSubscribe",
                value: function isSubscribe() {
                  return true;
                }
                /**
                 * @returns {string}
                 */
              },
              {
                key: "kind",
                value: function kind() {
                  return "subscribe";
                }
              }
            ]);
            return SubscribeOperation;
          })(Operation);
          module.exports = SubscribeOperation;
        },
        { "./operation": 76 }
      ],
      84: [
        function (require, module, exports) {
          var _require49 = require("./utils"),
            mix = _require49.mix;
          var Base = require("./base");
          var MixinDescription = require("../mixins/description");
          var MixinExternalDocs = require("../mixins/external-docs");
          var MixinSpecificationExtensions = require("../mixins/specification-extensions");
          /**
           * Implements functions to deal with a Tag object.
           * @class
           * @alias module:@asyncapi/parser#Tag
           * @extends Base
           * @mixes MixinDescription
           * @mixes MixinExternalDocs
           * @mixes MixinSpecificationExtensions
           * @returns {Tag}
           */ var Tag = /*#__PURE__*/ (function (_Base20) {
            "use strict";
            _inherits(Tag, _Base20);
            var _super34 = _createSuper(Tag);
            function Tag() {
              _classCallCheck2(this, Tag);
              return _super34.apply(this, arguments);
            }
            _createClass2(Tag, [
              {
                key: "name",
                value: /**
                 * @returns {string}
                 */ function name() {
                  return this._json.name;
                }
              }
            ]);
            return Tag;
          })(Base);
          module.exports = mix(
            Tag,
            MixinDescription,
            MixinExternalDocs,
            MixinSpecificationExtensions
          );
        },
        {
          "../mixins/description": 55,
          "../mixins/external-docs": 56,
          "../mixins/specification-extensions": 57,
          "./base": 60,
          "./utils": 85
        }
      ],
      85: [
        function (require, module, exports) {
          var utils = module.exports;
          var getMapValue = function getMapValue(obj, key, Type, options) {
            if (typeof key !== "string" || !obj) return null;
            var v = obj[String(key)];
            if (v === undefined) return null;
            return Type ? new Type(v, options) : v;
          };
          /**
           * Creates map of given type from object.
           * @private
           * @param  {Object} obj
           * @param  {Any} Type
           * @param  {Object} options
           */ utils.createMapOfType = function (obj, Type, options) {
            var result = {};
            if (!obj) return result;
            Object.entries(obj).forEach(function (_ref20) {
              var _ref21 = _slicedToArray(_ref20, 2),
                key = _ref21[0],
                value = _ref21[1];
              result[String(key)] = new Type(value, options);
            });
            return result;
          };
          /**
           * Creates given type from value retrieved from object by key.
           * @private
           * @param  {Object} obj
           * @param  {string} key
           * @param  {Any} Type
           * @param  {Object} options
           */ utils.getMapValueOfType = function (obj, key, Type, options) {
            return getMapValue(obj, key, Type, options);
          };
          /**
           * Retrieves value from object by key.
           * @private
           * @param  {Object} obj
           * @param  {string} key
           */ utils.getMapValueByKey = function (obj, key) {
            return getMapValue(obj, key);
          };
          /**
           * Extends a given model with additional methods related to frequently recurring models.
           * @function mix
           * @private
           * @param  {Object} model model to extend
           * @param  {Array<Object>} mixins array with mixins to extend the model with
           */ utils.mix = function (model) {
            var duplicatedMethods = false;
            function checkDuplication(mixin) {
              // check duplication of model in mixins array
              if (model === mixin) return true; // check duplication of model's methods
              duplicatedMethods = Object.keys(mixin).some(function (mixinMethod) {
                return model.prototype.hasOwnProperty(mixinMethod);
              });
              return duplicatedMethods;
            }
            for (
              var _len3 = arguments.length,
                mixins = new Array(_len3 > 1 ? _len3 - 1 : 0),
                _key5 = 1;
              _key5 < _len3;
              _key5++
            ) {
              mixins[_key5 - 1] = arguments[_key5];
            }
            if (mixins.some(checkDuplication)) {
              if (duplicatedMethods) {
                throw new Error(
                  "invalid mix function: model ".concat(
                    model.name,
                    " has at least one method that it is trying to replace by mixin"
                  )
                );
              } else {
                throw new Error(
                  "invalid mix function: cannot use the model ".concat(
                    model.name,
                    " as a mixin"
                  )
                );
              }
            }
            mixins.forEach(function (mixin) {
              return Object.assign(model.prototype, mixin);
            });
            return model;
          };
        },
        {}
      ],
      86: [
        function (require, module, exports) {
          (function (process, global) {
            (function () {
              var path = require("path");
              var fetch =
                typeof window !== "undefined"
                  ? window["fetch"]
                  : typeof global !== "undefined"
                  ? global["fetch"]
                  : null;
              var Ajv = require("ajv");
              var asyncapi = require("@asyncapi/specs");
              var $RefParser = require("@apidevtools/json-schema-ref-parser");
              var mergePatch = require("tiny-merge-patch").apply;
              var ParserError = require("./errors/parser-error");
              var _require50 = require("./customValidators.js"),
                validateChannels = _require50.validateChannels,
                validateTags = _require50.validateTags,
                validateServerVariables = _require50.validateServerVariables,
                validateOperationId = _require50.validateOperationId,
                validateServerSecurity = _require50.validateServerSecurity,
                validateMessageId = _require50.validateMessageId;
              var _require51 = require("./utils"),
                toJS = _require51.toJS,
                findRefs = _require51.findRefs,
                getLocationOf = _require51.getLocationOf,
                improveAjvErrors = _require51.improveAjvErrors,
                getDefaultSchemaFormat = _require51.getDefaultSchemaFormat;
              var AsyncAPIDocument = require("./models/asyncapi");
              var OPERATIONS = ["publish", "subscribe"]; //the only security types that can have a non empty array in the server security item
              var SPECIAL_SECURITY_TYPES = ["oauth2", "openIdConnect"];
              var PARSERS = {};
              var xParserCircle = "x-parser-circular";
              var xParserMessageParsed = "x-parser-message-parsed";
              var ajv = new Ajv({
                jsonPointers: true,
                allErrors: true,
                schemaId: "id",
                logger: false
              });
              ajv.addMetaSchema(
                require("ajv/lib/refs/json-schema-draft-04.json")
              );
              /**
               * @module @asyncapi/parser
               */ module.exports = {
                parse: parse,
                parseFromUrl: parseFromUrl,
                registerSchemaParser: registerSchemaParser,
                ParserError: ParserError,
                AsyncAPIDocument: AsyncAPIDocument
              };
              /**
               * The complete list of parse configuration options used to parse the given data.
               * @typedef {Object} ParserOptions
               * @property {String=} path - Path to the AsyncAPI document. It will be used to resolve relative references. Defaults to current working dir.
               * @property {Object=} parse - Options object to pass to {@link https://apitools.dev/json-schema-ref-parser/docs/options.html|json-schema-ref-parser}.
               * @property {Object=} resolve - Options object to pass to {@link https://apitools.dev/json-schema-ref-parser/docs/options.html|json-schema-ref-parser}.
               * @property {Boolean=} applyTraits - Whether to resolve and apply traits or not. Defaults to true.
               */ /**
               * Parses and validate an AsyncAPI document from YAML or JSON.
               *
               * @param {(String | Object)} asyncapiYAMLorJSON An AsyncAPI document in JSON or YAML format.
               * @param {ParserOptions=} options Configuration options object {@link #asyncapiparserparseroptions--object|ParserOptions}
               * @returns {Promise<AsyncAPIDocument>} The parsed AsyncAPI document.
               */ /*async */ function parse(asyncapiYAMLorJSON) {
                var options =
                  arguments.length > 1 && arguments[1] !== undefined
                    ? arguments[1]
                    : {};
                var parsedJSON;
                var initialFormat;
                options.path =
                  options.path || "".concat(process.cwd()).concat(path.sep);
                try {
                  var _toJS = toJS(asyncapiYAMLorJSON);
                  initialFormat = _toJS.initialFormat;
                  parsedJSON = _toJS.parsedJSON;
                  if (_typeof2(parsedJSON) !== "object") {
                    throw new ParserError({
                      type: "impossible-to-convert-to-json",
                      title: "Could not convert AsyncAPI to JSON.",
                      detail:
                        "Most probably the AsyncAPI document contains invalid YAML or YAML features not supported in JSON."
                    });
                  }
                  if (!parsedJSON.asyncapi) {
                    throw new ParserError({
                      type: "missing-asyncapi-field",
                      title: "The `asyncapi` field is missing.",
                      parsedJSON: parsedJSON
                    });
                  }
                  if (
                    parsedJSON.asyncapi.startsWith("1.") ||
                    !asyncapi[parsedJSON.asyncapi]
                  ) {
                    throw new ParserError({
                      type: "unsupported-version",
                      title: "Version ".concat(
                        parsedJSON.asyncapi,
                        " is not supported."
                      ),
                      detail: "Please use latest version of the specification.",
                      parsedJSON: parsedJSON,
                      validationErrors: [
                        getLocationOf(
                          "/asyncapi",
                          asyncapiYAMLorJSON,
                          initialFormat
                        )
                      ]
                    });
                  }
                  if (options.applyTraits === undefined)
                    options.applyTraits = true;
                  var refParser = new $RefParser(); //because of Ajv lacks support for circular refs, parser should not resolve them before Ajv validation and first needs to ignore them and leave circular $refs to successfully validate the document
                  //this is done pair to advice from Ajv creator https://github.com/ajv-validator/ajv/issues/1122#issuecomment-559378449
                  //later we perform full dereference of circular refs if they occure
                  /*await*/ dereference(
                    refParser,
                    parsedJSON,
                    initialFormat,
                    asyncapiYAMLorJSON,
                    _objectSpread2(
                      _objectSpread2({}, options),
                      {},
                      { dereference: { circular: "ignore" } }
                    )
                  );
                  var validate = getValidator(parsedJSON.asyncapi);
                  var valid = validate(parsedJSON);
                  var errors =
                    validate.errors && _toConsumableArray(validate.errors);
                  if (!valid)
                    throw new ParserError({
                      type: "validation-errors",
                      title:
                        "There were errors validating the AsyncAPI document.",
                      parsedJSON: parsedJSON,
                      validationErrors: improveAjvErrors(
                        errors,
                        asyncapiYAMLorJSON,
                        initialFormat
                      )
                    });
                  /*await*/ customDocumentOperations(
                    parsedJSON,
                    asyncapiYAMLorJSON,
                    initialFormat,
                    options
                  );
                  if (refParser.$refs.circular)
                    /*await*/ handleCircularRefs(
                      refParser,
                      parsedJSON,
                      initialFormat,
                      asyncapiYAMLorJSON,
                      options
                    );
                } catch (e) {
                  if (e instanceof ParserError) throw e;
                  throw new ParserError({
                    type: "unexpected-error",
                    title: e.message,
                    parsedJSON: parsedJSON
                  });
                }
                return new AsyncAPIDocument(parsedJSON);
              }
              /**
               * Fetches an AsyncAPI document from the given URL and passes its content to the `parse` method.
               *
               * @param {String} url URL where the AsyncAPI document is located.
               * @param {Object=} [fetchOptions] Configuration to pass to the {@link https://developer.mozilla.org/en-US/docs/Web/API/Request|fetch} call.
               * @param {ParserOptions=} [options] Configuration to pass to the {@link #asyncapiparserparseroptions--object|ParserOptions} method.
               * @returns {Promise<AsyncAPIDocument>} The parsed AsyncAPI document.
               */ function parseFromUrl(url, fetchOptions, options) {
                //Why not just addinga default to the arguments list?
                //All function parameters with default values should be declared after the function parameters without default values. Otherwise, it makes it impossible for callers to take advantage of defaults; they must re-specify the defaulted values or pass undefined in order to "get to" the non-default parameters.
                //To not break the API by changing argument position and to silet the linter it is just better to move adding
                if (!fetchOptions) fetchOptions = {};
                return new Promise(function (resolve, reject) {
                  fetch(url, fetchOptions)
                    .then(function (res) {
                      return res.text();
                    })
                    .then(function (doc) {
                      return parse(doc, options);
                    })
                    .then(function (result) {
                      return resolve(result);
                    })
                    ["catch"](function (e) {
                      if (e instanceof ParserError) return reject(e);
                      return reject(
                        new ParserError({
                          type: "fetch-url-error",
                          title: e.message
                        })
                      );
                    });
                });
              }
              /*async */ function dereference(
                refParser,
                parsedJSON,
                initialFormat,
                asyncapiYAMLorJSON,
                options
              ) {
                try {
                  return /*await*/ refParser.dereference(
                    options.path,
                    parsedJSON,
                    {
                      continueOnError: true,
                      parse: options.parse,
                      resolve: options.resolve,
                      dereference: options.dereference
                    }
                  );
                } catch (err) {
                  throw new ParserError({
                    type: "dereference-error",
                    title: err.errors[0].message,
                    parsedJSON: parsedJSON,
                    refs: findRefs(err.errors, initialFormat, asyncapiYAMLorJSON)
                  });
                }
              }
              /*
               * In case of circular refs, this function dereferences the spec again to dereference circular dependencies
               * Special property is added to the document that indicates it contains circular refs
               */ /*async */ function handleCircularRefs(
                refParser,
                parsedJSON,
                initialFormat,
                asyncapiYAMLorJSON,
                options
              ) {
                /*await*/ dereference(
                  refParser,
                  parsedJSON,
                  initialFormat,
                  asyncapiYAMLorJSON,
                  _objectSpread2(
                    _objectSpread2({}, options),
                    {},
                    { dereference: { circular: true } }
                  )
                ); //mark entire document as containing circular references
                parsedJSON[String(xParserCircle)] = true;
              }
              /**
               * Creates (or reuses) a function that validates an AsyncAPI document based on the passed AsyncAPI version.
               *
               * @private
               * @param {Object} version AsyncAPI version.
               * @returns {Function} Function that validates an AsyncAPI document based on the passed AsyncAPI version.
               */ function getValidator(version) {
                var validate = ajv.getSchema(version);
                if (!validate) {
                  ajv.addSchema(asyncapi[String(version)], version);
                  validate = ajv.getSchema(version);
                }
                return validate;
              }
              /*async */ function customDocumentOperations(
                parsedJSON,
                asyncapiYAMLorJSON,
                initialFormat,
                options
              ) {
                validateServerVariables(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat
                );
                validateServerSecurity(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat,
                  SPECIAL_SECURITY_TYPES
                );
                if (!parsedJSON.channels) return;
                validateTags(parsedJSON, asyncapiYAMLorJSON, initialFormat);
                validateChannels(parsedJSON, asyncapiYAMLorJSON, initialFormat);
                validateOperationId(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat,
                  OPERATIONS
                );
                validateMessageId(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat,
                  OPERATIONS
                );
                /*await*/ customComponentsMsgOperations(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat,
                  options
                );
                /*await*/ customChannelsOperations(
                  parsedJSON,
                  asyncapiYAMLorJSON,
                  initialFormat,
                  options
                );
              }
              /*async */ function validateAndConvertMessage(
                msg,
                originalAsyncAPIDocument,
                fileFormat,
                parsedAsyncAPIDocument,
                pathToPayload
              ) {
                //check if the message has been parsed before
                if (
                  xParserMessageParsed in msg &&
                  msg[String(xParserMessageParsed)] === true
                )
                  return;
                var defaultSchemaFormat = getDefaultSchemaFormat(
                  parsedAsyncAPIDocument.asyncapi
                );
                var schemaFormat = msg.schemaFormat || defaultSchemaFormat;
                /*await*/ PARSERS[String(schemaFormat)]({
                  schemaFormat: schemaFormat,
                  message: msg,
                  defaultSchemaFormat: defaultSchemaFormat,
                  originalAsyncAPIDocument: originalAsyncAPIDocument,
                  parsedAsyncAPIDocument: parsedAsyncAPIDocument,
                  fileFormat: fileFormat,
                  pathToPayload: pathToPayload
                });
                msg.schemaFormat = defaultSchemaFormat;
                msg[String(xParserMessageParsed)] = true;
              }
              /**
               * Registers a new schema parser. Schema parsers are in charge of parsing and transforming payloads to AsyncAPI Schema format.
               *
               * @param {Object} parserModule The schema parser module containing parse() and getMimeTypes() functions.
               */ function registerSchemaParser(parserModule) {
                if (
                  _typeof2(parserModule) !== "object" ||
                  typeof parserModule.parse !== "function" ||
                  typeof parserModule.getMimeTypes !== "function"
                )
                  throw new ParserError({
                    type: "impossible-to-register-parser",
                    title:
                      "parserModule must have parse() and getMimeTypes() functions."
                  });
                parserModule.getMimeTypes().forEach(function (schemaFormat) {
                  PARSERS[String(schemaFormat)] = parserModule.parse;
                });
              }
              function applyTraits(js) {
                if (Array.isArray(js.traits)) {
                  var _iterator9 = _createForOfIteratorHelper(js.traits),
                    _step9;
                  try {
                    for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                      var trait = _step9.value;
                      for (var key in trait) {
                        js[String(key)] = mergePatch(
                          js[String(key)],
                          trait[String(key)]
                        );
                      }
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                  js["x-parser-original-traits"] = js.traits;
                  delete js.traits;
                }
              }
              /**
               * Triggers additional operations on the AsyncAPI channels like traits application or message validation and conversion
               *
               * @private
               *
               * @param  {Object} parsedJSON parsed AsyncAPI document
               * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
               * @param  {String} initialFormat information of the document was originally JSON or YAML
               * @param  {ParserOptions} options Configuration options. {@link ParserOptions}
               */ /*async */ function customChannelsOperations(
                parsedJSON,
                asyncapiYAMLorJSON,
                initialFormat,
                options
              ) {
                var promisesArray = [];
                Object.entries(parsedJSON.channels).forEach(function (_ref22) {
                  var _ref23 = _slicedToArray(_ref22, 2),
                    channelName = _ref23[0],
                    channel = _ref23[1];
                  promisesArray.push.apply(
                    promisesArray,
                    _toConsumableArray(
                      OPERATIONS.map(
                        /*async*/ function (opName) {
                          var op = channel[String(opName)];
                          if (!op) return;
                          var messages = op.message
                            ? op.message.oneOf || [op.message]
                            : [];
                          if (options.applyTraits) {
                            applyTraits(op);
                            messages.forEach(function (m) {
                              return applyTraits(m);
                            });
                          }
                          var pathToPayload = "/channels/"
                            .concat(channelName, "/")
                            .concat(opName, "/message/payload");
                          var _iterator10 = _createForOfIteratorHelper(messages),
                            _step10;
                          try {
                            for (
                              _iterator10.s();
                              !(_step10 = _iterator10.n()).done;
  
                            ) {
                              var m = _step10.value;
                              /*await*/ validateAndConvertMessage(
                                m,
                                asyncapiYAMLorJSON,
                                initialFormat,
                                parsedJSON,
                                pathToPayload
                              );
                            }
                          } catch (err) {
                            _iterator10.e(err);
                          } finally {
                            _iterator10.f();
                          }
                        }
                      )
                    )
                  );
                });
                /*await*/ Promise.all(promisesArray);
              }
              /**
               * Triggers additional operations on the AsyncAPI messages located in the components section of the document. It triggers operations like traits application, validation and conversion
               *
               * @private
               *
               * @param  {Object} parsedJSON parsed AsyncAPI document
               * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
               * @param  {String} initialFormat information of the document was originally JSON or YAML
               * @param  {ParserOptions} options Configuration options. {@link ParserOptions}
               */ /*async */ function customComponentsMsgOperations(
                parsedJSON,
                asyncapiYAMLorJSON,
                initialFormat,
                options
              ) {
                if (!parsedJSON.components || !parsedJSON.components.messages)
                  return;
                var promisesArray = [];
                Object.entries(parsedJSON.components.messages).forEach(function (
                  _ref24
                ) {
                  var _ref25 = _slicedToArray(_ref24, 2),
                    messageName = _ref25[0],
                    message = _ref25[1];
                  if (options.applyTraits) {
                    applyTraits(message);
                  }
                  var pathToPayload = "/components/messages/".concat(
                    messageName,
                    "/payload"
                  );
                  promisesArray.push(
                    validateAndConvertMessage(
                      message,
                      asyncapiYAMLorJSON,
                      initialFormat,
                      parsedJSON,
                      pathToPayload
                    )
                  );
                });
                /*await*/ Promise.all(promisesArray);
              }
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "./customValidators.js": 49,
          "./errors/parser-error": 50,
          "./models/asyncapi": 59,
          "./utils": 87,
          "@apidevtools/json-schema-ref-parser": 3,
          "@asyncapi/specs": 88,
          _process: 246,
          ajv: 109,
          "ajv/lib/refs/json-schema-draft-04.json": 150,
          path: 245,
          "tiny-merge-patch": 188
        }
      ],
      87: [
        function (require, module, exports) {
          var YAML = require("js-yaml");
          var _require52 = require("@fmvilas/pseudo-yaml-ast"),
            yamlAST = _require52.yamlAST,
            loc = _require52.loc;
          var jsonAST = require("json-to-ast");
          var jsonParseBetterErrors = require("../lib/json-parse");
          var ParserError = require("./errors/parser-error");
          var jsonPointerToArray = function jsonPointerToArray(jsonPointer) {
            return (jsonPointer || "/").split("/").splice(1);
          };
          var utils = module.exports;
          var getAST = function getAST(asyncapiYAMLorJSON, initialFormat) {
            if (initialFormat === "yaml") {
              return yamlAST(asyncapiYAMLorJSON);
            } else if (initialFormat === "json") {
              return jsonAST(asyncapiYAMLorJSON);
            }
          };
          var findNode = function findNode(obj, location) {
            var _iterator11 = _createForOfIteratorHelper(location),
              _step11;
            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                var key = _step11.value;
                obj = obj ? obj[utils.untilde(key)] : null;
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
            return obj;
          };
          var findNodeInAST = function findNodeInAST(ast, location) {
            var obj = ast;
            var _iterator12 = _createForOfIteratorHelper(location),
              _step12;
            try {
              var _loop = function _loop() {
                var key = _step12.value;
                if (!Array.isArray(obj.children)) return { v: void 0 };
                var childArray = void 0;
                var child = obj.children.find(function (c) {
                  if (!c) return;
                  if (c.type === "Object")
                    return (childArray = c.children.find(function (a) {
                      return a.key.value === utils.untilde(key);
                    }));
                  return (
                    c.type === "Property" &&
                    c.key &&
                    c.key.value === utils.untilde(key)
                  );
                });
                if (!child) return { v: void 0 };
                obj = childArray ? childArray.value : child.value;
              };
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                var _ret = _loop();
                if (_typeof2(_ret) === "object") return _ret.v;
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
            return obj;
          };
          var findLocationOf = function findLocationOf(keys, ast, initialFormat) {
            if (initialFormat === "js")
              return { jsonPointer: "/".concat(keys.join("/")) };
            var node;
            if (initialFormat === "yaml") {
              node = findNode(ast, keys);
            } else if (initialFormat === "json") {
              node = findNodeInAST(ast, keys);
            }
            if (!node) return { jsonPointer: "/".concat(keys.join("/")) };
            var info;
            if (initialFormat === "yaml") {
              // disable eslint because loc is a Symbol
              // eslint-disable-next-line security/detect-object-injection
              info = node[loc];
            } else if (initialFormat === "json") {
              info = node.loc;
            }
            if (!info) return { jsonPointer: "/".concat(keys.join("/")) };
            return {
              jsonPointer: "/".concat(keys.join("/")),
              startLine: info.start.line,
              startColumn: info.start.column + 1,
              startOffset: info.start.offset,
              endLine: info.end ? info.end.line : undefined,
              endColumn: info.end ? info.end.column + 1 : undefined,
              endOffset: info.end ? info.end.offset : undefined
            };
          };
          utils.tilde = function (str) {
            return str.replace(/[~\/]{1}/g, function (m) {
              switch (m) {
                case "/":
                  return "~1";
                case "~":
                  return "~0";
              }
              return m;
            });
          };
          utils.untilde = function (str) {
            if (!str.includes("~")) return str;
            return str.replace(/~[01]/g, function (m) {
              switch (m) {
                case "~1":
                  return "/";
                case "~0":
                  return "~";
              }
              return m;
            });
          };
          utils.toJS = function (asyncapiYAMLorJSON) {
            if (!asyncapiYAMLorJSON) {
              throw new ParserError({
                type: "null-or-falsey-document",
                title: "Document can't be null or falsey."
              });
            }
            if (
              asyncapiYAMLorJSON.constructor &&
              asyncapiYAMLorJSON.constructor.name === "Object"
            ) {
              return { initialFormat: "js", parsedJSON: asyncapiYAMLorJSON };
            }
            if (typeof asyncapiYAMLorJSON !== "string") {
              throw new ParserError({
                type: "invalid-document-type",
                title:
                  "The AsyncAPI document has to be either a string or a JS object."
              });
            }
            if (asyncapiYAMLorJSON.trimLeft().startsWith("{")) {
              try {
                return {
                  initialFormat: "json",
                  parsedJSON: jsonParseBetterErrors(asyncapiYAMLorJSON)
                };
              } catch (e) {
                throw new ParserError({
                  type: "invalid-json",
                  title: "The provided JSON is not valid.",
                  detail: e.message,
                  location: {
                    startOffset: e.offset,
                    startLine: e.startLine,
                    startColumn: e.startColumn
                  }
                });
              }
            } else {
              try {
                return {
                  initialFormat: "yaml",
                  parsedJSON: YAML.safeLoad(asyncapiYAMLorJSON)
                };
              } catch (err) {
                throw new ParserError({
                  type: "invalid-yaml",
                  title: "The provided YAML is not valid.",
                  detail: err.message,
                  location: {
                    startOffset: err.mark.position,
                    startLine: err.mark.line + 1,
                    startColumn: err.mark.column + 1
                  }
                });
              }
            }
          };
          utils.findRefs = function (errors, initialFormat, asyncapiYAMLorJSON) {
            var refs = [];
            errors.map(function (_ref26) {
              var path = _ref26.path;
              return refs.push({
                location: [].concat(_toConsumableArray(path.map(utils.tilde)), [
                  "$ref"
                ])
              });
            });
            if (initialFormat === "js") {
              return refs.map(function (ref) {
                return { jsonPointer: "/".concat(ref.location.join("/")) };
              });
            }
            if (initialFormat === "yaml") {
              var pseudoAST = yamlAST(asyncapiYAMLorJSON);
              refs = refs.map(function (ref) {
                return findLocationOf(ref.location, pseudoAST, initialFormat);
              });
            } else if (initialFormat === "json") {
              var ast = jsonAST(asyncapiYAMLorJSON);
              refs = refs.map(function (ref) {
                return findLocationOf(ref.location, ast, initialFormat);
              });
            }
            return refs;
          };
          utils.getLocationOf = function (
            jsonPointer,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var ast = getAST(asyncapiYAMLorJSON, initialFormat);
            if (!ast) return { jsonPointer: jsonPointer };
            return findLocationOf(
              jsonPointerToArray(jsonPointer),
              ast,
              initialFormat
            );
          };
          utils.improveAjvErrors = function (
            errors,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var ast = getAST(asyncapiYAMLorJSON, initialFormat);
            return errors.map(function (error) {
              var defaultLocation = { jsonPointer: error.dataPath || "/" };
              var additionalProperty = error.params.additionalProperty;
              var jsonPointer = additionalProperty
                ? "".concat(error.dataPath, "/").concat(additionalProperty)
                : error.dataPath;
              return {
                title: ""
                  .concat(error.dataPath || "/", " ")
                  .concat(error.message),
                location: ast
                  ? findLocationOf(
                      jsonPointerToArray(jsonPointer),
                      ast,
                      initialFormat
                    )
                  : defaultLocation
              };
            });
          };
          /**
           * It parses the string and returns an array with all values that are between curly braces, including braces
           * @function parseUrlVariables
           * @private
           */ utils.parseUrlVariables = function (str) {
            if (typeof str !== "string") return;
            return str.match(/{(.+?)}/g);
          };
          /**
           * It parses the string and returns url parameters as string
           * @function parseUrlQueryParameters
           * @private
           */ utils.parseUrlQueryParameters = function (str) {
            if (typeof str !== "string") return;
            return str.match(/\?((.*=.*)(&?))/g);
          };
          /**
           * Returns an array of not existing properties in provided object with names specified in provided array
           * @function getMissingProps
           * @private
           */ utils.getMissingProps = function (arr, obj) {
            arr = arr.map(function (val) {
              return val.replace(/[{}]/g, "");
            });
            if (!obj) return arr;
            return arr.filter(function (val) {
              return !obj.hasOwnProperty(val);
            });
          };
          /**
           * Returns array of errors messages compatible with validationErrors parameter from ParserError
           *
           * @function groupValidationErrors
           * @private
           * @param  {String} root name of the root element in the AsyncAPI document, for example channels
           * @param  {String} errorMessage the text of the custom error message that will follow the path that points the error
           * @param  {Map} errorElements map of error elements cause the validation error might happen in many places in the document.
           * The key should have a path information where the error was found, the value holds information about error element but it is not mandatory
           * @param  {String} asyncapiYAMLorJSON AsyncAPI document in string
           * @param  {String} initialFormat information of the document was oryginally JSON or YAML
           * @returns {Array<Object>} Object has always 2 keys, title and location. Title is a combination of errorElement key + errorMessage + errorElement value.
           * Location is the object with information about location of the issue in the file and json Pointer
           */ utils.groupValidationErrors = function (
            root,
            errorMessage,
            errorElements,
            asyncapiYAMLorJSON,
            initialFormat
          ) {
            var errors = [];
            errorElements.forEach(function (val, key) {
              if (typeof val === "string") val = utils.untilde(val);
              var jsonPointer = root
                ? "/".concat(root, "/").concat(key)
                : "/".concat(key);
              errors.push({
                title: val
                  ? ""
                      .concat(utils.untilde(key), " ")
                      .concat(errorMessage, ": ")
                      .concat(val)
                  : "".concat(utils.untilde(key), " ").concat(errorMessage),
                location: utils.getLocationOf(
                  jsonPointer,
                  asyncapiYAMLorJSON,
                  initialFormat
                )
              });
            });
            return errors;
          };
          /**
           * extend map with channel params missing corresponding param object
           *
           * @function setNotProvidedParams
           * @private
           * @param  {Array<String>} variables array of all identified URL variables in a channel name
           * @param  {Object} val the channel object for which to identify the missing parameters
           * @param  {String} key the channel name.
           * @param  {Array<Object>} notProvidedChannelParams concatinated list of missing parameters for all channels
           * @param  {Map} notProvidedParams result map of all missing parameters extended by this function
           */ utils.setNotProvidedParams = function (
            variables,
            val,
            key,
            notProvidedChannelParams,
            notProvidedParams
          ) {
            var missingChannelParams = utils.getMissingProps(
              variables,
              val.parameters
            );
            if (missingChannelParams.length) {
              notProvidedParams.set(
                utils.tilde(key),
                notProvidedChannelParams
                  ? notProvidedChannelParams.concat(missingChannelParams)
                  : missingChannelParams
              );
            }
          };
          /**
           * Returns an array of server names listed in a channel's servers list that are not declared in the top-level servers object.
           *
           * @param {Map} parsedJSON the parsed AsyncAPI document, with potentially a top-level map of servers (keys are server names)
           * @param {Object} channel the channel object for which to validate the servers list (array elements are server names)
           * @private
           */ utils.getUnknownServers = function (parsedJSON, channel) {
            // servers list on channel
            if (!channel) return []; // no channel: no unknown servers
            var channelServers = channel.servers;
            if (!channelServers || channelServers.length === 0) return []; // no servers listed on channel: no unknown servers
            // top-level servers map
            var servers = parsedJSON.servers;
            if (!servers) return channelServers; // servers list on channel but no top-level servers: all servers are unknown
            var serversMap = new Map(Object.entries(servers)); // retain only servers listed on channel that are not defined in the top-level servers map
            return channelServers.filter(function (serverName) {
              return !serversMap.has(serverName);
            });
          };
          /**
           * returns default schema format for a given asyncapi version
           *
           * @function getDefaultSchemaFormat
           * @private
           * @param  {String} asyncapiVersion AsyncAPI spec version.
           */ utils.getDefaultSchemaFormat = function (asyncapiVersion) {
            return "application/vnd.aai.asyncapi;version=".concat(
              asyncapiVersion
            );
          };
        },
        {
          "../lib/json-parse": 53,
          "./errors/parser-error": 50,
          "@fmvilas/pseudo-yaml-ast": 99,
          "js-yaml": 155,
          "json-to-ast": 186
        }
      ],
      88: [
        function (require, module, exports) {
          module.exports = {
            "1.0.0": require("./schemas/1.0.0.json"),
            "1.1.0": require("./schemas/1.1.0.json"),
            "1.2.0": require("./schemas/1.2.0.json"),
            "2.0.0-rc1": require("./schemas/2.0.0-rc1.json"),
            "2.0.0-rc2": require("./schemas/2.0.0-rc2.json"),
            "2.0.0": require("./schemas/2.0.0.json"),
            "2.1.0": require("./schemas/2.1.0.json"),
            "2.2.0": require("./schemas/2.2.0.json"),
            "2.3.0": require("./schemas/2.3.0.json"),
            "2.4.0": require("./schemas/2.4.0.json")
          };
        },
        {
          "./schemas/1.0.0.json": 89,
          "./schemas/1.1.0.json": 90,
          "./schemas/1.2.0.json": 91,
          "./schemas/2.0.0-rc1.json": 92,
          "./schemas/2.0.0-rc2.json": 93,
          "./schemas/2.0.0.json": 94,
          "./schemas/2.1.0.json": 95,
          "./schemas/2.2.0.json": 96,
          "./schemas/2.3.0.json": 97,
          "./schemas/2.4.0.json": 98
        }
      ],
      89: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 1.0 schema.",
            id: "http://asyncapi.hitchhq.com/v1/schema.json#",
            $schema: "http://json-schema.org/draft-04/schema#",
            type: "object",
            required: ["asyncapi", "info", "topics"],
            additionalProperties: false,
            patternProperties: {
              "^x-": { $ref: "#/definitions/vendorExtension" }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["1.0.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              info: { $ref: "#/definitions/info" },
              baseTopic: {
                type: "string",
                pattern: "^[^/.]",
                description: "The base topic to the API. Example: 'hitch'.",
                default: ""
              },
              servers: {
                type: "array",
                items: { $ref: "#/definitions/server" },
                uniqueItems: true
              },
              topics: { $ref: "#/definitions/topics" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              security: {
                type: "array",
                items: { $ref: "#/definitions/SecurityRequirement" }
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { type: "string", format: "uri" } }
              },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "scheme"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  scheme: {
                    type: "string",
                    description: "The transfer protocol.",
                    enum: [
                      "kafka",
                      "kafka-secure",
                      "amqp",
                      "amqps",
                      "mqtt",
                      "mqtts",
                      "secure-mqtt",
                      "ws",
                      "wss",
                      "stomp",
                      "stomps"
                    ]
                  },
                  schemeVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                minProperties: 1,
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" }
                }
              },
              topics: {
                type: "object",
                description:
                  "Relative paths to the individual topics. They must be relative to the 'baseTopic'.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" },
                  "^[^.]": { $ref: "#/definitions/topicItem" }
                },
                additionalProperties: false
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[a-zA-Z0-9\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              schema: {
                type: "object",
                description: "A deterministic version of a JSON Schema object.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  format: { type: "string" },
                  title: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                  },
                  description: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                  },
                  default: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                  },
                  multipleOf: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                  },
                  maximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                  },
                  exclusiveMaximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                  },
                  minimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                  },
                  exclusiveMinimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                  },
                  maxLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  pattern: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                  },
                  maxItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  uniqueItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                  },
                  maxProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  required: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                  },
                  enum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                  },
                  additionalProperties: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      { type: "boolean" }
                    ],
                    default: {}
                  },
                  type: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/type"
                  },
                  items: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      }
                    ],
                    default: {}
                  },
                  allOf: {
                    type: "array",
                    minItems: 1,
                    items: { $ref: "#/definitions/schema" }
                  },
                  properties: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/schema" },
                    default: {}
                  },
                  discriminator: { type: "string" },
                  readOnly: { type: "boolean", default: false },
                  xml: { $ref: "#/definitions/xml" },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  example: {}
                },
                additionalProperties: false
              },
              xml: {
                type: "object",
                additionalProperties: false,
                properties: {
                  name: { type: "string" },
                  namespace: { type: "string" },
                  prefix: { type: "string" },
                  attribute: { type: "boolean", default: false },
                  wrapped: { type: "boolean", default: false }
                }
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              topicItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                minProperties: 1,
                properties: {
                  $ref: { type: "string" },
                  publish: { $ref: "#/definitions/message" },
                  subscribe: { $ref: "#/definitions/message" },
                  deprecated: { type: "boolean", default: false }
                }
              },
              message: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  headers: { $ref: "#/definitions/schema" },
                  payload: { $ref: "#/definitions/schema" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  example: {}
                }
              },
              vendorExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: { type: "array", items: { type: "string" } }
              },
              title: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/title"
              },
              description: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/description"
              },
              default: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/default"
              },
              multipleOf: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
              },
              maximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
              },
              exclusiveMaximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
              },
              minimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
              },
              exclusiveMinimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
              },
              maxLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              pattern: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
              },
              maxItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              uniqueItems: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
              },
              enum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
              }
            }
          };
        },
        {}
      ],
      90: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 1.1.0 schema.",
            id: "http://asyncapi.hitchhq.com/v1/schema.json#",
            $schema: "http://json-schema.org/draft-04/schema#",
            type: "object",
            required: ["asyncapi", "info", "topics"],
            additionalProperties: false,
            patternProperties: {
              "^x-": { $ref: "#/definitions/vendorExtension" }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["1.0.0", "1.1.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              info: { $ref: "#/definitions/info" },
              baseTopic: {
                type: "string",
                pattern: "^[^/.]",
                description: "The base topic to the API. Example: 'hitch'.",
                default: ""
              },
              servers: {
                type: "array",
                items: { $ref: "#/definitions/server" },
                uniqueItems: true
              },
              topics: { $ref: "#/definitions/topics" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              security: {
                type: "array",
                items: { $ref: "#/definitions/SecurityRequirement" }
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { type: "string", format: "uri" } }
              },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "scheme"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  scheme: {
                    type: "string",
                    description: "The transfer protocol.",
                    enum: [
                      "kafka",
                      "kafka-secure",
                      "amqp",
                      "amqps",
                      "mqtt",
                      "mqtts",
                      "secure-mqtt",
                      "ws",
                      "wss",
                      "stomp",
                      "stomps",
                      "jms"
                    ]
                  },
                  schemeVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                minProperties: 1,
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" }
                }
              },
              topics: {
                type: "object",
                description:
                  "Relative paths to the individual topics. They must be relative to the 'baseTopic'.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" },
                  "^[^.]": { $ref: "#/definitions/topicItem" }
                },
                additionalProperties: false
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[a-zA-Z0-9\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              schema: {
                type: "object",
                description: "A deterministic version of a JSON Schema object.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  format: { type: "string" },
                  title: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                  },
                  description: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                  },
                  default: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                  },
                  multipleOf: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                  },
                  maximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                  },
                  exclusiveMaximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                  },
                  minimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                  },
                  exclusiveMinimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                  },
                  maxLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  pattern: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                  },
                  maxItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  uniqueItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                  },
                  maxProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  required: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                  },
                  enum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                  },
                  additionalProperties: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      { type: "boolean" }
                    ],
                    default: {}
                  },
                  type: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/type"
                  },
                  items: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      }
                    ],
                    default: {}
                  },
                  allOf: {
                    type: "array",
                    minItems: 1,
                    items: { $ref: "#/definitions/schema" }
                  },
                  oneOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  anyOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  not: { $ref: "#/definitions/schema" },
                  properties: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/schema" },
                    default: {}
                  },
                  discriminator: { type: "string" },
                  readOnly: { type: "boolean", default: false },
                  xml: { $ref: "#/definitions/xml" },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  example: {}
                },
                additionalProperties: false
              },
              xml: {
                type: "object",
                additionalProperties: false,
                properties: {
                  name: { type: "string" },
                  namespace: { type: "string" },
                  prefix: { type: "string" },
                  attribute: { type: "boolean", default: false },
                  wrapped: { type: "boolean", default: false }
                }
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              topicItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                minProperties: 1,
                properties: {
                  $ref: { type: "string" },
                  parameters: {
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/parameter" }
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                  },
                  name: {
                    type: "string",
                    description: "The name of the parameter."
                  },
                  schema: { $ref: "#/definitions/schema" }
                }
              },
              operation: {
                oneOf: [
                  { $ref: "#/definitions/message" },
                  {
                    type: "object",
                    required: ["oneOf"],
                    additionalProperties: false,
                    patternProperties: {
                      "^x-": { $ref: "#/definitions/vendorExtension" }
                    },
                    properties: {
                      oneOf: {
                        type: "array",
                        minItems: 2,
                        items: { $ref: "#/definitions/message" }
                      }
                    }
                  }
                ]
              },
              message: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  headers: { $ref: "#/definitions/schema" },
                  payload: { $ref: "#/definitions/schema" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  example: {}
                }
              },
              vendorExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: { type: "array", items: { type: "string" } }
              },
              title: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/title"
              },
              description: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/description"
              },
              default: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/default"
              },
              multipleOf: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
              },
              maximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
              },
              exclusiveMaximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
              },
              minimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
              },
              exclusiveMinimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
              },
              maxLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              pattern: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
              },
              maxItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              uniqueItems: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
              },
              enum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
              }
            }
          };
        },
        {}
      ],
      91: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 1.2.0 schema.",
            id: "http://asyncapi.hitchhq.com/v1/schema.json#",
            $schema: "http://json-schema.org/draft-04/schema#",
            type: "object",
            required: ["asyncapi", "info"],
            oneOf: [
              { required: ["topics"] },
              { required: ["stream"] },
              { required: ["events"] }
            ],
            additionalProperties: false,
            patternProperties: {
              "^x-": { $ref: "#/definitions/vendorExtension" }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["1.0.0", "1.1.0", "1.2.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              info: { $ref: "#/definitions/info" },
              baseTopic: {
                type: "string",
                pattern: "^[^/.]",
                description: "The base topic to the API. Example: 'hitch'.",
                default: ""
              },
              servers: {
                type: "array",
                items: { $ref: "#/definitions/server" },
                uniqueItems: true
              },
              topics: { $ref: "#/definitions/topics" },
              stream: {
                $ref: "#/definitions/stream",
                description:
                  "The list of messages a consumer can read or write from/to a streaming API."
              },
              events: {
                $ref: "#/definitions/events",
                description:
                  "The list of messages an events API sends and/or receives."
              },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              security: {
                type: "array",
                items: { $ref: "#/definitions/SecurityRequirement" }
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { type: "string", format: "uri" } }
              },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "scheme"],
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  scheme: {
                    type: "string",
                    description: "The transfer protocol.",
                    enum: [
                      "kafka",
                      "kafka-secure",
                      "amqp",
                      "amqps",
                      "mqtt",
                      "mqtts",
                      "secure-mqtt",
                      "ws",
                      "wss",
                      "stomp",
                      "stomps",
                      "jms",
                      "http",
                      "https"
                    ]
                  },
                  schemeVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                minProperties: 1,
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" }
                }
              },
              topics: {
                type: "object",
                description:
                  "Relative paths to the individual topics. They must be relative to the 'baseTopic'.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" },
                  "^[^.]": { $ref: "#/definitions/topicItem" }
                },
                additionalProperties: false
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[a-zA-Z0-9\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description: "JSON objects describing re-usable topic parameters."
              },
              schema: {
                type: "object",
                description: "A deterministic version of a JSON Schema object.",
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  format: { type: "string" },
                  title: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                  },
                  description: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                  },
                  default: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                  },
                  multipleOf: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                  },
                  maximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                  },
                  exclusiveMaximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                  },
                  minimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                  },
                  exclusiveMinimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                  },
                  maxLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  pattern: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                  },
                  maxItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  uniqueItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                  },
                  maxProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  required: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                  },
                  enum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                  },
                  additionalProperties: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      { type: "boolean" }
                    ],
                    default: {}
                  },
                  type: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/type"
                  },
                  items: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      }
                    ],
                    default: {}
                  },
                  allOf: {
                    type: "array",
                    minItems: 1,
                    items: { $ref: "#/definitions/schema" }
                  },
                  oneOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  anyOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  not: { $ref: "#/definitions/schema" },
                  properties: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/schema" },
                    default: {}
                  },
                  discriminator: { type: "string" },
                  readOnly: { type: "boolean", default: false },
                  xml: { $ref: "#/definitions/xml" },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  example: {}
                },
                additionalProperties: false
              },
              xml: {
                type: "object",
                additionalProperties: false,
                properties: {
                  name: { type: "string" },
                  namespace: { type: "string" },
                  prefix: { type: "string" },
                  attribute: { type: "boolean", default: false },
                  wrapped: { type: "boolean", default: false }
                }
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              topicItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                minProperties: 1,
                properties: {
                  $ref: { type: "string" },
                  parameters: {
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/parameter" }
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                  },
                  name: {
                    type: "string",
                    description: "The name of the parameter."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  $ref: { type: "string" }
                }
              },
              operation: {
                oneOf: [
                  { $ref: "#/definitions/message" },
                  {
                    type: "object",
                    required: ["oneOf"],
                    additionalProperties: false,
                    patternProperties: {
                      "^x-": { $ref: "#/definitions/vendorExtension" }
                    },
                    properties: {
                      oneOf: {
                        type: "array",
                        minItems: 2,
                        items: { $ref: "#/definitions/message" }
                      }
                    }
                  }
                ]
              },
              stream: {
                title: "Stream Object",
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                minProperties: 1,
                properties: {
                  framing: {
                    title: "Stream Framing Object",
                    type: "object",
                    patternProperties: {
                      "^x-": { $ref: "#/definitions/vendorExtension" }
                    },
                    minProperties: 1,
                    oneOf: [
                      {
                        additionalProperties: false,
                        properties: {
                          type: { type: "string", enum: ["chunked"] },
                          delimiter: {
                            type: "string",
                            enum: ["\\r\\n", "\\n"],
                            default: "\\r\\n"
                          }
                        }
                      },
                      {
                        additionalProperties: false,
                        properties: {
                          type: { type: "string", enum: ["sse"] },
                          delimiter: {
                            type: "string",
                            enum: ["\\n\\n"],
                            default: "\\n\\n"
                          }
                        }
                      }
                    ]
                  },
                  read: {
                    title: "Stream Read Object",
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/message" }
                  },
                  write: {
                    title: "Stream Write Object",
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/message" }
                  }
                }
              },
              events: {
                title: "Events Object",
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                minProperties: 1,
                anyOf: [{ required: ["receive"] }, { required: ["send"] }],
                properties: {
                  receive: {
                    title: "Events Receive Object",
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/message" }
                  },
                  send: {
                    title: "Events Send Object",
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/message" }
                  }
                }
              },
              message: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                },
                properties: {
                  $ref: { type: "string" },
                  headers: { $ref: "#/definitions/schema" },
                  payload: { $ref: "#/definitions/schema" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  example: {}
                }
              },
              vendorExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-": { $ref: "#/definitions/vendorExtension" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: { "^x-": {} },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: { type: "array", items: { type: "string" } }
              },
              title: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/title"
              },
              description: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/description"
              },
              default: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/default"
              },
              multipleOf: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
              },
              maximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
              },
              exclusiveMaximum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
              },
              minimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
              },
              exclusiveMinimum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
              },
              maxLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minLength: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              pattern: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
              },
              maxItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
              },
              minItems: {
                $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
              },
              uniqueItems: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
              },
              enum: {
                $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
              }
            }
          };
        },
        {}
      ],
      92: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.0.0-rc1 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "id", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.0.0-rc1"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri-reference"
              },
              info: { $ref: "#/definitions/info" },
              servers: {
                type: "array",
                items: { $ref: "#/definitions/server" },
                uniqueItems: true
              },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "protocol"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  baseChannel: { type: "string", "x-format": "uri-path" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                minProperties: 1,
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  traits: { $ref: "#/definitions/traits" }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                type: "object",
                description: "A deterministic version of a JSON Schema object.",
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  format: { type: "string" },
                  title: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                  },
                  description: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                  },
                  default: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                  },
                  multipleOf: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                  },
                  maximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                  },
                  exclusiveMaximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                  },
                  minimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                  },
                  exclusiveMinimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                  },
                  maxLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  pattern: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                  },
                  maxItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  uniqueItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                  },
                  maxProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                  },
                  minProperties: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                  },
                  required: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                  },
                  enum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                  },
                  deprecated: { type: "boolean", default: false },
                  additionalProperties: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      { type: "boolean" }
                    ],
                    default: {}
                  },
                  type: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/type"
                  },
                  items: {
                    anyOf: [
                      { $ref: "#/definitions/schema" },
                      {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      }
                    ],
                    default: {}
                  },
                  allOf: {
                    type: "array",
                    minItems: 1,
                    items: { $ref: "#/definitions/schema" }
                  },
                  oneOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  anyOf: {
                    type: "array",
                    minItems: 2,
                    items: { $ref: "#/definitions/schema" }
                  },
                  not: { $ref: "#/definitions/schema" },
                  properties: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/schema" },
                    default: {}
                  },
                  discriminator: { type: "string" },
                  readOnly: { type: "boolean", default: false },
                  xml: { $ref: "#/definitions/xml" },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  example: {},
                  examples: { type: "array", items: {} }
                },
                additionalProperties: false
              },
              xml: {
                type: "object",
                additionalProperties: false,
                properties: {
                  name: { type: "string" },
                  namespace: { type: "string" },
                  prefix: { type: "string" },
                  attribute: { type: "boolean", default: false },
                  wrapped: { type: "boolean", default: false }
                }
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                minProperties: 1,
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "array",
                    uniqueItems: true,
                    minItems: 1,
                    items: { $ref: "#/definitions/parameter" }
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  protocolInfo: {
                    type: "object",
                    additionalProperties: { type: "object" }
                  }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  name: {
                    type: "string",
                    description: "The name of the parameter."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  protocolInfo: {
                    type: "object",
                    additionalProperties: { type: "object" }
                  },
                  message: {
                    oneOf: [
                      { $ref: "#/definitions/message" },
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          oneOf: {
                            type: "array",
                            minItems: 2,
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      }
                    ]
                  }
                }
              },
              message: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    type: "object",
                    additionalProperties: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/schema" }
                      ]
                    }
                  },
                  payload: {},
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  protocolInfo: {
                    type: "object",
                    additionalProperties: { type: "object" }
                  },
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/messageTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  }
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern: "^\\$message\\.(header|payload)#(/\\w+)+"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              traits: {
                type: "object",
                additionalProperties: {
                  anyOf: [
                    { $ref: "#/definitions/operationTrait" },
                    { $ref: "#/definitions/messageTrait" }
                  ]
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  protocolInfo: {
                    type: "object",
                    additionalProperties: { type: "object" }
                  }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    type: "object",
                    additionalProperties: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/schema" }
                      ]
                    }
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  protocolInfo: {
                    type: "object",
                    additionalProperties: { type: "object" }
                  }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false,
                    minProperties: 1
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      93: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.0.0-rc2 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.0.0-rc2"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "protocol"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                minProperties: 1,
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    type: "object",
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: { $ref: "#/definitions/schema" },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 2,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 2,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                minProperties: 1,
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: { $ref: "#/definitions/schema" },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: { type: "array", items: { type: "object" } },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/schema" }
                    ]
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false,
                    minProperties: 1
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      94: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.0.0 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.0.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "protocol"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          { type: "boolean" }
                        ],
                        default: {}
                      },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: {
                            allOf: [
                              { $ref: "#/definitions/schema" },
                              { properties: { type: { const: "object" } } }
                            ]
                          },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              properties: {
                                headers: { type: "object" },
                                payload: {}
                              }
                            }
                          },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    allOf: [
                      { $ref: "#/definitions/schema" },
                      { properties: { type: { const: "object" } } }
                    ]
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      95: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.1.0 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.1.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "protocol"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          { type: "boolean" }
                        ],
                        default: {}
                      },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: {
                            allOf: [
                              { $ref: "#/definitions/schema" },
                              { properties: { type: { const: "object" } } }
                            ]
                          },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              anyOf: [
                                { required: ["payload"] },
                                { required: ["headers"] }
                              ],
                              properties: {
                                name: {
                                  type: "string",
                                  description:
                                    "Machine readable name of the message example."
                                },
                                summary: {
                                  type: "string",
                                  description:
                                    "A brief summary of the message example."
                                },
                                headers: { type: "object" },
                                payload: {}
                              }
                            }
                          },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {},
                  ibmmq: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    allOf: [
                      { $ref: "#/definitions/schema" },
                      { properties: { type: { const: "object" } } }
                    ]
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: {
                    type: "array",
                    items: {
                      type: "object",
                      additionalProperties: false,
                      anyOf: [
                        { required: ["payload"] },
                        { required: ["headers"] }
                      ],
                      properties: {
                        name: {
                          type: "string",
                          description:
                            "Machine readable name of the message example."
                        },
                        summary: {
                          type: "string",
                          description: "A brief summary of the message example."
                        },
                        headers: { type: "object" },
                        payload: {}
                      }
                    }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" },
                  { $ref: "#/definitions/SaslSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/SaslPlainSecurityScheme" },
                  { $ref: "#/definitions/SaslScramSecurityScheme" },
                  { $ref: "#/definitions/SaslGssapiSecurityScheme" }
                ]
              },
              SaslPlainSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["plain"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslScramSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["scramSha256", "scramSha512"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslGssapiSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["gssapi"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      96: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.2.0 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.2.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                required: ["url", "protocol"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          { type: "boolean" }
                        ],
                        default: {}
                      },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  servers: {
                    type: "array",
                    description:
                      "The names of the servers on which this channel is available. If absent or empty then this channel must be available on all servers.",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: {
                            allOf: [
                              { $ref: "#/definitions/schema" },
                              { properties: { type: { const: "object" } } }
                            ]
                          },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              anyOf: [
                                { required: ["payload"] },
                                { required: ["headers"] }
                              ],
                              properties: {
                                name: {
                                  type: "string",
                                  description:
                                    "Machine readable name of the message example."
                                },
                                summary: {
                                  type: "string",
                                  description:
                                    "A brief summary of the message example."
                                },
                                headers: { type: "object" },
                                payload: {}
                              }
                            }
                          },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  anypointmq: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {},
                  ibmmq: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    allOf: [
                      { $ref: "#/definitions/schema" },
                      { properties: { type: { const: "object" } } }
                    ]
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" },
                  { $ref: "#/definitions/SaslSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/SaslPlainSecurityScheme" },
                  { $ref: "#/definitions/SaslScramSecurityScheme" },
                  { $ref: "#/definitions/SaslGssapiSecurityScheme" }
                ]
              },
              SaslPlainSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["plain"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslScramSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["scramSha256", "scramSha512"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslGssapiSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["gssapi"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      97: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.3.0 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.3.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: { $ref: "#/definitions/servers" },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                anyOf: [
                  { required: ["url", "protocol"] },
                  { required: ["$ref"] }
                ],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  servers: { $ref: "#/definitions/servers" },
                  channels: { $ref: "#/definitions/channels" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          { type: "boolean" }
                        ],
                        default: {}
                      },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  servers: {
                    type: "array",
                    description:
                      "The names of the servers on which this channel is available. If absent or empty then this channel must be available on all servers.",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: {
                            allOf: [
                              { $ref: "#/definitions/schema" },
                              { properties: { type: { const: "object" } } }
                            ]
                          },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              anyOf: [
                                { required: ["payload"] },
                                { required: ["headers"] }
                              ],
                              properties: {
                                name: {
                                  type: "string",
                                  description:
                                    "Machine readable name of the message example."
                                },
                                summary: {
                                  type: "string",
                                  description:
                                    "A brief summary of the message example."
                                },
                                headers: { type: "object" },
                                payload: {}
                              }
                            }
                          },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  anypointmq: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {},
                  ibmmq: {},
                  solace: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    allOf: [
                      { $ref: "#/definitions/schema" },
                      { properties: { type: { const: "object" } } }
                    ]
                  },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" },
                  { $ref: "#/definitions/SaslSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/SaslPlainSecurityScheme" },
                  { $ref: "#/definitions/SaslScramSecurityScheme" },
                  { $ref: "#/definitions/SaslGssapiSecurityScheme" }
                ]
              },
              SaslPlainSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["plain"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslScramSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["scramSha256", "scramSha512"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslGssapiSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["gssapi"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      98: [
        function (require, module, exports) {
          module.exports = {
            title: "AsyncAPI 2.4.0 schema.",
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            required: ["asyncapi", "info", "channels"],
            additionalProperties: false,
            patternProperties: {
              "^x-[\\w\\d\\.\\x2d_]+$": {
                $ref: "#/definitions/specificationExtension"
              }
            },
            properties: {
              asyncapi: {
                type: "string",
                enum: ["2.4.0"],
                description:
                  "The AsyncAPI specification version of this document."
              },
              id: {
                type: "string",
                description: "A unique id representing the application.",
                format: "uri"
              },
              info: { $ref: "#/definitions/info" },
              servers: { $ref: "#/definitions/servers" },
              defaultContentType: { type: "string" },
              channels: { $ref: "#/definitions/channels" },
              components: { $ref: "#/definitions/components" },
              tags: {
                type: "array",
                items: { $ref: "#/definitions/tag" },
                uniqueItems: true
              },
              externalDocs: { $ref: "#/definitions/externalDocs" }
            },
            definitions: {
              Reference: {
                type: "object",
                required: ["$ref"],
                properties: { $ref: { $ref: "#/definitions/ReferenceObject" } }
              },
              ReferenceObject: { type: "string", format: "uri-reference" },
              info: {
                type: "object",
                description: "General information about the API.",
                required: ["version", "title"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  title: {
                    type: "string",
                    description: "A unique and precise title of the API."
                  },
                  version: {
                    type: "string",
                    description: "A semantic version number of the API."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the API. Should be different from the title. CommonMark is allowed."
                  },
                  termsOfService: {
                    type: "string",
                    description:
                      "A URL to the Terms of Service for the API. MUST be in the format of a URL.",
                    format: "uri"
                  },
                  contact: { $ref: "#/definitions/contact" },
                  license: { $ref: "#/definitions/license" }
                }
              },
              contact: {
                type: "object",
                description: "Contact information for the owners of the API.",
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The identifying name of the contact person/organization."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the contact information.",
                    format: "uri"
                  },
                  email: {
                    type: "string",
                    description:
                      "The email address of the contact person/organization.",
                    format: "email"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              license: {
                type: "object",
                required: ["name"],
                additionalProperties: false,
                properties: {
                  name: {
                    type: "string",
                    description:
                      "The name of the license type. It's encouraged to use an OSI compatible license."
                  },
                  url: {
                    type: "string",
                    description: "The URL pointing to the license.",
                    format: "uri"
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              server: {
                type: "object",
                description: "An object representing a Server.",
                anyOf: [
                  { required: ["url", "protocol"] },
                  { required: ["$ref"] }
                ],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  url: { type: "string" },
                  description: { type: "string" },
                  protocol: {
                    type: "string",
                    description: "The transfer protocol."
                  },
                  protocolVersion: { type: "string" },
                  variables: { $ref: "#/definitions/serverVariables" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              servers: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/server" }
              },
              serverVariables: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/serverVariable" }
              },
              serverVariable: {
                type: "object",
                description:
                  "An object representing a Server Variable for server URL template substitution.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  enum: {
                    type: "array",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  default: { type: "string" },
                  description: { type: "string" },
                  examples: { type: "array", items: { type: "string" } }
                }
              },
              channels: {
                type: "object",
                propertyNames: {
                  type: "string",
                  format: "uri-template",
                  minLength: 1
                },
                additionalProperties: { $ref: "#/definitions/channelItem" }
              },
              components: {
                type: "object",
                description:
                  "An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemas: { $ref: "#/definitions/schemas" },
                  servers: { $ref: "#/definitions/servers" },
                  serverVariables: { $ref: "#/definitions/serverVariables" },
                  channels: { $ref: "#/definitions/channels" },
                  messages: { $ref: "#/definitions/messages" },
                  securitySchemes: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/SecurityScheme" }
                        ]
                      }
                    }
                  },
                  parameters: { $ref: "#/definitions/parameters" },
                  correlationIds: {
                    type: "object",
                    patternProperties: {
                      "^[\\w\\d\\.\\-_]+$": {
                        oneOf: [
                          { $ref: "#/definitions/Reference" },
                          { $ref: "#/definitions/correlationId" }
                        ]
                      }
                    }
                  },
                  operationTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/operationTrait" }
                  },
                  messageTraits: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/messageTrait" }
                  },
                  serverBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  channelBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  operationBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  },
                  messageBindings: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/bindingsObject" }
                  }
                }
              },
              schemas: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/schema" },
                description: "JSON objects describing schemas the API uses."
              },
              messages: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/message" },
                description:
                  "JSON objects describing the messages being consumed and produced by the API."
              },
              parameters: {
                type: "object",
                additionalProperties: { $ref: "#/definitions/parameter" },
                description:
                  "JSON objects describing re-usable channel parameters."
              },
              schema: {
                allOf: [
                  { $ref: "http://json-schema.org/draft-07/schema#" },
                  {
                    patternProperties: {
                      "^x-[\\w\\d\\.\\x2d_]+$": {
                        $ref: "#/definitions/specificationExtension"
                      }
                    },
                    properties: {
                      additionalProperties: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          { type: "boolean" }
                        ],
                        default: {}
                      },
                      items: {
                        anyOf: [
                          { $ref: "#/definitions/schema" },
                          {
                            type: "array",
                            minItems: 1,
                            items: { $ref: "#/definitions/schema" }
                          }
                        ],
                        default: {}
                      },
                      allOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      oneOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      anyOf: {
                        type: "array",
                        minItems: 1,
                        items: { $ref: "#/definitions/schema" }
                      },
                      not: { $ref: "#/definitions/schema" },
                      properties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      patternProperties: {
                        type: "object",
                        additionalProperties: { $ref: "#/definitions/schema" },
                        default: {}
                      },
                      propertyNames: { $ref: "#/definitions/schema" },
                      contains: { $ref: "#/definitions/schema" },
                      discriminator: { type: "string" },
                      externalDocs: { $ref: "#/definitions/externalDocs" },
                      deprecated: { type: "boolean", default: false }
                    }
                  }
                ]
              },
              externalDocs: {
                type: "object",
                additionalProperties: false,
                description: "information about external documentation",
                required: ["url"],
                properties: {
                  description: { type: "string" },
                  url: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              channelItem: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  $ref: { $ref: "#/definitions/ReferenceObject" },
                  parameters: {
                    type: "object",
                    additionalProperties: { $ref: "#/definitions/parameter" }
                  },
                  description: {
                    type: "string",
                    description: "A description of the channel."
                  },
                  servers: {
                    type: "array",
                    description:
                      "The names of the servers on which this channel is available. If absent or empty then this channel must be available on all servers.",
                    items: { type: "string" },
                    uniqueItems: true
                  },
                  publish: { $ref: "#/definitions/operation" },
                  subscribe: { $ref: "#/definitions/operation" },
                  deprecated: { type: "boolean", default: false },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              parameter: {
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed."
                  },
                  schema: { $ref: "#/definitions/schema" },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the parameter value",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  },
                  $ref: { $ref: "#/definitions/ReferenceObject" }
                }
              },
              operation: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  traits: {
                    type: "array",
                    items: {
                      oneOf: [
                        { $ref: "#/definitions/Reference" },
                        { $ref: "#/definitions/operationTrait" },
                        {
                          type: "array",
                          items: [
                            {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/operationTrait" }
                              ]
                            },
                            { type: "object", additionalItems: true }
                          ]
                        }
                      ]
                    }
                  },
                  summary: { type: "string" },
                  description: { type: "string" },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  bindings: { $ref: "#/definitions/bindingsObject" },
                  message: { $ref: "#/definitions/message" }
                }
              },
              message: {
                oneOf: [
                  { $ref: "#/definitions/Reference" },
                  {
                    oneOf: [
                      {
                        type: "object",
                        required: ["oneOf"],
                        additionalProperties: false,
                        properties: {
                          oneOf: {
                            type: "array",
                            items: { $ref: "#/definitions/message" }
                          }
                        }
                      },
                      {
                        type: "object",
                        additionalProperties: false,
                        patternProperties: {
                          "^x-[\\w\\d\\.\\x2d_]+$": {
                            $ref: "#/definitions/specificationExtension"
                          }
                        },
                        properties: {
                          schemaFormat: { type: "string" },
                          contentType: { type: "string" },
                          headers: {
                            allOf: [
                              { $ref: "#/definitions/schema" },
                              { properties: { type: { const: "object" } } }
                            ]
                          },
                          messageId: { type: "string" },
                          payload: {},
                          correlationId: {
                            oneOf: [
                              { $ref: "#/definitions/Reference" },
                              { $ref: "#/definitions/correlationId" }
                            ]
                          },
                          tags: {
                            type: "array",
                            items: { $ref: "#/definitions/tag" },
                            uniqueItems: true
                          },
                          summary: {
                            type: "string",
                            description: "A brief summary of the message."
                          },
                          name: {
                            type: "string",
                            description: "Name of the message."
                          },
                          title: {
                            type: "string",
                            description: "A human-friendly title for the message."
                          },
                          description: {
                            type: "string",
                            description:
                              "A longer description of the message. CommonMark is allowed."
                          },
                          externalDocs: { $ref: "#/definitions/externalDocs" },
                          deprecated: { type: "boolean", default: false },
                          examples: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              anyOf: [
                                { required: ["payload"] },
                                { required: ["headers"] }
                              ],
                              properties: {
                                name: {
                                  type: "string",
                                  description:
                                    "Machine readable name of the message example."
                                },
                                summary: {
                                  type: "string",
                                  description:
                                    "A brief summary of the message example."
                                },
                                headers: { type: "object" },
                                payload: {}
                              }
                            }
                          },
                          bindings: { $ref: "#/definitions/bindingsObject" },
                          traits: {
                            type: "array",
                            items: {
                              oneOf: [
                                { $ref: "#/definitions/Reference" },
                                { $ref: "#/definitions/messageTrait" },
                                {
                                  type: "array",
                                  items: [
                                    {
                                      oneOf: [
                                        { $ref: "#/definitions/Reference" },
                                        { $ref: "#/definitions/messageTrait" }
                                      ]
                                    },
                                    { type: "object", additionalItems: true }
                                  ]
                                }
                              ]
                            }
                          }
                        }
                      }
                    ]
                  }
                ]
              },
              bindingsObject: {
                type: "object",
                additionalProperties: true,
                properties: {
                  http: {},
                  ws: {},
                  amqp: {},
                  amqp1: {},
                  mqtt: {},
                  mqtt5: {},
                  kafka: {},
                  anypointmq: {},
                  nats: {},
                  jms: {},
                  sns: {},
                  sqs: {},
                  stomp: {},
                  redis: {},
                  ibmmq: {},
                  solace: {}
                }
              },
              correlationId: {
                type: "object",
                required: ["location"],
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  description: {
                    type: "string",
                    description:
                      "A optional description of the correlation ID. GitHub Flavored Markdown is allowed."
                  },
                  location: {
                    type: "string",
                    description:
                      "A runtime expression that specifies the location of the correlation ID",
                    pattern:
                      "^\\$message\\.(header|payload)#(\\/(([^\\/~])|(~[01]))*)*"
                  }
                }
              },
              specificationExtension: {
                description: "Any property starting with x- is valid.",
                additionalProperties: true,
                additionalItems: true
              },
              tag: {
                type: "object",
                additionalProperties: false,
                required: ["name"],
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                  externalDocs: { $ref: "#/definitions/externalDocs" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              operationTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  summary: { type: "string" },
                  description: { type: "string" },
                  security: {
                    type: "array",
                    items: { $ref: "#/definitions/SecurityRequirement" }
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  operationId: { type: "string" },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              messageTrait: {
                type: "object",
                additionalProperties: false,
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                properties: {
                  schemaFormat: { type: "string" },
                  contentType: { type: "string" },
                  headers: {
                    allOf: [
                      { $ref: "#/definitions/schema" },
                      { properties: { type: { const: "object" } } }
                    ]
                  },
                  messageId: { type: "string" },
                  correlationId: {
                    oneOf: [
                      { $ref: "#/definitions/Reference" },
                      { $ref: "#/definitions/correlationId" }
                    ]
                  },
                  tags: {
                    type: "array",
                    items: { $ref: "#/definitions/tag" },
                    uniqueItems: true
                  },
                  summary: {
                    type: "string",
                    description: "A brief summary of the message."
                  },
                  name: { type: "string", description: "Name of the message." },
                  title: {
                    type: "string",
                    description: "A human-friendly title for the message."
                  },
                  description: {
                    type: "string",
                    description:
                      "A longer description of the message. CommonMark is allowed."
                  },
                  externalDocs: { $ref: "#/definitions/externalDocs" },
                  deprecated: { type: "boolean", default: false },
                  examples: { type: "array", items: { type: "object" } },
                  bindings: { $ref: "#/definitions/bindingsObject" }
                }
              },
              SecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/userPassword" },
                  { $ref: "#/definitions/apiKey" },
                  { $ref: "#/definitions/X509" },
                  { $ref: "#/definitions/symmetricEncryption" },
                  { $ref: "#/definitions/asymmetricEncryption" },
                  { $ref: "#/definitions/HTTPSecurityScheme" },
                  { $ref: "#/definitions/oauth2Flows" },
                  { $ref: "#/definitions/openIdConnect" },
                  { $ref: "#/definitions/SaslSecurityScheme" }
                ]
              },
              userPassword: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["userPassword"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              apiKey: {
                type: "object",
                required: ["type", "in"],
                properties: {
                  type: { type: "string", enum: ["apiKey"] },
                  in: { type: "string", enum: ["user", "password"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              X509: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["X509"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              symmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["symmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              asymmetricEncryption: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["asymmetricEncryption"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              HTTPSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/NonBearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/BearerHTTPSecurityScheme" },
                  { $ref: "#/definitions/APIKeyHTTPSecurityScheme" }
                ]
              },
              NonBearerHTTPSecurityScheme: {
                not: {
                  type: "object",
                  properties: { scheme: { type: "string", enum: ["bearer"] } }
                },
                type: "object",
                required: ["scheme", "type"],
                properties: {
                  scheme: { type: "string" },
                  description: { type: "string" },
                  type: { type: "string", enum: ["http"] }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              BearerHTTPSecurityScheme: {
                type: "object",
                required: ["type", "scheme"],
                properties: {
                  scheme: { type: "string", enum: ["bearer"] },
                  bearerFormat: { type: "string" },
                  type: { type: "string", enum: ["http"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              APIKeyHTTPSecurityScheme: {
                type: "object",
                required: ["type", "name", "in"],
                properties: {
                  type: { type: "string", enum: ["httpApiKey"] },
                  name: { type: "string" },
                  in: { type: "string", enum: ["header", "query", "cookie"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslSecurityScheme: {
                oneOf: [
                  { $ref: "#/definitions/SaslPlainSecurityScheme" },
                  { $ref: "#/definitions/SaslScramSecurityScheme" },
                  { $ref: "#/definitions/SaslGssapiSecurityScheme" }
                ]
              },
              SaslPlainSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["plain"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslScramSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["scramSha256", "scramSha512"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SaslGssapiSecurityScheme: {
                type: "object",
                required: ["type"],
                properties: {
                  type: { type: "string", enum: ["gssapi"] },
                  description: { type: "string" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Flows: {
                type: "object",
                required: ["type", "flows"],
                properties: {
                  type: { type: "string", enum: ["oauth2"] },
                  description: { type: "string" },
                  flows: {
                    type: "object",
                    properties: {
                      implicit: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "scopes"] },
                          { not: { required: ["tokenUrl"] } }
                        ]
                      },
                      password: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      clientCredentials: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["tokenUrl", "scopes"] },
                          { not: { required: ["authorizationUrl"] } }
                        ]
                      },
                      authorizationCode: {
                        allOf: [
                          { $ref: "#/definitions/oauth2Flow" },
                          { required: ["authorizationUrl", "tokenUrl", "scopes"] }
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                }
              },
              oauth2Flow: {
                type: "object",
                properties: {
                  authorizationUrl: { type: "string", format: "uri" },
                  tokenUrl: { type: "string", format: "uri" },
                  refreshUrl: { type: "string", format: "uri" },
                  scopes: { $ref: "#/definitions/oauth2Scopes" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              oauth2Scopes: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              openIdConnect: {
                type: "object",
                required: ["type", "openIdConnectUrl"],
                properties: {
                  type: { type: "string", enum: ["openIdConnect"] },
                  description: { type: "string" },
                  openIdConnectUrl: { type: "string", format: "uri" }
                },
                patternProperties: {
                  "^x-[\\w\\d\\.\\x2d_]+$": {
                    $ref: "#/definitions/specificationExtension"
                  }
                },
                additionalProperties: false
              },
              SecurityRequirement: {
                type: "object",
                additionalProperties: {
                  type: "array",
                  items: { type: "string" },
                  uniqueItems: true
                }
              }
            }
          };
        },
        {}
      ],
      99: [
        function (require, module, exports) {
          var _require53 = require("yaml-ast-parser"),
            load = _require53.load,
            Kind = _require53.Kind;
          var loc = Symbol("pseudo-yaml-ast-loc");
          var hasOwnProp = function hasOwnProp(obj, key) {
            return (
              obj &&
              _typeof2(obj) === "object" &&
              Object.prototype.hasOwnProperty.call(obj, key)
            );
          };
          var isUndefined = function isUndefined(v) {
            return v === undefined;
          };
          var isNull = function isNull(v) {
            return v === null;
          };
          var isPrimitive = function isPrimitive(v) {
            return (
              Number.isNaN(v) ||
              isNull(v) ||
              isUndefined(v) ||
              _typeof2(v) === "symbol"
            );
          };
          var isPrimitiveNode = function isPrimitiveNode(node) {
            return isPrimitive(node.value) || !hasOwnProp(node, "value");
          };
          var isBetween = function isBetween(start, pos, end) {
            return pos <= end && pos >= start;
          };
          var getLoc = function getLoc(input, _ref27) {
            var _ref27$start = _ref27.start,
              start = _ref27$start === void 0 ? 0 : _ref27$start,
              _ref27$end = _ref27.end,
              end = _ref27$end === void 0 ? 0 : _ref27$end;
            var lines = input.split(/\n/);
            var loc = { start: {}, end: {} };
            var sum = 0;
            var _iterator13 = _createForOfIteratorHelper(lines.keys()),
              _step13;
            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                var i = _step13.value;
                var line = lines[i];
                var ls = sum;
                var le = sum + line.length;
                if (isUndefined(loc.start.line) && isBetween(ls, start, le)) {
                  loc.start.line = i + 1;
                  loc.start.column = start - ls;
                  loc.start.offset = start;
                }
                if (isUndefined(loc.end.line) && isBetween(ls, end, le)) {
                  loc.end.line = i + 1;
                  loc.end.column = end - ls;
                  loc.end.offset = end;
                }
                sum = le + 1; // +1 because the break is also a char
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
            return loc;
          };
          var visitors = {
            MAP: function MAP() {
              var node =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              var input =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : "";
              var ctx =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {};
              return Object.assign(
                walk(node.mappings, input),
                _defineProperty2(
                  {},
                  loc,
                  getLoc(input, {
                    start: node.startPosition,
                    end: node.endPosition
                  })
                )
              );
            },
            MAPPING: function MAPPING() {
              var node =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              var input =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : "";
              var ctx =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {};
              var value = walk([node.value], input);
              if (!isPrimitive(value)) {
                value[loc] = getLoc(input, {
                  start: node.startPosition,
                  end: node.endPosition
                });
              }
              return Object.assign(
                ctx,
                _defineProperty2({}, node.key.value, value)
              );
            },
            SCALAR: function SCALAR() {
              var node =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              var input =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : "";
              if (isPrimitiveNode(node)) {
                return node.value;
              }
              var _loc = getLoc(input, {
                start: node.startPosition,
                end: node.endPosition
              });
              var wrappable = function wrappable(Constructor) {
                return function () {
                  var v = new Constructor(node.value);
                  v[loc] = _loc;
                  return v;
                };
              };
              var object = function object() {
                node.value[loc] = _loc;
                return node.value;
              };
              var types = {
                boolean: wrappable(Boolean),
                number: wrappable(Number),
                string: wrappable(String),
                function: object,
                object: object
              };
              return types[_typeof2(node.value)]();
            },
            SEQ: function SEQ() {
              var node =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              var input =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : "";
              var items = walk(node.items, input, []);
              items[loc] = getLoc(input, {
                start: node.startPosition,
                end: node.endPosition
              });
              return items;
            }
          };
          var walk = function walk() {
            var nodes =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : [];
            var input = arguments.length > 1 ? arguments[1] : undefined;
            var ctx =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {};
            var onNode = function onNode(node, ctx, fallback) {
              var visitor;
              if (node) visitor = visitors[Kind[node.kind]];
              return visitor ? visitor(node, input, ctx) : fallback;
            };
            var walkObj = function walkObj() {
              return nodes.reduce(function (sum, node) {
                return onNode(node, sum, sum);
              }, ctx);
            };
            var walkArr = function walkArr() {
              return nodes
                .map(function (node) {
                  return onNode(node, ctx, null);
                }, ctx)
                .filter(Boolean);
            };
            return Array.isArray(ctx) ? walkArr() : walkObj();
          };
          module.exports.loc = loc;
          module.exports.yamlAST = function (input) {
            return walk([load(input)], input);
          };
        },
        { "yaml-ast-parser": 193 }
      ],
      100: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.Ono = void 0;
          var extend_error_1 = require("./extend-error");
          var normalize_1 = require("./normalize");
          var to_json_1 = require("./to-json");
          var constructor = Ono;
          exports.Ono = constructor;
          /**
           * Creates an `Ono` instance for a specifc error type.
           */ // eslint-disable-next-line @typescript-eslint/naming-convention
          function Ono(ErrorConstructor, options) {
            options = normalize_1.normalizeOptions(options);
            function ono() {
              for (
                var _len4 = arguments.length, args = new Array(_len4), _key6 = 0;
                _key6 < _len4;
                _key6++
              ) {
                args[_key6] = arguments[_key6];
              }
              var _normalize_1$normaliz = normalize_1.normalizeArgs(
                  args,
                  options
                ),
                originalError = _normalize_1$normaliz.originalError,
                props = _normalize_1$normaliz.props,
                message = _normalize_1$normaliz.message; // Create a new error of the specified type
              var newError = new ErrorConstructor(message); // Extend the error with the properties of the original error and the `props` object
              return extend_error_1.extendError(newError, originalError, props);
            }
            ono[Symbol.species] = ErrorConstructor;
            return ono;
          }
          /**
           * Returns an object containing all properties of the given Error object,
           * which can be used with `JSON.stringify()`.
           */ Ono.toJSON = function toJSON(error) {
            return to_json_1.toJSON.call(error);
          };
          /**
           * Extends the given Error object with enhanced Ono functionality, such as nested stack traces,
           * additional properties, and improved support for `JSON.stringify()`.
           */ Ono.extend = function extend(error, originalError, props) {
            if (props || originalError instanceof Error) {
              return extend_error_1.extendError(error, originalError, props);
            } else if (originalError) {
              return extend_error_1.extendError(error, undefined, originalError);
            } else {
              return extend_error_1.extendError(error);
            }
          };
        },
        { "./extend-error": 101, "./normalize": 104, "./to-json": 107 }
      ],
      101: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.extendError = void 0;
          var isomorphic_node_1 = require("./isomorphic.node");
          var stack_1 = require("./stack");
          var to_json_1 = require("./to-json");
          var protectedProps = ["name", "message", "stack"];
          /**
           * Extends the new error with the properties of the original error and the `props` object.
           *
           * @param newError - The error object to extend
           * @param originalError - The original error object, if any
           * @param props - Additional properties to add, if any
           */ function extendError(error, originalError, props) {
            var onoError = error;
            extendStack(onoError, originalError); // Copy properties from the original error
            if (originalError && _typeof2(originalError) === "object") {
              mergeErrors(onoError, originalError);
            } // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.
            // So replace it with one that outputs every property of the error.
            onoError.toJSON = to_json_1.toJSON; // On Node.js, add support for the `util.inspect()` method
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (isomorphic_node_1.addInspectMethod) {
              isomorphic_node_1.addInspectMethod(onoError);
            } // Finally, copy custom properties that were specified by the user.
            // These props OVERWRITE any previous props
            if (props && _typeof2(props) === "object") {
              Object.assign(onoError, props);
            }
            return onoError;
          }
          exports.extendError = extendError;
          /**
           * Extend the error stack to include its cause
           */ function extendStack(newError, originalError) {
            var stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
            if (stack_1.isLazyStack(stackProp)) {
              stack_1.lazyJoinStacks(stackProp, newError, originalError);
            } else if (stack_1.isWritableStack(stackProp)) {
              newError.stack = stack_1.joinStacks(newError, originalError);
            }
          }
          /**
           * Merges properties of the original error with the new error.
           *
           * @param newError - The error object to extend
           * @param originalError - The original error object, if any
           */ function mergeErrors(newError, originalError) {
            // Get the original error's keys
            // NOTE: We specifically exclude properties that we have already set on the new error.
            // This is _especially_ important for the `stack` property, because this property has
            // a lazy getter in some environments
            var keys = to_json_1.getDeepKeys(originalError, protectedProps); // HACK: We have to cast the errors to `any` so we can use symbol indexers.
            // see https://github.com/Microsoft/TypeScript/issues/1863
            var _newError = newError;
            var _originalError = originalError;
            var _iterator14 = _createForOfIteratorHelper(keys),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
                var key = _step14.value;
                if (_newError[key] === undefined) {
                  try {
                    _newError[key] = _originalError[key];
                  } catch (e) {
                    // This property is read-only, so it can't be copied
                  }
                }
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
          }
        },
        { "./isomorphic.node": 103, "./stack": 106, "./to-json": 107 }
      ],
      102: [
        function (require, module, exports) {
          "use strict";
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k;
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function get() {
                      return m[k];
                    }
                  });
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k;
                  o[k2] = m[k];
                });
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m) {
                if (p !== "default" && !exports.hasOwnProperty(p))
                  __createBinding(exports, m, p);
              }
            };
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.ono = void 0;
          /* eslint-env commonjs */ var singleton_1 = require("./singleton");
          Object.defineProperty(exports, "ono", {
            enumerable: true,
            get: function get() {
              return singleton_1.ono;
            }
          });
          var constructor_1 = require("./constructor");
          Object.defineProperty(exports, "Ono", {
            enumerable: true,
            get: function get() {
              return constructor_1.Ono;
            }
          });
          __exportStar(require("./types"), exports);
          exports["default"] = singleton_1.ono; // CommonJS default export hack
          if (
            _typeof2(module) === "object" &&
            _typeof2(module.exports) === "object"
          ) {
            module.exports = Object.assign(
              module.exports["default"],
              module.exports
            );
          }
        },
        { "./constructor": 100, "./singleton": 105, "./types": 108 }
      ],
      103: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.addInspectMethod = exports.format = void 0;
          /**
           * Ono supports custom formatters for error messages.  In Node.js, it defaults
           * to the `util.format()` function.  In browsers, it defaults to `Array.join()`.
           *
           * The Node.js functionality can be used in a web browser via a polyfill,
           * such as "format-util".
           *
           * @see https://github.com/tmpfs/format-util
           */ exports.format = false;
          /**
           * The `util.inspect()` functionality only applies to Node.js.
           * We return the constant `false` here so that the Node-specific code gets removed by tree-shaking.
           */ exports.addInspectMethod = false;
        },
        {}
      ],
      104: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.normalizeArgs = exports.normalizeOptions = void 0;
          var isomorphic_node_1 = require("./isomorphic.node");
          /**
           * Normalizes Ono options, accounting for defaults and optional options.
           */ function normalizeOptions(options) {
            options = options || {};
            return {
              concatMessages:
                options.concatMessages === undefined
                  ? true
                  : Boolean(options.concatMessages),
              format:
                options.format === undefined
                  ? isomorphic_node_1.format
                  : typeof options.format === "function"
                  ? options.format
                  : false
            };
          }
          exports.normalizeOptions = normalizeOptions;
          /**
           * Normalizes the Ono arguments, accounting for defaults, options, and optional arguments.
           */ function normalizeArgs(args, options) {
            var originalError;
            var props;
            var formatArgs;
            var message = ""; // Determine which arguments were actually specified
            if (typeof args[0] === "string") {
              formatArgs = args;
            } else if (typeof args[1] === "string") {
              if (args[0] instanceof Error) {
                originalError = args[0];
              } else {
                props = args[0];
              }
              formatArgs = args.slice(1);
            } else {
              originalError = args[0];
              props = args[1];
              formatArgs = args.slice(2);
            } // If there are any format arguments, then format the error message
            if (formatArgs.length > 0) {
              if (options.format) {
                message = options.format.apply(undefined, formatArgs);
              } else {
                message = formatArgs.join(" ");
              }
            }
            if (
              options.concatMessages &&
              originalError &&
              originalError.message
            ) {
              // The inner-error's message will be added to the new message
              message += (message ? " \n" : "") + originalError.message;
            }
            return {
              originalError: originalError,
              props: props,
              message: message
            };
          }
          exports.normalizeArgs = normalizeArgs;
        },
        { "./isomorphic.node": 103 }
      ],
      105: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.ono = void 0;
          var constructor_1 = require("./constructor");
          var singleton = ono;
          exports.ono = singleton;
          ono.error = new constructor_1.Ono(Error);
          ono.eval = new constructor_1.Ono(EvalError);
          ono.range = new constructor_1.Ono(RangeError);
          ono.reference = new constructor_1.Ono(ReferenceError);
          ono.syntax = new constructor_1.Ono(SyntaxError);
          ono.type = new constructor_1.Ono(TypeError);
          ono.uri = new constructor_1.Ono(URIError);
          var onoMap = ono;
          /**
           * Creates a new error with the specified message, properties, and/or inner error.
           * If an inner error is provided, then the new error will match its type, if possible.
           */ function ono() {
            for (
              var _len5 = arguments.length, args = new Array(_len5), _key7 = 0;
              _key7 < _len5;
              _key7++
            ) {
              args[_key7] = arguments[_key7];
            }
            var originalError = args[0]; // Is the first argument an Error-like object?
            if (
              _typeof2(originalError) === "object" &&
              typeof originalError.name === "string"
            ) {
              // Try to find an Ono singleton method that matches this error type
              for (
                var _i10 = 0, _Object$values2 = Object.values(onoMap);
                _i10 < _Object$values2.length;
                _i10++
              ) {
                var typedOno = _Object$values2[_i10];
                if (typeof typedOno === "function" && typedOno.name === "ono") {
                  var species = typedOno[Symbol.species];
                  if (
                    species &&
                    species !== Error &&
                    (originalError instanceof species ||
                      originalError.name === species.name)
                  ) {
                    // Create an error of the same type
                    return typedOno.apply(undefined, args);
                  }
                }
              }
            } // By default, create a base Error object
            return ono.error.apply(undefined, args);
          }
        },
        { "./constructor": 100 }
      ],
      106: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.lazyJoinStacks =
            exports.joinStacks =
            exports.isWritableStack =
            exports.isLazyStack =
              void 0;
          var newline = /\r?\n/;
          var onoCall = /\bono[ @]/;
          /**
           * Is the property lazily computed?
           */ function isLazyStack(stackProp) {
            return Boolean(
              stackProp &&
                stackProp.configurable &&
                typeof stackProp.get === "function"
            );
          }
          exports.isLazyStack = isLazyStack;
          /**
           * Is the stack property writable?
           */ function isWritableStack(stackProp) {
            return Boolean(
              // If there is no stack property, then it's writable, since assigning it will create it
              !stackProp ||
                stackProp.writable ||
                typeof stackProp.set === "function"
            );
          }
          exports.isWritableStack = isWritableStack;
          /**
           * Appends the original `Error.stack` property to the new Error's stack.
           */ function joinStacks(newError, originalError) {
            var newStack = popStack(newError.stack);
            var originalStack = originalError ? originalError.stack : undefined;
            if (newStack && originalStack) {
              return newStack + "\n\n" + originalStack;
            } else {
              return newStack || originalStack;
            }
          }
          exports.joinStacks = joinStacks;
          /**
           * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.
           */ function lazyJoinStacks(lazyStack, newError, originalError) {
            if (originalError) {
              Object.defineProperty(newError, "stack", {
                get: function get() {
                  var newStack = lazyStack.get.apply(newError);
                  return joinStacks({ stack: newStack }, originalError);
                },
                enumerable: false,
                configurable: true
              });
            } else {
              lazyPopStack(newError, lazyStack);
            }
          }
          exports.lazyJoinStacks = lazyJoinStacks;
          /**
           * Removes Ono from the stack, so that the stack starts at the original error location
           */ function popStack(stack) {
            if (stack) {
              var lines = stack.split(newline); // Find the Ono call(s) in the stack, and remove them
              var onoStart;
              for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (onoCall.test(line)) {
                  if (onoStart === undefined) {
                    // We found the first Ono call in the stack trace.
                    // There may be other subsequent Ono calls as well.
                    onoStart = i;
                  }
                } else if (onoStart !== undefined) {
                  // We found the first non-Ono call after one or more Ono calls.
                  // So remove the Ono call lines from the stack trace
                  lines.splice(onoStart, i - onoStart);
                  break;
                }
              }
              if (lines.length > 0) {
                return lines.join("\n");
              }
            } // If we get here, then the stack doesn't contain a call to `ono`.
            // This may be due to minification or some optimization of the JS engine.
            // So just return the stack as-is.
            return stack;
          }
          /**
           * Calls `popStack` lazily, when the `Error.stack` property is accessed.
           */ function lazyPopStack(error, lazyStack) {
            Object.defineProperty(error, "stack", {
              get: function get() {
                return popStack(lazyStack.get.apply(error));
              },
              enumerable: false,
              configurable: true
            });
          }
        },
        {}
      ],
      107: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          exports.getDeepKeys = exports.toJSON = void 0;
          var nonJsonTypes = ["function", "symbol", "undefined"];
          var protectedProps = ["constructor", "prototype", "__proto__"];
          var objectPrototype = Object.getPrototypeOf({});
          /**
           * Custom JSON serializer for Error objects.
           * Returns all built-in error properties, as well as extended properties.
           */ function toJSON() {
            // HACK: We have to cast the objects to `any` so we can use symbol indexers.
            // see https://github.com/Microsoft/TypeScript/issues/1863
            var pojo = {};
            var error = this;
            var _iterator15 = _createForOfIteratorHelper(getDeepKeys(error)),
              _step15;
            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
                var key = _step15.value;
                if (typeof key === "string") {
                  var value = error[key];
                  var type = _typeof2(value);
                  if (!nonJsonTypes.includes(type)) {
                    pojo[key] = value;
                  }
                }
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
            return pojo;
          }
          exports.toJSON = toJSON;
          /**
           * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.
           * Does NOT return members of the base Object prototype, or the specified omitted keys.
           */ function getDeepKeys(obj) {
            var omit =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : [];
            var keys = []; // Crawl the prototype chain, finding all the string and symbol keys
            while (obj && obj !== objectPrototype) {
              keys = keys.concat(
                Object.getOwnPropertyNames(obj),
                Object.getOwnPropertySymbols(obj)
              );
              obj = Object.getPrototypeOf(obj);
            } // De-duplicate the list of keys
            var uniqueKeys = new Set(keys); // Remove any omitted keys
            var _iterator16 = _createForOfIteratorHelper(
                omit.concat(protectedProps)
              ),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done; ) {
                var key = _step16.value;
                uniqueKeys["delete"](key);
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            return uniqueKeys;
          }
          exports.getDeepKeys = getDeepKeys;
        },
        {}
      ],
      108: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var util_1 = require("util");
        },
        { util: 277 }
      ],
      109: [
        function (require, module, exports) {
          "use strict";
          var compileSchema = require("./compile"),
            resolve = require("./compile/resolve"),
            Cache = require("./cache"),
            SchemaObject = require("./compile/schema_obj"),
            stableStringify = require("fast-json-stable-stringify"),
            formats = require("./compile/formats"),
            rules = require("./compile/rules"),
            $dataMetaSchema = require("./data"),
            util = require("./compile/util");
          module.exports = Ajv;
          Ajv.prototype.validate = validate;
          Ajv.prototype.compile = compile;
          Ajv.prototype.addSchema = addSchema;
          Ajv.prototype.addMetaSchema = addMetaSchema;
          Ajv.prototype.validateSchema = validateSchema;
          Ajv.prototype.getSchema = getSchema;
          Ajv.prototype.removeSchema = removeSchema;
          Ajv.prototype.addFormat = addFormat;
          Ajv.prototype.errorsText = errorsText;
          Ajv.prototype._addSchema = _addSchema;
          Ajv.prototype._compile = _compile;
          Ajv.prototype.compileAsync = require("./compile/async");
          var customKeyword = require("./keyword");
          Ajv.prototype.addKeyword = customKeyword.add;
          Ajv.prototype.getKeyword = customKeyword.get;
          Ajv.prototype.removeKeyword = customKeyword.remove;
          Ajv.prototype.validateKeyword = customKeyword.validate;
          var errorClasses = require("./compile/error_classes");
          Ajv.ValidationError = errorClasses.Validation;
          Ajv.MissingRefError = errorClasses.MissingRef;
          Ajv.$dataMetaSchema = $dataMetaSchema;
          var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
          var META_IGNORE_OPTIONS = [
            "removeAdditional",
            "useDefaults",
            "coerceTypes",
            "strictDefaults"
          ];
          var META_SUPPORT_DATA = ["/properties"];
          /**
           * Creates validator instance.
           * Usage: `Ajv(opts)`
           * @param {Object} opts optional options
           * @return {Object} ajv instance
           */ function Ajv(opts) {
            if (!(this instanceof Ajv)) return new Ajv(opts);
            opts = this._opts = util.copy(opts) || {};
            setLogger(this);
            this._schemas = {};
            this._refs = {};
            this._fragments = {};
            this._formats = formats(opts.format);
            this._cache = opts.cache || new Cache();
            this._loadingSchemas = {};
            this._compilations = [];
            this.RULES = rules();
            this._getId = chooseGetId(opts);
            opts.loopRequired = opts.loopRequired || Infinity;
            if (opts.errorDataPath == "property")
              opts._errorDataPathProperty = true;
            if (opts.serialize === undefined) opts.serialize = stableStringify;
            this._metaOpts = getMetaSchemaOptions(this);
            if (opts.formats) addInitialFormats(this);
            if (opts.keywords) addInitialKeywords(this);
            addDefaultMetaSchema(this);
            if (_typeof2(opts.meta) == "object") this.addMetaSchema(opts.meta);
            if (opts.nullable)
              this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
            addInitialSchemas(this);
          }
          /**
           * Validate data using schema
           * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
           * @this   Ajv
           * @param  {String|Object} schemaKeyRef key, ref or schema object
           * @param  {Any} data to be validated
           * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
           */ function validate(schemaKeyRef, data) {
            var v;
            if (typeof schemaKeyRef == "string") {
              v = this.getSchema(schemaKeyRef);
              if (!v)
                throw new Error(
                  'no schema with key or ref "' + schemaKeyRef + '"'
                );
            } else {
              var schemaObj = this._addSchema(schemaKeyRef);
              v = schemaObj.validate || this._compile(schemaObj);
            }
            var valid = v(data);
            if (v.$async !== true) this.errors = v.errors;
            return valid;
          }
          /**
           * Create validating function for passed schema.
           * @this   Ajv
           * @param  {Object} schema schema object
           * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
           * @return {Function} validating function
           */ function compile(schema, _meta) {
            var schemaObj = this._addSchema(schema, undefined, _meta);
            return schemaObj.validate || this._compile(schemaObj);
          }
          /**
           * Adds schema to the instance.
           * @this   Ajv
           * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
           * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
           * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
           * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
           * @return {Ajv} this for method chaining
           */ function addSchema(schema, key, _skipValidation, _meta) {
            if (Array.isArray(schema)) {
              for (var i = 0; i < schema.length; i++) {
                this.addSchema(schema[i], undefined, _skipValidation, _meta);
              }
              return this;
            }
            var id = this._getId(schema);
            if (id !== undefined && typeof id != "string")
              throw new Error("schema id must be string");
            key = resolve.normalizeId(key || id);
            checkUnique(this, key);
            this._schemas[key] = this._addSchema(
              schema,
              _skipValidation,
              _meta,
              true
            );
            return this;
          }
          /**
           * Add schema that will be used to validate other schemas
           * options in META_IGNORE_OPTIONS are alway set to false
           * @this   Ajv
           * @param {Object} schema schema object
           * @param {String} key optional schema key
           * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
           * @return {Ajv} this for method chaining
           */ function addMetaSchema(schema, key, skipValidation) {
            this.addSchema(schema, key, skipValidation, true);
            return this;
          }
          /**
           * Validate schema
           * @this   Ajv
           * @param {Object} schema schema to validate
           * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
           * @return {Boolean} true if schema is valid
           */ function validateSchema(schema, throwOrLogError) {
            var $schema = schema.$schema;
            if ($schema !== undefined && typeof $schema != "string")
              throw new Error("$schema must be a string");
            $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
            if (!$schema) {
              this.logger.warn("meta-schema not available");
              this.errors = null;
              return true;
            }
            var valid = this.validate($schema, schema);
            if (!valid && throwOrLogError) {
              var message = "schema is invalid: " + this.errorsText();
              if (this._opts.validateSchema == "log") this.logger.error(message);
              else throw new Error(message);
            }
            return valid;
          }
          function defaultMeta(self) {
            var meta = self._opts.meta;
            self._opts.defaultMeta =
              _typeof2(meta) == "object"
                ? self._getId(meta) || meta
                : self.getSchema(META_SCHEMA_ID)
                ? META_SCHEMA_ID
                : undefined;
            return self._opts.defaultMeta;
          }
          /**
           * Get compiled schema from the instance by `key` or `ref`.
           * @this   Ajv
           * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
           * @return {Function} schema validating function (with property `schema`).
           */ function getSchema(keyRef) {
            var schemaObj = _getSchemaObj(this, keyRef);
            switch (_typeof2(schemaObj)) {
              case "object":
                return schemaObj.validate || this._compile(schemaObj);
              case "string":
                return this.getSchema(schemaObj);
              case "undefined":
                return _getSchemaFragment(this, keyRef);
            }
          }
          function _getSchemaFragment(self, ref) {
            var res = resolve.schema.call(self, { schema: {} }, ref);
            if (res) {
              var schema = res.schema,
                root = res.root,
                baseId = res.baseId;
              var v = compileSchema.call(self, schema, root, undefined, baseId);
              self._fragments[ref] = new SchemaObject({
                ref: ref,
                fragment: true,
                schema: schema,
                root: root,
                baseId: baseId,
                validate: v
              });
              return v;
            }
          }
          function _getSchemaObj(self, keyRef) {
            keyRef = resolve.normalizeId(keyRef);
            return (
              self._schemas[keyRef] ||
              self._refs[keyRef] ||
              self._fragments[keyRef]
            );
          }
          /**
           * Remove cached schema(s).
           * If no parameter is passed all schemas but meta-schemas are removed.
           * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
           * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
           * @this   Ajv
           * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
           * @return {Ajv} this for method chaining
           */ function removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
              _removeAllSchemas(this, this._schemas, schemaKeyRef);
              _removeAllSchemas(this, this._refs, schemaKeyRef);
              return this;
            }
            switch (_typeof2(schemaKeyRef)) {
              case "undefined":
                _removeAllSchemas(this, this._schemas);
                _removeAllSchemas(this, this._refs);
                this._cache.clear();
                return this;
              case "string":
                var schemaObj = _getSchemaObj(this, schemaKeyRef);
                if (schemaObj) this._cache.del(schemaObj.cacheKey);
                delete this._schemas[schemaKeyRef];
                delete this._refs[schemaKeyRef];
                return this;
              case "object":
                var serialize = this._opts.serialize;
                var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
                this._cache.del(cacheKey);
                var id = this._getId(schemaKeyRef);
                if (id) {
                  id = resolve.normalizeId(id);
                  delete this._schemas[id];
                  delete this._refs[id];
                }
            }
            return this;
          }
          function _removeAllSchemas(self, schemas, regex) {
            for (var keyRef in schemas) {
              var schemaObj = schemas[keyRef];
              if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
                self._cache.del(schemaObj.cacheKey);
                delete schemas[keyRef];
              }
            }
          }
          /* @this   Ajv */ function _addSchema(
            schema,
            skipValidation,
            meta,
            shouldAddSchema
          ) {
            if (_typeof2(schema) != "object" && typeof schema != "boolean")
              throw new Error("schema should be object or boolean");
            var serialize = this._opts.serialize;
            var cacheKey = serialize ? serialize(schema) : schema;
            var cached = this._cache.get(cacheKey);
            if (cached) return cached;
            shouldAddSchema =
              shouldAddSchema || this._opts.addUsedSchema !== false;
            var id = resolve.normalizeId(this._getId(schema));
            if (id && shouldAddSchema) checkUnique(this, id);
            var willValidate =
              this._opts.validateSchema !== false && !skipValidation;
            var recursiveMeta;
            if (
              willValidate &&
              !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))
            )
              this.validateSchema(schema, true);
            var localRefs = resolve.ids.call(this, schema);
            var schemaObj = new SchemaObject({
              id: id,
              schema: schema,
              localRefs: localRefs,
              cacheKey: cacheKey,
              meta: meta
            });
            if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
            this._cache.put(cacheKey, schemaObj);
            if (willValidate && recursiveMeta) this.validateSchema(schema, true);
            return schemaObj;
          }
          /* @this   Ajv */ function _compile(schemaObj, root) {
            if (schemaObj.compiling) {
              schemaObj.validate = callValidate;
              callValidate.schema = schemaObj.schema;
              callValidate.errors = null;
              callValidate.root = root ? root : callValidate;
              if (schemaObj.schema.$async === true) callValidate.$async = true;
              return callValidate;
            }
            schemaObj.compiling = true;
            var currentOpts;
            if (schemaObj.meta) {
              currentOpts = this._opts;
              this._opts = this._metaOpts;
            }
            var v;
            try {
              v = compileSchema.call(
                this,
                schemaObj.schema,
                root,
                schemaObj.localRefs
              );
            } catch (e) {
              delete schemaObj.validate;
              throw e;
            } finally {
              schemaObj.compiling = false;
              if (schemaObj.meta) this._opts = currentOpts;
            }
            schemaObj.validate = v;
            schemaObj.refs = v.refs;
            schemaObj.refVal = v.refVal;
            schemaObj.root = v.root;
            return v;
            /* @this   {*} - custom context, see passContext option */ function callValidate() {
              /* jshint validthis: true */ var _validate = schemaObj.validate;
              var result = _validate.apply(this, arguments);
              callValidate.errors = _validate.errors;
              return result;
            }
          }
          function chooseGetId(opts) {
            switch (opts.schemaId) {
              case "auto":
                return _get$IdOrId;
              case "id":
                return _getId;
              default:
                return _get$Id;
            }
          }
          /* @this   Ajv */ function _getId(schema) {
            if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
            return schema.id;
          }
          /* @this   Ajv */ function _get$Id(schema) {
            if (schema.id) this.logger.warn("schema id ignored", schema.id);
            return schema.$id;
          }
          function _get$IdOrId(schema) {
            if (schema.$id && schema.id && schema.$id != schema.id)
              throw new Error("schema $id is different from id");
            return schema.$id || schema.id;
          }
          /**
           * Convert array of error message objects to string
           * @this   Ajv
           * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
           * @param  {Object} options optional options with properties `separator` and `dataVar`.
           * @return {String} human readable string with all errors descriptions
           */ function errorsText(errors, options) {
            errors = errors || this.errors;
            if (!errors) return "No errors";
            options = options || {};
            var separator =
              options.separator === undefined ? ", " : options.separator;
            var dataVar =
              options.dataVar === undefined ? "data" : options.dataVar;
            var text = "";
            for (var i = 0; i < errors.length; i++) {
              var e = errors[i];
              if (e) text += dataVar + e.dataPath + " " + e.message + separator;
            }
            return text.slice(0, -separator.length);
          }
          /**
           * Add custom format
           * @this   Ajv
           * @param {String} name format name
           * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
           * @return {Ajv} this for method chaining
           */ function addFormat(name, format) {
            if (typeof format == "string") format = new RegExp(format);
            this._formats[name] = format;
            return this;
          }
          function addDefaultMetaSchema(self) {
            var $dataSchema;
            if (self._opts.$data) {
              $dataSchema = require("./refs/data.json");
              self.addMetaSchema($dataSchema, $dataSchema.$id, true);
            }
            if (self._opts.meta === false) return;
            var metaSchema = require("./refs/json-schema-draft-07.json");
            if (self._opts.$data)
              metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
            self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
            self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
          }
          function addInitialSchemas(self) {
            var optsSchemas = self._opts.schemas;
            if (!optsSchemas) return;
            if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
            else
              for (var key in optsSchemas) {
                self.addSchema(optsSchemas[key], key);
              }
          }
          function addInitialFormats(self) {
            for (var name in self._opts.formats) {
              var format = self._opts.formats[name];
              self.addFormat(name, format);
            }
          }
          function addInitialKeywords(self) {
            for (var name in self._opts.keywords) {
              var keyword = self._opts.keywords[name];
              self.addKeyword(name, keyword);
            }
          }
          function checkUnique(self, id) {
            if (self._schemas[id] || self._refs[id])
              throw new Error(
                'schema with key or id "' + id + '" already exists'
              );
          }
          function getMetaSchemaOptions(self) {
            var metaOpts = util.copy(self._opts);
            for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) {
              delete metaOpts[META_IGNORE_OPTIONS[i]];
            }
            return metaOpts;
          }
          function setLogger(self) {
            var logger = self._opts.logger;
            if (logger === false) {
              self.logger = { log: noop, warn: noop, error: noop };
            } else {
              if (logger === undefined) logger = console;
              if (
                !(
                  _typeof2(logger) == "object" &&
                  logger.log &&
                  logger.warn &&
                  logger.error
                )
              )
                throw new Error(
                  "logger must implement log, warn and error methods"
                );
              self.logger = logger;
            }
          }
          function noop() {}
        },
        {
          "./cache": 110,
          "./compile": 114,
          "./compile/async": 111,
          "./compile/error_classes": 112,
          "./compile/formats": 113,
          "./compile/resolve": 115,
          "./compile/rules": 116,
          "./compile/schema_obj": 117,
          "./compile/util": 119,
          "./data": 120,
          "./keyword": 148,
          "./refs/data.json": 149,
          "./refs/json-schema-draft-07.json": 151,
          "fast-json-stable-stringify": 154
        }
      ],
      110: [
        function (require, module, exports) {
          "use strict";
          var Cache = (module.exports = function Cache() {
            this._cache = {};
          });
          Cache.prototype.put = function Cache_put(key, value) {
            this._cache[key] = value;
          };
          Cache.prototype.get = function Cache_get(key) {
            return this._cache[key];
          };
          Cache.prototype.del = function Cache_del(key) {
            delete this._cache[key];
          };
          Cache.prototype.clear = function Cache_clear() {
            this._cache = {};
          };
        },
        {}
      ],
      111: [
        function (require, module, exports) {
          "use strict";
          var MissingRefError = require("./error_classes").MissingRef;
          module.exports = compileAsync;
          /**
           * Creates validating function for passed schema with asynchronous loading of missing schemas.
           * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
           * @this  Ajv
           * @param {Object}   schema schema object
           * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
           * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
           * @return {Promise} promise that resolves with a validating function.
           */ function compileAsync(schema, meta, callback) {
            /* eslint no-shadow: 0 */ /* global Promise */ /* jshint validthis: true */ var self =
              this;
            if (typeof this._opts.loadSchema != "function")
              throw new Error("options.loadSchema should be a function");
            if (typeof meta == "function") {
              callback = meta;
              meta = undefined;
            }
            var p = loadMetaSchemaOf(schema).then(function () {
              var schemaObj = self._addSchema(schema, undefined, meta);
              return schemaObj.validate || _compileAsync(schemaObj);
            });
            if (callback) {
              p.then(function (v) {
                callback(null, v);
              }, callback);
            }
            return p;
            function loadMetaSchemaOf(sch) {
              var $schema = sch.$schema;
              return $schema && !self.getSchema($schema)
                ? compileAsync.call(self, { $ref: $schema }, true)
                : Promise.resolve();
            }
            function _compileAsync(schemaObj) {
              try {
                return self._compile(schemaObj);
              } catch (e) {
                if (e instanceof MissingRefError) return loadMissingSchema(e);
                throw e;
              }
              function loadMissingSchema(e) {
                var ref = e.missingSchema;
                if (added(ref))
                  throw new Error(
                    "Schema " +
                      ref +
                      " is loaded but " +
                      e.missingRef +
                      " cannot be resolved"
                  );
                var schemaPromise = self._loadingSchemas[ref];
                if (!schemaPromise) {
                  schemaPromise = self._loadingSchemas[ref] =
                    self._opts.loadSchema(ref);
                  schemaPromise.then(removePromise, removePromise);
                }
                return schemaPromise
                  .then(function (sch) {
                    if (!added(ref)) {
                      return loadMetaSchemaOf(sch).then(function () {
                        if (!added(ref))
                          self.addSchema(sch, ref, undefined, meta);
                      });
                    }
                  })
                  .then(function () {
                    return _compileAsync(schemaObj);
                  });
                function removePromise() {
                  delete self._loadingSchemas[ref];
                }
                function added(ref) {
                  return self._refs[ref] || self._schemas[ref];
                }
              }
            }
          }
        },
        { "./error_classes": 112 }
      ],
      112: [
        function (require, module, exports) {
          "use strict";
          var resolve = require("./resolve");
          module.exports = {
            Validation: errorSubclass(ValidationError),
            MissingRef: errorSubclass(MissingRefError)
          };
          function ValidationError(errors) {
            this.message = "validation failed";
            this.errors = errors;
            this.ajv = this.validation = true;
          }
          MissingRefError.message = function (baseId, ref) {
            return "can't resolve reference " + ref + " from id " + baseId;
          };
          function MissingRefError(baseId, ref, message) {
            this.message = message || MissingRefError.message(baseId, ref);
            this.missingRef = resolve.url(baseId, ref);
            this.missingSchema = resolve.normalizeId(
              resolve.fullPath(this.missingRef)
            );
          }
          function errorSubclass(Subclass) {
            Subclass.prototype = Object.create(Error.prototype);
            Subclass.prototype.constructor = Subclass;
            return Subclass;
          }
        },
        { "./resolve": 115 }
      ],
      113: [
        function (require, module, exports) {
          "use strict";
          var util = require("./util");
          var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
          var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
          var HOSTNAME =
            /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
          var URI =
            /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
          var URIREF =
            /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i; // uri-template: https://tools.ietf.org/html/rfc6570
          var URITEMPLATE =
            /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i; // For the source: https://gist.github.com/dperini/729294
          // For test cases: https://mathiasbynens.be/demo/url-regex
          // @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
          // var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
          var URL =
            /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
          var UUID =
            /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
          var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
          var JSON_POINTER_URI_FRAGMENT =
            /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
          var RELATIVE_JSON_POINTER =
            /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
          module.exports = formats;
          function formats(mode) {
            mode = mode == "full" ? "full" : "fast";
            return util.copy(formats[mode]);
          }
          formats.fast = {
            // date: http://tools.ietf.org/html/rfc3339#section-5.6
            date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/, // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
            time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
            "date-time":
              /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
            uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
            "uri-reference":
              /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
            "uri-template": URITEMPLATE,
            url: URL, // email (sources from jsen validator):
            // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
            // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
            email:
              /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
            hostname: HOSTNAME, // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
            ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
            ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
            regex: regex, // uuid: http://tools.ietf.org/html/rfc4122
            uuid: UUID, // JSON-pointer: https://tools.ietf.org/html/rfc6901
            // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
            "json-pointer": JSON_POINTER,
            "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT, // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
            "relative-json-pointer": RELATIVE_JSON_POINTER
          };
          formats.full = {
            date: date,
            time: time,
            "date-time": date_time,
            uri: uri,
            "uri-reference": URIREF,
            "uri-template": URITEMPLATE,
            url: URL,
            email:
              /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
            hostname: HOSTNAME,
            ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
            ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
            regex: regex,
            uuid: UUID,
            "json-pointer": JSON_POINTER,
            "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
            "relative-json-pointer": RELATIVE_JSON_POINTER
          };
          function isLeapYear(year) {
            // https://tools.ietf.org/html/rfc3339#appendix-C
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function date(str) {
            // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
            var matches = str.match(DATE);
            if (!matches) return false;
            var year = +matches[1];
            var month = +matches[2];
            var day = +matches[3];
            return (
              month >= 1 &&
              month <= 12 &&
              day >= 1 &&
              day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month])
            );
          }
          function time(str, full) {
            var matches = str.match(TIME);
            if (!matches) return false;
            var hour = matches[1];
            var minute = matches[2];
            var second = matches[3];
            var timeZone = matches[5];
            return (
              ((hour <= 23 && minute <= 59 && second <= 59) ||
                (hour == 23 && minute == 59 && second == 60)) &&
              (!full || timeZone)
            );
          }
          var DATE_TIME_SEPARATOR = /t|\s/i;
          function date_time(str) {
            // http://tools.ietf.org/html/rfc3339#section-5.6
            var dateTime = str.split(DATE_TIME_SEPARATOR);
            return (
              dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true)
            );
          }
          var NOT_URI_FRAGMENT = /\/|:/;
          function uri(str) {
            // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
            return NOT_URI_FRAGMENT.test(str) && URI.test(str);
          }
          var Z_ANCHOR = /[^\\]\\Z/;
          function regex(str) {
            if (Z_ANCHOR.test(str)) return false;
            try {
              new RegExp(str);
              return true;
            } catch (e) {
              return false;
            }
          }
        },
        { "./util": 119 }
      ],
      114: [
        function (require, module, exports) {
          "use strict";
          var resolve = require("./resolve"),
            util = require("./util"),
            errorClasses = require("./error_classes"),
            stableStringify = require("fast-json-stable-stringify");
          var validateGenerator = require("../dotjs/validate");
          /**
           * Functions below are used inside compiled validations function
           */ var ucs2length = util.ucs2length;
          var equal = require("fast-deep-equal"); // this error is thrown by async schemas to return validation errors via exception
          var ValidationError = errorClasses.Validation;
          module.exports = compile;
          /**
           * Compiles schema to validation function
           * @this   Ajv
           * @param  {Object} schema schema object
           * @param  {Object} root object with information about the root schema for this schema
           * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
           * @param  {String} baseId base ID for IDs in the schema
           * @return {Function} validation function
           */ function compile(schema, root, localRefs, baseId) {
            /* jshint validthis: true, evil: true */ /* eslint no-shadow: 0 */ var self =
                this,
              opts = this._opts,
              refVal = [undefined],
              refs = {},
              patterns = [],
              patternsHash = {},
              defaults = [],
              defaultsHash = {},
              customRules = [];
            root = root || { schema: schema, refVal: refVal, refs: refs };
            var c = checkCompiling.call(this, schema, root, baseId);
            var compilation = this._compilations[c.index];
            if (c.compiling) return (compilation.callValidate = callValidate);
            var formats = this._formats;
            var RULES = this.RULES;
            try {
              var v = localCompile(schema, root, localRefs, baseId);
              compilation.validate = v;
              var cv = compilation.callValidate;
              if (cv) {
                cv.schema = v.schema;
                cv.errors = null;
                cv.refs = v.refs;
                cv.refVal = v.refVal;
                cv.root = v.root;
                cv.$async = v.$async;
                if (opts.sourceCode) cv.source = v.source;
              }
              return v;
            } finally {
              endCompiling.call(this, schema, root, baseId);
            }
            /* @this   {*} - custom context, see passContext option */ function callValidate() {
              /* jshint validthis: true */ var validate = compilation.validate;
              var result = validate.apply(this, arguments);
              callValidate.errors = validate.errors;
              return result;
            }
            function localCompile(_schema, _root, localRefs, baseId) {
              var isRoot = !_root || (_root && _root.schema == _schema);
              if (_root.schema != root.schema)
                return compile.call(self, _schema, _root, localRefs, baseId);
              var $async = _schema.$async === true;
              var sourceCode = validateGenerator({
                isTop: true,
                schema: _schema,
                isRoot: isRoot,
                baseId: baseId,
                root: _root,
                schemaPath: "",
                errSchemaPath: "#",
                errorPath: '""',
                MissingRefError: errorClasses.MissingRef,
                RULES: RULES,
                validate: validateGenerator,
                util: util,
                resolve: resolve,
                resolveRef: resolveRef,
                usePattern: usePattern,
                useDefault: useDefault,
                useCustomRule: useCustomRule,
                opts: opts,
                formats: formats,
                logger: self.logger,
                self: self
              });
              sourceCode =
                vars(refVal, refValCode) +
                vars(patterns, patternCode) +
                vars(defaults, defaultCode) +
                vars(customRules, customRuleCode) +
                sourceCode;
              if (opts.processCode)
                sourceCode = opts.processCode(sourceCode, _schema); // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
              var validate;
              try {
                var makeValidate = new Function(
                  "self",
                  "RULES",
                  "formats",
                  "root",
                  "refVal",
                  "defaults",
                  "customRules",
                  "equal",
                  "ucs2length",
                  "ValidationError",
                  sourceCode
                );
                validate = makeValidate(
                  self,
                  RULES,
                  formats,
                  root,
                  refVal,
                  defaults,
                  customRules,
                  equal,
                  ucs2length,
                  ValidationError
                );
                refVal[0] = validate;
              } catch (e) {
                self.logger.error(
                  "Error compiling schema, function code:",
                  sourceCode
                );
                throw e;
              }
              validate.schema = _schema;
              validate.errors = null;
              validate.refs = refs;
              validate.refVal = refVal;
              validate.root = isRoot ? validate : _root;
              if ($async) validate.$async = true;
              if (opts.sourceCode === true) {
                validate.source = {
                  code: sourceCode,
                  patterns: patterns,
                  defaults: defaults
                };
              }
              return validate;
            }
            function resolveRef(baseId, ref, isRoot) {
              ref = resolve.url(baseId, ref);
              var refIndex = refs[ref];
              var _refVal, refCode;
              if (refIndex !== undefined) {
                _refVal = refVal[refIndex];
                refCode = "refVal[" + refIndex + "]";
                return resolvedRef(_refVal, refCode);
              }
              if (!isRoot && root.refs) {
                var rootRefId = root.refs[ref];
                if (rootRefId !== undefined) {
                  _refVal = root.refVal[rootRefId];
                  refCode = addLocalRef(ref, _refVal);
                  return resolvedRef(_refVal, refCode);
                }
              }
              refCode = addLocalRef(ref);
              var v = resolve.call(self, localCompile, root, ref);
              if (v === undefined) {
                var localSchema = localRefs && localRefs[ref];
                if (localSchema) {
                  v = resolve.inlineRef(localSchema, opts.inlineRefs)
                    ? localSchema
                    : compile.call(self, localSchema, root, localRefs, baseId);
                }
              }
              if (v === undefined) {
                removeLocalRef(ref);
              } else {
                replaceLocalRef(ref, v);
                return resolvedRef(v, refCode);
              }
            }
            function addLocalRef(ref, v) {
              var refId = refVal.length;
              refVal[refId] = v;
              refs[ref] = refId;
              return "refVal" + refId;
            }
            function removeLocalRef(ref) {
              delete refs[ref];
            }
            function replaceLocalRef(ref, v) {
              var refId = refs[ref];
              refVal[refId] = v;
            }
            function resolvedRef(refVal, code) {
              return _typeof2(refVal) == "object" || typeof refVal == "boolean"
                ? { code: code, schema: refVal, inline: true }
                : { code: code, $async: refVal && !!refVal.$async };
            }
            function usePattern(regexStr) {
              var index = patternsHash[regexStr];
              if (index === undefined) {
                index = patternsHash[regexStr] = patterns.length;
                patterns[index] = regexStr;
              }
              return "pattern" + index;
            }
            function useDefault(value) {
              switch (_typeof2(value)) {
                case "boolean":
                case "number":
                  return "" + value;
                case "string":
                  return util.toQuotedString(value);
                case "object":
                  if (value === null) return "null";
                  var valueStr = stableStringify(value);
                  var index = defaultsHash[valueStr];
                  if (index === undefined) {
                    index = defaultsHash[valueStr] = defaults.length;
                    defaults[index] = value;
                  }
                  return "default" + index;
              }
            }
            function useCustomRule(rule, schema, parentSchema, it) {
              if (self._opts.validateSchema !== false) {
                var deps = rule.definition.dependencies;
                if (
                  deps &&
                  !deps.every(function (keyword) {
                    return Object.prototype.hasOwnProperty.call(
                      parentSchema,
                      keyword
                    );
                  })
                )
                  throw new Error(
                    "parent schema must have all required keywords: " +
                      deps.join(",")
                  );
                var validateSchema = rule.definition.validateSchema;
                if (validateSchema) {
                  var valid = validateSchema(schema);
                  if (!valid) {
                    var message =
                      "keyword schema is invalid: " +
                      self.errorsText(validateSchema.errors);
                    if (self._opts.validateSchema == "log")
                      self.logger.error(message);
                    else throw new Error(message);
                  }
                }
              }
              var compile = rule.definition.compile,
                inline = rule.definition.inline,
                macro = rule.definition.macro;
              var validate;
              if (compile) {
                validate = compile.call(self, schema, parentSchema, it);
              } else if (macro) {
                validate = macro.call(self, schema, parentSchema, it);
                if (opts.validateSchema !== false)
                  self.validateSchema(validate, true);
              } else if (inline) {
                validate = inline.call(
                  self,
                  it,
                  rule.keyword,
                  schema,
                  parentSchema
                );
              } else {
                validate = rule.definition.validate;
                if (!validate) return;
              }
              if (validate === undefined)
                throw new Error(
                  'custom keyword "' + rule.keyword + '"failed to compile'
                );
              var index = customRules.length;
              customRules[index] = validate;
              return { code: "customRule" + index, validate: validate };
            }
          }
          /**
           * Checks if the schema is currently compiled
           * @this   Ajv
           * @param  {Object} schema schema to compile
           * @param  {Object} root root object
           * @param  {String} baseId base schema ID
           * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
           */ function checkCompiling(schema, root, baseId) {
            /* jshint validthis: true */ var index = compIndex.call(
              this,
              schema,
              root,
              baseId
            );
            if (index >= 0) return { index: index, compiling: true };
            index = this._compilations.length;
            this._compilations[index] = {
              schema: schema,
              root: root,
              baseId: baseId
            };
            return { index: index, compiling: false };
          }
          /**
           * Removes the schema from the currently compiled list
           * @this   Ajv
           * @param  {Object} schema schema to compile
           * @param  {Object} root root object
           * @param  {String} baseId base schema ID
           */ function endCompiling(schema, root, baseId) {
            /* jshint validthis: true */ var i = compIndex.call(
              this,
              schema,
              root,
              baseId
            );
            if (i >= 0) this._compilations.splice(i, 1);
          }
          /**
           * Index of schema compilation in the currently compiled list
           * @this   Ajv
           * @param  {Object} schema schema to compile
           * @param  {Object} root root object
           * @param  {String} baseId base schema ID
           * @return {Integer} compilation index
           */ function compIndex(schema, root, baseId) {
            /* jshint validthis: true */ for (
              var i = 0;
              i < this._compilations.length;
              i++
            ) {
              var c = this._compilations[i];
              if (c.schema == schema && c.root == root && c.baseId == baseId)
                return i;
            }
            return -1;
          }
          function patternCode(i, patterns) {
            return (
              "var pattern" +
              i +
              " = new RegExp(" +
              util.toQuotedString(patterns[i]) +
              ");"
            );
          }
          function defaultCode(i) {
            return "var default" + i + " = defaults[" + i + "];";
          }
          function refValCode(i, refVal) {
            return refVal[i] === undefined
              ? ""
              : "var refVal" + i + " = refVal[" + i + "];";
          }
          function customRuleCode(i) {
            return "var customRule" + i + " = customRules[" + i + "];";
          }
          function vars(arr, statement) {
            if (!arr.length) return "";
            var code = "";
            for (var i = 0; i < arr.length; i++) {
              code += statement(i, arr);
            }
            return code;
          }
        },
        {
          "../dotjs/validate": 147,
          "./error_classes": 112,
          "./resolve": 115,
          "./util": 119,
          "fast-deep-equal": 153,
          "fast-json-stable-stringify": 154
        }
      ],
      115: [
        function (require, module, exports) {
          "use strict";
          var URI = require("uri-js"),
            equal = require("fast-deep-equal"),
            util = require("./util"),
            SchemaObject = require("./schema_obj"),
            traverse = require("json-schema-traverse");
          module.exports = resolve;
          resolve.normalizeId = normalizeId;
          resolve.fullPath = getFullPath;
          resolve.url = resolveUrl;
          resolve.ids = resolveIds;
          resolve.inlineRef = inlineRef;
          resolve.schema = resolveSchema;
          /**
           * [resolve and compile the references ($ref)]
           * @this   Ajv
           * @param  {Function} compile reference to schema compilation funciton (localCompile)
           * @param  {Object} root object with information about the root schema for the current schema
           * @param  {String} ref reference to resolve
           * @return {Object|Function} schema object (if the schema can be inlined) or validation function
           */ function resolve(compile, root, ref) {
            /* jshint validthis: true */ var refVal = this._refs[ref];
            if (typeof refVal == "string") {
              if (this._refs[refVal]) refVal = this._refs[refVal];
              else return resolve.call(this, compile, root, refVal);
            }
            refVal = refVal || this._schemas[ref];
            if (refVal instanceof SchemaObject) {
              return inlineRef(refVal.schema, this._opts.inlineRefs)
                ? refVal.schema
                : refVal.validate || this._compile(refVal);
            }
            var res = resolveSchema.call(this, root, ref);
            var schema, v, baseId;
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
            if (schema instanceof SchemaObject) {
              v =
                schema.validate ||
                compile.call(this, schema.schema, root, undefined, baseId);
            } else if (schema !== undefined) {
              v = inlineRef(schema, this._opts.inlineRefs)
                ? schema
                : compile.call(this, schema, root, undefined, baseId);
            }
            return v;
          }
          /**
           * Resolve schema, its root and baseId
           * @this Ajv
           * @param  {Object} root root object with properties schema, refVal, refs
           * @param  {String} ref  reference to resolve
           * @return {Object} object with properties schema, root, baseId
           */ function resolveSchema(root, ref) {
            /* jshint validthis: true */ var p = URI.parse(ref),
              refPath = _getFullPath(p),
              baseId = getFullPath(this._getId(root.schema));
            if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
              var id = normalizeId(refPath);
              var refVal = this._refs[id];
              if (typeof refVal == "string") {
                return resolveRecursive.call(this, root, refVal, p);
              } else if (refVal instanceof SchemaObject) {
                if (!refVal.validate) this._compile(refVal);
                root = refVal;
              } else {
                refVal = this._schemas[id];
                if (refVal instanceof SchemaObject) {
                  if (!refVal.validate) this._compile(refVal);
                  if (id == normalizeId(ref))
                    return { schema: refVal, root: root, baseId: baseId };
                  root = refVal;
                } else {
                  return;
                }
              }
              if (!root.schema) return;
              baseId = getFullPath(this._getId(root.schema));
            }
            return getJsonPointer.call(this, p, baseId, root.schema, root);
          }
          /* @this Ajv */ function resolveRecursive(root, ref, parsedRef) {
            /* jshint validthis: true */ var res = resolveSchema.call(
              this,
              root,
              ref
            );
            if (res) {
              var schema = res.schema;
              var baseId = res.baseId;
              root = res.root;
              var id = this._getId(schema);
              if (id) baseId = resolveUrl(baseId, id);
              return getJsonPointer.call(this, parsedRef, baseId, schema, root);
            }
          }
          var PREVENT_SCOPE_CHANGE = util.toHash([
            "properties",
            "patternProperties",
            "enum",
            "dependencies",
            "definitions"
          ]);
          /* @this Ajv */ function getJsonPointer(
            parsedRef,
            baseId,
            schema,
            root
          ) {
            /* jshint validthis: true */ parsedRef.fragment =
              parsedRef.fragment || "";
            if (parsedRef.fragment.slice(0, 1) != "/") return;
            var parts = parsedRef.fragment.split("/");
            for (var i = 1; i < parts.length; i++) {
              var part = parts[i];
              if (part) {
                part = util.unescapeFragment(part);
                schema = schema[part];
                if (schema === undefined) break;
                var id;
                if (!PREVENT_SCOPE_CHANGE[part]) {
                  id = this._getId(schema);
                  if (id) baseId = resolveUrl(baseId, id);
                  if (schema.$ref) {
                    var $ref = resolveUrl(baseId, schema.$ref);
                    var res = resolveSchema.call(this, root, $ref);
                    if (res) {
                      schema = res.schema;
                      root = res.root;
                      baseId = res.baseId;
                    }
                  }
                }
              }
            }
            if (schema !== undefined && schema !== root.schema)
              return { schema: schema, root: root, baseId: baseId };
          }
          var SIMPLE_INLINED = util.toHash([
            "type",
            "format",
            "pattern",
            "maxLength",
            "minLength",
            "maxProperties",
            "minProperties",
            "maxItems",
            "minItems",
            "maximum",
            "minimum",
            "uniqueItems",
            "multipleOf",
            "required",
            "enum"
          ]);
          function inlineRef(schema, limit) {
            if (limit === false) return false;
            if (limit === undefined || limit === true) return checkNoRef(schema);
            else if (limit) return countKeys(schema) <= limit;
          }
          function checkNoRef(schema) {
            var item;
            if (Array.isArray(schema)) {
              for (var i = 0; i < schema.length; i++) {
                item = schema[i];
                if (_typeof2(item) == "object" && !checkNoRef(item)) return false;
              }
            } else {
              for (var key in schema) {
                if (key == "$ref") return false;
                item = schema[key];
                if (_typeof2(item) == "object" && !checkNoRef(item)) return false;
              }
            }
            return true;
          }
          function countKeys(schema) {
            var count = 0,
              item;
            if (Array.isArray(schema)) {
              for (var i = 0; i < schema.length; i++) {
                item = schema[i];
                if (_typeof2(item) == "object") count += countKeys(item);
                if (count == Infinity) return Infinity;
              }
            } else {
              for (var key in schema) {
                if (key == "$ref") return Infinity;
                if (SIMPLE_INLINED[key]) {
                  count++;
                } else {
                  item = schema[key];
                  if (_typeof2(item) == "object") count += countKeys(item) + 1;
                  if (count == Infinity) return Infinity;
                }
              }
            }
            return count;
          }
          function getFullPath(id, normalize) {
            if (normalize !== false) id = normalizeId(id);
            var p = URI.parse(id);
            return _getFullPath(p);
          }
          function _getFullPath(p) {
            return URI.serialize(p).split("#")[0] + "#";
          }
          var TRAILING_SLASH_HASH = /#\/?$/;
          function normalizeId(id) {
            return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
          }
          function resolveUrl(baseId, id) {
            id = normalizeId(id);
            return URI.resolve(baseId, id);
          }
          /* @this Ajv */ function resolveIds(schema) {
            var schemaId = normalizeId(this._getId(schema));
            var baseIds = { "": schemaId };
            var fullPaths = { "": getFullPath(schemaId, false) };
            var localRefs = {};
            var self = this;
            traverse(
              schema,
              { allKeys: true },
              function (
                sch,
                jsonPtr,
                rootSchema,
                parentJsonPtr,
                parentKeyword,
                parentSchema,
                keyIndex
              ) {
                if (jsonPtr === "") return;
                var id = self._getId(sch);
                var baseId = baseIds[parentJsonPtr];
                var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
                if (keyIndex !== undefined)
                  fullPath +=
                    "/" +
                    (typeof keyIndex == "number"
                      ? keyIndex
                      : util.escapeFragment(keyIndex));
                if (typeof id == "string") {
                  id = baseId = normalizeId(
                    baseId ? URI.resolve(baseId, id) : id
                  );
                  var refVal = self._refs[id];
                  if (typeof refVal == "string") refVal = self._refs[refVal];
                  if (refVal && refVal.schema) {
                    if (!equal(sch, refVal.schema))
                      throw new Error(
                        'id "' + id + '" resolves to more than one schema'
                      );
                  } else if (id != normalizeId(fullPath)) {
                    if (id[0] == "#") {
                      if (localRefs[id] && !equal(sch, localRefs[id]))
                        throw new Error(
                          'id "' + id + '" resolves to more than one schema'
                        );
                      localRefs[id] = sch;
                    } else {
                      self._refs[id] = fullPath;
                    }
                  }
                }
                baseIds[jsonPtr] = baseId;
                fullPaths[jsonPtr] = fullPath;
              }
            );
            return localRefs;
          }
        },
        {
          "./schema_obj": 117,
          "./util": 119,
          "fast-deep-equal": 153,
          "json-schema-traverse": 185,
          "uri-js": 189
        }
      ],
      116: [
        function (require, module, exports) {
          "use strict";
          var ruleModules = require("../dotjs"),
            toHash = require("./util").toHash;
          module.exports = function rules() {
            var RULES = [
              {
                type: "number",
                rules: [
                  { maximum: ["exclusiveMaximum"] },
                  { minimum: ["exclusiveMinimum"] },
                  "multipleOf",
                  "format"
                ]
              },
              {
                type: "string",
                rules: ["maxLength", "minLength", "pattern", "format"]
              },
              {
                type: "array",
                rules: [
                  "maxItems",
                  "minItems",
                  "items",
                  "contains",
                  "uniqueItems"
                ]
              },
              {
                type: "object",
                rules: [
                  "maxProperties",
                  "minProperties",
                  "required",
                  "dependencies",
                  "propertyNames",
                  { properties: ["additionalProperties", "patternProperties"] }
                ]
              },
              {
                rules: [
                  "$ref",
                  "const",
                  "enum",
                  "not",
                  "anyOf",
                  "oneOf",
                  "allOf",
                  "if"
                ]
              }
            ];
            var ALL = ["type", "$comment"];
            var KEYWORDS = [
              "$schema",
              "$id",
              "id",
              "$data",
              "$async",
              "title",
              "description",
              "default",
              "definitions",
              "examples",
              "readOnly",
              "writeOnly",
              "contentMediaType",
              "contentEncoding",
              "additionalItems",
              "then",
              "else"
            ];
            var TYPES = [
              "number",
              "integer",
              "string",
              "array",
              "object",
              "boolean",
              "null"
            ];
            RULES.all = toHash(ALL);
            RULES.types = toHash(TYPES);
            RULES.forEach(function (group) {
              group.rules = group.rules.map(function (keyword) {
                var implKeywords;
                if (_typeof2(keyword) == "object") {
                  var key = Object.keys(keyword)[0];
                  implKeywords = keyword[key];
                  keyword = key;
                  implKeywords.forEach(function (k) {
                    ALL.push(k);
                    RULES.all[k] = true;
                  });
                }
                ALL.push(keyword);
                var rule = (RULES.all[keyword] = {
                  keyword: keyword,
                  code: ruleModules[keyword],
                  implements: implKeywords
                });
                return rule;
              });
              RULES.all.$comment = {
                keyword: "$comment",
                code: ruleModules.$comment
              };
              if (group.type) RULES.types[group.type] = group;
            });
            RULES.keywords = toHash(ALL.concat(KEYWORDS));
            RULES.custom = {};
            return RULES;
          };
        },
        { "../dotjs": 136, "./util": 119 }
      ],
      117: [
        function (require, module, exports) {
          "use strict";
          var util = require("./util");
          module.exports = SchemaObject;
          function SchemaObject(obj) {
            util.copy(obj, this);
          }
        },
        { "./util": 119 }
      ],
      118: [
        function (require, module, exports) {
          "use strict"; // https://mathiasbynens.be/notes/javascript-encoding
          // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
          module.exports = function ucs2length(str) {
            var length = 0,
              len = str.length,
              pos = 0,
              value;
            while (pos < len) {
              length++;
              value = str.charCodeAt(pos++);
              if (value >= 0xd800 && value <= 0xdbff && pos < len) {
                // high surrogate, and there is a next character
                value = str.charCodeAt(pos);
                if ((value & 0xfc00) == 0xdc00) pos++; // low surrogate
              }
            }
            return length;
          };
        },
        {}
      ],
      119: [
        function (require, module, exports) {
          "use strict";
          module.exports = {
            copy: copy,
            checkDataType: checkDataType,
            checkDataTypes: checkDataTypes,
            coerceToTypes: coerceToTypes,
            toHash: toHash,
            getProperty: getProperty,
            escapeQuotes: escapeQuotes,
            equal: require("fast-deep-equal"),
            ucs2length: require("./ucs2length"),
            varOccurences: varOccurences,
            varReplace: varReplace,
            schemaHasRules: schemaHasRules,
            schemaHasRulesExcept: schemaHasRulesExcept,
            schemaUnknownRules: schemaUnknownRules,
            toQuotedString: toQuotedString,
            getPathExpr: getPathExpr,
            getPath: getPath,
            getData: getData,
            unescapeFragment: unescapeFragment,
            unescapeJsonPointer: unescapeJsonPointer,
            escapeFragment: escapeFragment,
            escapeJsonPointer: escapeJsonPointer
          };
          function copy(o, to) {
            to = to || {};
            for (var key in o) {
              to[key] = o[key];
            }
            return to;
          }
          function checkDataType(dataType, data, strictNumbers, negate) {
            var EQUAL = negate ? " !== " : " === ",
              AND = negate ? " || " : " && ",
              OK = negate ? "!" : "",
              NOT = negate ? "" : "!";
            switch (dataType) {
              case "null":
                return data + EQUAL + "null";
              case "array":
                return OK + "Array.isArray(" + data + ")";
              case "object":
                return (
                  "(" +
                  OK +
                  data +
                  AND +
                  "typeof " +
                  data +
                  EQUAL +
                  '"object"' +
                  AND +
                  NOT +
                  "Array.isArray(" +
                  data +
                  "))"
                );
              case "integer":
                return (
                  "(typeof " +
                  data +
                  EQUAL +
                  '"number"' +
                  AND +
                  NOT +
                  "(" +
                  data +
                  " % 1)" +
                  AND +
                  data +
                  EQUAL +
                  data +
                  (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") +
                  ")"
                );
              case "number":
                return (
                  "(typeof " +
                  data +
                  EQUAL +
                  '"' +
                  dataType +
                  '"' +
                  (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") +
                  ")"
                );
              default:
                return "typeof " + data + EQUAL + '"' + dataType + '"';
            }
          }
          function checkDataTypes(dataTypes, data, strictNumbers) {
            switch (dataTypes.length) {
              case 1:
                return checkDataType(dataTypes[0], data, strictNumbers, true);
              default:
                var code = "";
                var types = toHash(dataTypes);
                if (types.array && types.object) {
                  code = types["null"] ? "(" : "(!" + data + " || ";
                  code += "typeof " + data + ' !== "object")';
                  delete types["null"];
                  delete types.array;
                  delete types.object;
                }
                if (types.number) delete types.integer;
                for (var t in types) {
                  code +=
                    (code ? " && " : "") +
                    checkDataType(t, data, strictNumbers, true);
                }
                return code;
            }
          }
          var COERCE_TO_TYPES = toHash([
            "string",
            "number",
            "integer",
            "boolean",
            "null"
          ]);
          function coerceToTypes(optionCoerceTypes, dataTypes) {
            if (Array.isArray(dataTypes)) {
              var types = [];
              for (var i = 0; i < dataTypes.length; i++) {
                var t = dataTypes[i];
                if (COERCE_TO_TYPES[t]) types[types.length] = t;
                else if (optionCoerceTypes === "array" && t === "array")
                  types[types.length] = t;
              }
              if (types.length) return types;
            } else if (COERCE_TO_TYPES[dataTypes]) {
              return [dataTypes];
            } else if (optionCoerceTypes === "array" && dataTypes === "array") {
              return ["array"];
            }
          }
          function toHash(arr) {
            var hash = {};
            for (var i = 0; i < arr.length; i++) {
              hash[arr[i]] = true;
            }
            return hash;
          }
          var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
          var SINGLE_QUOTE = /'|\\/g;
          function getProperty(key) {
            return typeof key == "number"
              ? "[" + key + "]"
              : IDENTIFIER.test(key)
              ? "." + key
              : "['" + escapeQuotes(key) + "']";
          }
          function escapeQuotes(str) {
            return str
              .replace(SINGLE_QUOTE, "\\$&")
              .replace(/\n/g, "\\n")
              .replace(/\r/g, "\\r")
              .replace(/\f/g, "\\f")
              .replace(/\t/g, "\\t");
          }
          function varOccurences(str, dataVar) {
            dataVar += "[^0-9]";
            var matches = str.match(new RegExp(dataVar, "g"));
            return matches ? matches.length : 0;
          }
          function varReplace(str, dataVar, expr) {
            dataVar += "([^0-9])";
            expr = expr.replace(/\$/g, "$$$$");
            return str.replace(new RegExp(dataVar, "g"), expr + "$1");
          }
          function schemaHasRules(schema, rules) {
            if (typeof schema == "boolean") return !schema;
            for (var key in schema) {
              if (rules[key]) return true;
            }
          }
          function schemaHasRulesExcept(schema, rules, exceptKeyword) {
            if (typeof schema == "boolean")
              return !schema && exceptKeyword != "not";
            for (var key in schema) {
              if (key != exceptKeyword && rules[key]) return true;
            }
          }
          function schemaUnknownRules(schema, rules) {
            if (typeof schema == "boolean") return;
            for (var key in schema) {
              if (!rules[key]) return key;
            }
          }
          function toQuotedString(str) {
            return "'" + escapeQuotes(str) + "'";
          }
          function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
            var path = jsonPointers // false by default
              ? "'/' + " +
                expr +
                (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
              : isNumber
              ? "'[' + " + expr + " + ']'"
              : "'[\\'' + " + expr + " + '\\']'";
            return joinPaths(currentPath, path);
          }
          function getPath(currentPath, prop, jsonPointers) {
            var path = jsonPointers // false by default
              ? toQuotedString("/" + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
            return joinPaths(currentPath, path);
          }
          var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
          var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
          function getData($data, lvl, paths) {
            var up, jsonPointer, data, matches;
            if ($data === "") return "rootData";
            if ($data[0] == "/") {
              if (!JSON_POINTER.test($data))
                throw new Error("Invalid JSON-pointer: " + $data);
              jsonPointer = $data;
              data = "rootData";
            } else {
              matches = $data.match(RELATIVE_JSON_POINTER);
              if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
              up = +matches[1];
              jsonPointer = matches[2];
              if (jsonPointer == "#") {
                if (up >= lvl)
                  throw new Error(
                    "Cannot access property/index " +
                      up +
                      " levels up, current level is " +
                      lvl
                  );
                return paths[lvl - up];
              }
              if (up > lvl)
                throw new Error(
                  "Cannot access data " +
                    up +
                    " levels up, current level is " +
                    lvl
                );
              data = "data" + (lvl - up || "");
              if (!jsonPointer) return data;
            }
            var expr = data;
            var segments = jsonPointer.split("/");
            for (var i = 0; i < segments.length; i++) {
              var segment = segments[i];
              if (segment) {
                data += getProperty(unescapeJsonPointer(segment));
                expr += " && " + data;
              }
            }
            return expr;
          }
          function joinPaths(a, b) {
            if (a == '""') return b;
            return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
          }
          function unescapeFragment(str) {
            return unescapeJsonPointer(decodeURIComponent(str));
          }
          function escapeFragment(str) {
            return encodeURIComponent(escapeJsonPointer(str));
          }
          function escapeJsonPointer(str) {
            return str.replace(/~/g, "~0").replace(/\//g, "~1");
          }
          function unescapeJsonPointer(str) {
            return str.replace(/~1/g, "/").replace(/~0/g, "~");
          }
        },
        { "./ucs2length": 118, "fast-deep-equal": 153 }
      ],
      120: [
        function (require, module, exports) {
          "use strict";
          var KEYWORDS = [
            "multipleOf",
            "maximum",
            "exclusiveMaximum",
            "minimum",
            "exclusiveMinimum",
            "maxLength",
            "minLength",
            "pattern",
            "additionalItems",
            "maxItems",
            "minItems",
            "uniqueItems",
            "maxProperties",
            "minProperties",
            "required",
            "additionalProperties",
            "enum",
            "format",
            "const"
          ];
          module.exports = function (metaSchema, keywordsJsonPointers) {
            for (var i = 0; i < keywordsJsonPointers.length; i++) {
              metaSchema = JSON.parse(JSON.stringify(metaSchema));
              var segments = keywordsJsonPointers[i].split("/");
              var keywords = metaSchema;
              var j;
              for (j = 1; j < segments.length; j++) {
                keywords = keywords[segments[j]];
              }
              for (j = 0; j < KEYWORDS.length; j++) {
                var key = KEYWORDS[j];
                var schema = keywords[key];
                if (schema) {
                  keywords[key] = {
                    anyOf: [
                      schema,
                      {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                      }
                    ]
                  };
                }
              }
            }
            return metaSchema;
          };
        },
        {}
      ],
      121: [
        function (require, module, exports) {
          "use strict";
          var metaSchema = require("./refs/json-schema-draft-07.json");
          module.exports = {
            $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
            definitions: { simpleTypes: metaSchema.definitions.simpleTypes },
            type: "object",
            dependencies: {
              schema: ["validate"],
              $data: ["validate"],
              statements: ["inline"],
              valid: { not: { required: ["macro"] } }
            },
            properties: {
              type: metaSchema.properties.type,
              schema: { type: "boolean" },
              statements: { type: "boolean" },
              dependencies: { type: "array", items: { type: "string" } },
              metaSchema: { type: "object" },
              modifying: { type: "boolean" },
              valid: { type: "boolean" },
              $data: { type: "boolean" },
              async: { type: "boolean" },
              errors: { anyOf: [{ type: "boolean" }, { const: "full" }] }
            }
          };
        },
        { "./refs/json-schema-draft-07.json": 151 }
      ],
      122: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate__limit(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $errorKeyword;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $isMax = $keyword == "maximum",
              $exclusiveKeyword = $isMax
                ? "exclusiveMaximum"
                : "exclusiveMinimum",
              $schemaExcl = it.schema[$exclusiveKeyword],
              $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
              $op = $isMax ? "<" : ">",
              $notOp = $isMax ? ">" : "<",
              $errorKeyword = undefined;
            if (
              !($isData || typeof $schema == "number" || $schema === undefined)
            ) {
              throw new Error($keyword + " must be number");
            }
            if (
              !(
                $isDataExcl ||
                $schemaExcl === undefined ||
                typeof $schemaExcl == "number" ||
                typeof $schemaExcl == "boolean"
              )
            ) {
              throw new Error($exclusiveKeyword + " must be number or boolean");
            }
            if ($isDataExcl) {
              var $schemaValueExcl = it.util.getData(
                  $schemaExcl.$data,
                  $dataLvl,
                  it.dataPathArr
                ),
                $exclusive = "exclusive" + $lvl,
                $exclType = "exclType" + $lvl,
                $exclIsNumber = "exclIsNumber" + $lvl,
                $opExpr = "op" + $lvl,
                $opStr = "' + " + $opExpr + " + '";
              out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
              $schemaValueExcl = "schemaExcl" + $lvl;
              out +=
                " var " +
                $exclusive +
                "; var " +
                $exclType +
                " = typeof " +
                $schemaValueExcl +
                "; if (" +
                $exclType +
                " != 'boolean' && " +
                $exclType +
                " != 'undefined' && " +
                $exclType +
                " != 'number') { ";
              var $errorKeyword = $exclusiveKeyword;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  ($errorKeyword || "_exclusiveLimit") +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: {} ";
                if (it.opts.messages !== false) {
                  out +=
                    " , message: '" + $exclusiveKeyword + " should be boolean' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out +=
                  " var err = " +
                  __err +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else if ( ";
              if ($isData) {
                out +=
                  " (" +
                  $schemaValue +
                  " !== undefined && typeof " +
                  $schemaValue +
                  " != 'number') || ";
              }
              out +=
                " " +
                $exclType +
                " == 'number' ? ( (" +
                $exclusive +
                " = " +
                $schemaValue +
                " === undefined || " +
                $schemaValueExcl +
                " " +
                $op +
                "= " +
                $schemaValue +
                ") ? " +
                $data +
                " " +
                $notOp +
                "= " +
                $schemaValueExcl +
                " : " +
                $data +
                " " +
                $notOp +
                " " +
                $schemaValue +
                " ) : ( (" +
                $exclusive +
                " = " +
                $schemaValueExcl +
                " === true) ? " +
                $data +
                " " +
                $notOp +
                "= " +
                $schemaValue +
                " : " +
                $data +
                " " +
                $notOp +
                " " +
                $schemaValue +
                " ) || " +
                $data +
                " !== " +
                $data +
                ") { var op" +
                $lvl +
                " = " +
                $exclusive +
                " ? '" +
                $op +
                "' : '" +
                $op +
                "='; ";
              if ($schema === undefined) {
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                $schemaValue = $schemaValueExcl;
                $isData = $isDataExcl;
              }
            } else {
              var $exclIsNumber = typeof $schemaExcl == "number",
                $opStr = $op;
              if ($exclIsNumber && $isData) {
                var $opExpr = "'" + $opStr + "'";
                out += " if ( ";
                if ($isData) {
                  out +=
                    " (" +
                    $schemaValue +
                    " !== undefined && typeof " +
                    $schemaValue +
                    " != 'number') || ";
                }
                out +=
                  " ( " +
                  $schemaValue +
                  " === undefined || " +
                  $schemaExcl +
                  " " +
                  $op +
                  "= " +
                  $schemaValue +
                  " ? " +
                  $data +
                  " " +
                  $notOp +
                  "= " +
                  $schemaExcl +
                  " : " +
                  $data +
                  " " +
                  $notOp +
                  " " +
                  $schemaValue +
                  " ) || " +
                  $data +
                  " !== " +
                  $data +
                  ") { ";
              } else {
                if ($exclIsNumber && $schema === undefined) {
                  $exclusive = true;
                  $errorKeyword = $exclusiveKeyword;
                  $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                  $schemaValue = $schemaExcl;
                  $notOp += "=";
                } else {
                  if ($exclIsNumber)
                    $schemaValue = Math[$isMax ? "min" : "max"](
                      $schemaExcl,
                      $schema
                    );
                  if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                    $exclusive = true;
                    $errorKeyword = $exclusiveKeyword;
                    $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                    $notOp += "=";
                  } else {
                    $exclusive = false;
                    $opStr += "=";
                  }
                }
                var $opExpr = "'" + $opStr + "'";
                out += " if ( ";
                if ($isData) {
                  out +=
                    " (" +
                    $schemaValue +
                    " !== undefined && typeof " +
                    $schemaValue +
                    " != 'number') || ";
                }
                out +=
                  " " +
                  $data +
                  " " +
                  $notOp +
                  " " +
                  $schemaValue +
                  " || " +
                  $data +
                  " !== " +
                  $data +
                  ") { ";
              }
            }
            $errorKeyword = $errorKeyword || $keyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                ($errorKeyword || "_limit") +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { comparison: " +
                $opExpr +
                ", limit: " +
                $schemaValue +
                ", exclusive: " +
                $exclusive +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be " + $opStr + " ";
                if ($isData) {
                  out += "' + " + $schemaValue;
                } else {
                  out += "" + $schemaValue + "'";
                }
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + $schema;
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      123: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate__limitItems(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $errorKeyword;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (!($isData || typeof $schema == "number")) {
              throw new Error($keyword + " must be number");
            }
            var $op = $keyword == "maxItems" ? ">" : "<";
            out += "if ( ";
            if ($isData) {
              out +=
                " (" +
                $schemaValue +
                " !== undefined && typeof " +
                $schemaValue +
                " != 'number') || ";
            }
            out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
            var $errorKeyword = $keyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                ($errorKeyword || "_limitItems") +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { limit: " +
                $schemaValue +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should NOT have ";
                if ($keyword == "maxItems") {
                  out += "more";
                } else {
                  out += "fewer";
                }
                out += " than ";
                if ($isData) {
                  out += "' + " + $schemaValue + " + '";
                } else {
                  out += "" + $schema;
                }
                out += " items' ";
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + $schema;
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += "} ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      124: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate__limitLength(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $errorKeyword;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (!($isData || typeof $schema == "number")) {
              throw new Error($keyword + " must be number");
            }
            var $op = $keyword == "maxLength" ? ">" : "<";
            out += "if ( ";
            if ($isData) {
              out +=
                " (" +
                $schemaValue +
                " !== undefined && typeof " +
                $schemaValue +
                " != 'number') || ";
            }
            if (it.opts.unicode === false) {
              out += " " + $data + ".length ";
            } else {
              out += " ucs2length(" + $data + ") ";
            }
            out += " " + $op + " " + $schemaValue + ") { ";
            var $errorKeyword = $keyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                ($errorKeyword || "_limitLength") +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { limit: " +
                $schemaValue +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should NOT be ";
                if ($keyword == "maxLength") {
                  out += "longer";
                } else {
                  out += "shorter";
                }
                out += " than ";
                if ($isData) {
                  out += "' + " + $schemaValue + " + '";
                } else {
                  out += "" + $schema;
                }
                out += " characters' ";
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + $schema;
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += "} ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      125: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate__limitProperties(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $errorKeyword;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (!($isData || typeof $schema == "number")) {
              throw new Error($keyword + " must be number");
            }
            var $op = $keyword == "maxProperties" ? ">" : "<";
            out += "if ( ";
            if ($isData) {
              out +=
                " (" +
                $schemaValue +
                " !== undefined && typeof " +
                $schemaValue +
                " != 'number') || ";
            }
            out +=
              " Object.keys(" +
              $data +
              ").length " +
              $op +
              " " +
              $schemaValue +
              ") { ";
            var $errorKeyword = $keyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                ($errorKeyword || "_limitProperties") +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { limit: " +
                $schemaValue +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should NOT have ";
                if ($keyword == "maxProperties") {
                  out += "more";
                } else {
                  out += "fewer";
                }
                out += " than ";
                if ($isData) {
                  out += "' + " + $schemaValue + " + '";
                } else {
                  out += "" + $schema;
                }
                out += " properties' ";
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + $schema;
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += "} ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      126: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_allOf(it, $keyword, $ruleType) {
            var out = " ";
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $currentBaseId = $it.baseId,
              $allSchemasEmpty = true;
            var arr1 = $schema;
            if (arr1) {
              var $sch,
                $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $sch = arr1[($i += 1)];
                if (
                  it.opts.strictKeywords
                    ? (_typeof2($sch) == "object" &&
                        Object.keys($sch).length > 0) ||
                      $sch === false
                    : it.util.schemaHasRules($sch, it.RULES.all)
                ) {
                  $allSchemasEmpty = false;
                  $it.schema = $sch;
                  $it.schemaPath = $schemaPath + "[" + $i + "]";
                  $it.errSchemaPath = $errSchemaPath + "/" + $i;
                  out += "  " + it.validate($it) + " ";
                  $it.baseId = $currentBaseId;
                  if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                  }
                }
              }
            }
            if ($breakOnError) {
              if ($allSchemasEmpty) {
                out += " if (true) { ";
              } else {
                out += " " + $closingBraces.slice(0, -1) + " ";
              }
            }
            return out;
          };
        },
        {}
      ],
      127: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_anyOf(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $noEmptySchema = $schema.every(function ($sch) {
              return it.opts.strictKeywords
                ? (_typeof2($sch) == "object" && Object.keys($sch).length > 0) ||
                    $sch === false
                : it.util.schemaHasRules($sch, it.RULES.all);
            });
            if ($noEmptySchema) {
              var $currentBaseId = $it.baseId;
              out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              var arr1 = $schema;
              if (arr1) {
                var $sch,
                  $i = -1,
                  l1 = arr1.length - 1;
                while ($i < l1) {
                  $sch = arr1[($i += 1)];
                  $it.schema = $sch;
                  $it.schemaPath = $schemaPath + "[" + $i + "]";
                  $it.errSchemaPath = $errSchemaPath + "/" + $i;
                  out += "  " + it.validate($it) + " ";
                  $it.baseId = $currentBaseId;
                  out +=
                    " " +
                    $valid +
                    " = " +
                    $valid +
                    " || " +
                    $nextValid +
                    "; if (!" +
                    $valid +
                    ") { ";
                  $closingBraces += "}";
                }
              }
              it.compositeRule = $it.compositeRule = $wasComposite;
              out +=
                " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "anyOf" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: {} ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should match some schema in anyOf' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError(vErrors); ";
                } else {
                  out += " validate.errors = vErrors; return false; ";
                }
              }
              out +=
                " } else {  errors = " +
                $errs +
                "; if (vErrors !== null) { if (" +
                $errs +
                ") vErrors.length = " +
                $errs +
                "; else vErrors = null; } ";
              if (it.opts.allErrors) {
                out += " } ";
              }
            } else {
              if ($breakOnError) {
                out += " if (true) { ";
              }
            }
            return out;
          };
        },
        {}
      ],
      128: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_comment(it, $keyword, $ruleType) {
            var out = " ";
            var $schema = it.schema[$keyword];
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $comment = it.util.toQuotedString($schema);
            if (it.opts.$comment === true) {
              out += " console.log(" + $comment + ");";
            } else if (typeof it.opts.$comment == "function") {
              out +=
                " self._opts.$comment(" +
                $comment +
                ", " +
                it.util.toQuotedString($errSchemaPath) +
                ", validate.root.schema);";
            }
            return out;
          };
        },
        {}
      ],
      129: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_const(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (!$isData) {
              out +=
                " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
            }
            out +=
              "var " +
              $valid +
              " = equal(" +
              $data +
              ", schema" +
              $lvl +
              "); if (!" +
              $valid +
              ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "const" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { allowedValue: schema" +
                $lvl +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be equal to constant' ";
              }
              if (it.opts.verbose) {
                out +=
                  " , schema: validate.schema" +
                  $schemaPath +
                  " , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " }";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      130: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_contains(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $idx = "i" + $lvl,
              $dataNxt = ($it.dataLevel = it.dataLevel + 1),
              $nextData = "data" + $dataNxt,
              $currentBaseId = it.baseId,
              $nonEmptySchema = it.opts.strictKeywords
                ? (_typeof2($schema) == "object" &&
                    Object.keys($schema).length > 0) ||
                  $schema === false
                : it.util.schemaHasRules($schema, it.RULES.all);
            out += "var " + $errs + " = errors;var " + $valid + ";";
            if ($nonEmptySchema) {
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $schema;
              $it.schemaPath = $schemaPath;
              $it.errSchemaPath = $errSchemaPath;
              out +=
                " var " +
                $nextValid +
                " = false; for (var " +
                $idx +
                " = 0; " +
                $idx +
                " < " +
                $data +
                ".length; " +
                $idx +
                "++) { ";
              $it.errorPath = it.util.getPathExpr(
                it.errorPath,
                $idx,
                it.opts.jsonPointers,
                true
              );
              var $passData = $data + "[" + $idx + "]";
              $it.dataPathArr[$dataNxt] = $idx;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out +=
                  " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out +=
                  " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (" + $nextValid + ") break; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
              out += " " + $closingBraces + " if (!" + $nextValid + ") {";
            } else {
              out += " if (" + $data + ".length == 0) {";
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "contains" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: {} ";
              if (it.opts.messages !== false) {
                out += " , message: 'should contain a valid item' ";
              }
              if (it.opts.verbose) {
                out +=
                  " , schema: validate.schema" +
                  $schemaPath +
                  " , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
            if ($nonEmptySchema) {
              out +=
                "  errors = " +
                $errs +
                "; if (vErrors !== null) { if (" +
                $errs +
                ") vErrors.length = " +
                $errs +
                "; else vErrors = null; } ";
            }
            if (it.opts.allErrors) {
              out += " } ";
            }
            return out;
          };
        },
        {}
      ],
      131: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_custom(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $errorKeyword;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $rule = this,
              $definition = "definition" + $lvl,
              $rDef = $rule.definition,
              $closingBraces = "";
            var $compile, $inline, $macro, $ruleValidate, $validateCode;
            if ($isData && $rDef.$data) {
              $validateCode = "keywordValidate" + $lvl;
              var $validateSchema = $rDef.validateSchema;
              out +=
                " var " +
                $definition +
                " = RULES.custom['" +
                $keyword +
                "'].definition; var " +
                $validateCode +
                " = " +
                $definition +
                ".validate;";
            } else {
              $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
              if (!$ruleValidate) return;
              $schemaValue = "validate.schema" + $schemaPath;
              $validateCode = $ruleValidate.code;
              $compile = $rDef.compile;
              $inline = $rDef.inline;
              $macro = $rDef.macro;
            }
            var $ruleErrs = $validateCode + ".errors",
              $i = "i" + $lvl,
              $ruleErr = "ruleErr" + $lvl,
              $asyncKeyword = $rDef.async;
            if ($asyncKeyword && !it.async)
              throw new Error("async keyword in sync schema");
            if (!($inline || $macro)) {
              out += "" + $ruleErrs + " = null;";
            }
            out += "var " + $errs + " = errors;var " + $valid + ";";
            if ($isData && $rDef.$data) {
              $closingBraces += "}";
              out +=
                " if (" +
                $schemaValue +
                " === undefined) { " +
                $valid +
                " = true; } else { ";
              if ($validateSchema) {
                $closingBraces += "}";
                out +=
                  " " +
                  $valid +
                  " = " +
                  $definition +
                  ".validateSchema(" +
                  $schemaValue +
                  "); if (" +
                  $valid +
                  ") { ";
              }
            }
            if ($inline) {
              if ($rDef.statements) {
                out += " " + $ruleValidate.validate + " ";
              } else {
                out += " " + $valid + " = " + $ruleValidate.validate + "; ";
              }
            } else if ($macro) {
              var $it = it.util.copy(it);
              var $closingBraces = "";
              $it.level++;
              var $nextValid = "valid" + $it.level;
              $it.schema = $ruleValidate.validate;
              $it.schemaPath = "";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              var $code = it
                .validate($it)
                .replace(/validate\.schema/g, $validateCode);
              it.compositeRule = $it.compositeRule = $wasComposite;
              out += " " + $code;
            } else {
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              out += "  " + $validateCode + ".call( ";
              if (it.opts.passContext) {
                out += "this";
              } else {
                out += "self";
              }
              if ($compile || $rDef.schema === false) {
                out += " , " + $data + " ";
              } else {
                out +=
                  " , " +
                  $schemaValue +
                  " , " +
                  $data +
                  " , validate.schema" +
                  it.schemaPath +
                  " ";
              }
              out += " , (dataPath || '')";
              if (it.errorPath != '""') {
                out += " + " + it.errorPath;
              }
              var $parentData = $dataLvl
                  ? "data" + ($dataLvl - 1 || "")
                  : "parentData",
                $parentDataProperty = $dataLvl
                  ? it.dataPathArr[$dataLvl]
                  : "parentDataProperty";
              out +=
                " , " +
                $parentData +
                " , " +
                $parentDataProperty +
                " , rootData )  ";
              var def_callRuleValidate = out;
              out = $$outStack.pop();
              if ($rDef.errors === false) {
                out += " " + $valid + " = ";
                if ($asyncKeyword) {
                  out += "/*await*/ ";
                }
                out += "" + def_callRuleValidate + "; ";
              } else {
                if ($asyncKeyword) {
                  $ruleErrs = "customErrors" + $lvl;
                  out +=
                    " var " +
                    $ruleErrs +
                    " = null; try { " +
                    $valid +
                    " = /*await*/ " +
                    def_callRuleValidate +
                    "; } catch (e) { " +
                    $valid +
                    " = false; if (e instanceof ValidationError) " +
                    $ruleErrs +
                    " = e.errors; else throw e; } ";
                } else {
                  out +=
                    " " +
                    $ruleErrs +
                    " = null; " +
                    $valid +
                    " = " +
                    def_callRuleValidate +
                    "; ";
                }
              }
            }
            if ($rDef.modifying) {
              out +=
                " if (" +
                $parentData +
                ") " +
                $data +
                " = " +
                $parentData +
                "[" +
                $parentDataProperty +
                "];";
            }
            out += "" + $closingBraces;
            if ($rDef.valid) {
              if ($breakOnError) {
                out += " if (true) { ";
              }
            } else {
              out += " if ( ";
              if ($rDef.valid === undefined) {
                out += " !";
                if ($macro) {
                  out += "" + $nextValid;
                } else {
                  out += "" + $valid;
                }
              } else {
                out += " " + !$rDef.valid + " ";
              }
              out += ") { ";
              $errorKeyword = $rule.keyword;
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  ($errorKeyword || "custom") +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { keyword: '" +
                  $rule.keyword +
                  "' } ";
                if (it.opts.messages !== false) {
                  out +=
                    " , message: 'should pass \"" +
                    $rule.keyword +
                    "\" keyword validation' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out +=
                  " var err = " +
                  __err +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              var def_customError = out;
              out = $$outStack.pop();
              if ($inline) {
                if ($rDef.errors) {
                  if ($rDef.errors != "full") {
                    out +=
                      "  for (var " +
                      $i +
                      "=" +
                      $errs +
                      "; " +
                      $i +
                      "<errors; " +
                      $i +
                      "++) { var " +
                      $ruleErr +
                      " = vErrors[" +
                      $i +
                      "]; if (" +
                      $ruleErr +
                      ".dataPath === undefined) " +
                      $ruleErr +
                      ".dataPath = (dataPath || '') + " +
                      it.errorPath +
                      "; if (" +
                      $ruleErr +
                      ".schemaPath === undefined) { " +
                      $ruleErr +
                      '.schemaPath = "' +
                      $errSchemaPath +
                      '"; } ';
                    if (it.opts.verbose) {
                      out +=
                        " " +
                        $ruleErr +
                        ".schema = " +
                        $schemaValue +
                        "; " +
                        $ruleErr +
                        ".data = " +
                        $data +
                        "; ";
                    }
                    out += " } ";
                  }
                } else {
                  if ($rDef.errors === false) {
                    out += " " + def_customError + " ";
                  } else {
                    out +=
                      " if (" +
                      $errs +
                      " == errors) { " +
                      def_customError +
                      " } else {  for (var " +
                      $i +
                      "=" +
                      $errs +
                      "; " +
                      $i +
                      "<errors; " +
                      $i +
                      "++) { var " +
                      $ruleErr +
                      " = vErrors[" +
                      $i +
                      "]; if (" +
                      $ruleErr +
                      ".dataPath === undefined) " +
                      $ruleErr +
                      ".dataPath = (dataPath || '') + " +
                      it.errorPath +
                      "; if (" +
                      $ruleErr +
                      ".schemaPath === undefined) { " +
                      $ruleErr +
                      '.schemaPath = "' +
                      $errSchemaPath +
                      '"; } ';
                    if (it.opts.verbose) {
                      out +=
                        " " +
                        $ruleErr +
                        ".schema = " +
                        $schemaValue +
                        "; " +
                        $ruleErr +
                        ".data = " +
                        $data +
                        "; ";
                    }
                    out += " } } ";
                  }
                }
              } else if ($macro) {
                out += "   var err =   ";
                /* istanbul ignore else */ if (it.createErrors !== false) {
                  out +=
                    " { keyword: '" +
                    ($errorKeyword || "custom") +
                    "' , dataPath: (dataPath || '') + " +
                    it.errorPath +
                    " , schemaPath: " +
                    it.util.toQuotedString($errSchemaPath) +
                    " , params: { keyword: '" +
                    $rule.keyword +
                    "' } ";
                  if (it.opts.messages !== false) {
                    out +=
                      " , message: 'should pass \"" +
                      $rule.keyword +
                      "\" keyword validation' ";
                  }
                  if (it.opts.verbose) {
                    out +=
                      " , schema: validate.schema" +
                      $schemaPath +
                      " , parentSchema: validate.schema" +
                      it.schemaPath +
                      " , data: " +
                      $data +
                      " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out +=
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                if (!it.compositeRule && $breakOnError) {
                  /* istanbul ignore if */ if (it.async) {
                    out += " throw new ValidationError(vErrors); ";
                  } else {
                    out += " validate.errors = vErrors; return false; ";
                  }
                }
              } else {
                if ($rDef.errors === false) {
                  out += " " + def_customError + " ";
                } else {
                  out +=
                    " if (Array.isArray(" +
                    $ruleErrs +
                    ")) { if (vErrors === null) vErrors = " +
                    $ruleErrs +
                    "; else vErrors = vErrors.concat(" +
                    $ruleErrs +
                    "); errors = vErrors.length;  for (var " +
                    $i +
                    "=" +
                    $errs +
                    "; " +
                    $i +
                    "<errors; " +
                    $i +
                    "++) { var " +
                    $ruleErr +
                    " = vErrors[" +
                    $i +
                    "]; if (" +
                    $ruleErr +
                    ".dataPath === undefined) " +
                    $ruleErr +
                    ".dataPath = (dataPath || '') + " +
                    it.errorPath +
                    ";  " +
                    $ruleErr +
                    '.schemaPath = "' +
                    $errSchemaPath +
                    '";  ';
                  if (it.opts.verbose) {
                    out +=
                      " " +
                      $ruleErr +
                      ".schema = " +
                      $schemaValue +
                      "; " +
                      $ruleErr +
                      ".data = " +
                      $data +
                      "; ";
                  }
                  out += " } } else { " + def_customError + " } ";
                }
              }
              out += " } ";
              if ($breakOnError) {
                out += " else { ";
              }
            }
            return out;
          };
        },
        {}
      ],
      132: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_dependencies(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $schemaDeps = {},
              $propertyDeps = {},
              $ownProperties = it.opts.ownProperties;
            for ($property in $schema) {
              if ($property == "__proto__") continue;
              var $sch = $schema[$property];
              var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
              $deps[$property] = $sch;
            }
            out += "var " + $errs + " = errors;";
            var $currentErrorPath = it.errorPath;
            out += "var missing" + $lvl + ";";
            for (var $property in $propertyDeps) {
              $deps = $propertyDeps[$property];
              if ($deps.length) {
                out +=
                  " if ( " +
                  $data +
                  it.util.getProperty($property) +
                  " !== undefined ";
                if ($ownProperties) {
                  out +=
                    " && Object.prototype.hasOwnProperty.call(" +
                    $data +
                    ", '" +
                    it.util.escapeQuotes($property) +
                    "') ";
                }
                if ($breakOnError) {
                  out += " && ( ";
                  var arr1 = $deps;
                  if (arr1) {
                    var $propertyKey,
                      $i = -1,
                      l1 = arr1.length - 1;
                    while ($i < l1) {
                      $propertyKey = arr1[($i += 1)];
                      if ($i) {
                        out += " || ";
                      }
                      var $prop = it.util.getProperty($propertyKey),
                        $useData = $data + $prop;
                      out += " ( ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out +=
                          " || ! Object.prototype.hasOwnProperty.call(" +
                          $data +
                          ", '" +
                          it.util.escapeQuotes($propertyKey) +
                          "') ";
                      }
                      out +=
                        ") && (missing" +
                        $lvl +
                        " = " +
                        it.util.toQuotedString(
                          it.opts.jsonPointers ? $propertyKey : $prop
                        ) +
                        ") ) ";
                    }
                  }
                  out += ")) {  ";
                  var $propertyPath = "missing" + $lvl,
                    $missingProperty = "' + " + $propertyPath + " + '";
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.opts.jsonPointers
                      ? it.util.getPathExpr(
                          $currentErrorPath,
                          $propertyPath,
                          true
                        )
                      : $currentErrorPath + " + " + $propertyPath;
                  }
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      "dependencies" +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { property: '" +
                      it.util.escapeQuotes($property) +
                      "', missingProperty: '" +
                      $missingProperty +
                      "', depsCount: " +
                      $deps.length +
                      ", deps: '" +
                      it.util.escapeQuotes(
                        $deps.length == 1 ? $deps[0] : $deps.join(", ")
                      ) +
                      "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should have ";
                      if ($deps.length == 1) {
                        out += "property " + it.util.escapeQuotes($deps[0]);
                      } else {
                        out +=
                          "properties " + it.util.escapeQuotes($deps.join(", "));
                      }
                      out +=
                        " when property " +
                        it.util.escapeQuotes($property) +
                        " is present' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                } else {
                  out += " ) { ";
                  var arr2 = $deps;
                  if (arr2) {
                    var $propertyKey,
                      i2 = -1,
                      l2 = arr2.length - 1;
                    while (i2 < l2) {
                      $propertyKey = arr2[(i2 += 1)];
                      var $prop = it.util.getProperty($propertyKey),
                        $missingProperty = it.util.escapeQuotes($propertyKey),
                        $useData = $data + $prop;
                      if (it.opts._errorDataPathProperty) {
                        it.errorPath = it.util.getPath(
                          $currentErrorPath,
                          $propertyKey,
                          it.opts.jsonPointers
                        );
                      }
                      out += " if ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out +=
                          " || ! Object.prototype.hasOwnProperty.call(" +
                          $data +
                          ", '" +
                          it.util.escapeQuotes($propertyKey) +
                          "') ";
                      }
                      out += ") {  var err =   ";
                      /* istanbul ignore else */ if (it.createErrors !== false) {
                        out +=
                          " { keyword: '" +
                          "dependencies" +
                          "' , dataPath: (dataPath || '') + " +
                          it.errorPath +
                          " , schemaPath: " +
                          it.util.toQuotedString($errSchemaPath) +
                          " , params: { property: '" +
                          it.util.escapeQuotes($property) +
                          "', missingProperty: '" +
                          $missingProperty +
                          "', depsCount: " +
                          $deps.length +
                          ", deps: '" +
                          it.util.escapeQuotes(
                            $deps.length == 1 ? $deps[0] : $deps.join(", ")
                          ) +
                          "' } ";
                        if (it.opts.messages !== false) {
                          out += " , message: 'should have ";
                          if ($deps.length == 1) {
                            out += "property " + it.util.escapeQuotes($deps[0]);
                          } else {
                            out +=
                              "properties " +
                              it.util.escapeQuotes($deps.join(", "));
                          }
                          out +=
                            " when property " +
                            it.util.escapeQuotes($property) +
                            " is present' ";
                        }
                        if (it.opts.verbose) {
                          out +=
                            " , schema: validate.schema" +
                            $schemaPath +
                            " , parentSchema: validate.schema" +
                            it.schemaPath +
                            " , data: " +
                            $data +
                            " ";
                        }
                        out += " } ";
                      } else {
                        out += " {} ";
                      }
                      out +=
                        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                    }
                  }
                }
                out += " }   ";
                if ($breakOnError) {
                  $closingBraces += "}";
                  out += " else { ";
                }
              }
            }
            it.errorPath = $currentErrorPath;
            var $currentBaseId = $it.baseId;
            for (var $property in $schemaDeps) {
              var $sch = $schemaDeps[$property];
              if (
                it.opts.strictKeywords
                  ? (_typeof2($sch) == "object" &&
                      Object.keys($sch).length > 0) ||
                    $sch === false
                  : it.util.schemaHasRules($sch, it.RULES.all)
              ) {
                out +=
                  " " +
                  $nextValid +
                  " = true; if ( " +
                  $data +
                  it.util.getProperty($property) +
                  " !== undefined ";
                if ($ownProperties) {
                  out +=
                    " && Object.prototype.hasOwnProperty.call(" +
                    $data +
                    ", '" +
                    it.util.escapeQuotes($property) +
                    "') ";
                }
                out += ") { ";
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + it.util.getProperty($property);
                $it.errSchemaPath =
                  $errSchemaPath + "/" + it.util.escapeFragment($property);
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
            if ($breakOnError) {
              out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
            }
            return out;
          };
        },
        {}
      ],
      133: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_enum(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $i = "i" + $lvl,
              $vSchema = "schema" + $lvl;
            if (!$isData) {
              out +=
                " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
            }
            out += "var " + $valid + ";";
            if ($isData) {
              out +=
                " if (schema" +
                $lvl +
                " === undefined) " +
                $valid +
                " = true; else if (!Array.isArray(schema" +
                $lvl +
                ")) " +
                $valid +
                " = false; else {";
            }
            out +=
              "" +
              $valid +
              " = false;for (var " +
              $i +
              "=0; " +
              $i +
              "<" +
              $vSchema +
              ".length; " +
              $i +
              "++) if (equal(" +
              $data +
              ", " +
              $vSchema +
              "[" +
              $i +
              "])) { " +
              $valid +
              " = true; break; }";
            if ($isData) {
              out += "  }  ";
            }
            out += " if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "enum" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { allowedValues: schema" +
                $lvl +
                " } ";
              if (it.opts.messages !== false) {
                out +=
                  " , message: 'should be equal to one of the allowed values' ";
              }
              if (it.opts.verbose) {
                out +=
                  " , schema: validate.schema" +
                  $schemaPath +
                  " , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " }";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      134: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_format(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            if (it.opts.format === false) {
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            }
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $unknownFormats = it.opts.unknownFormats,
              $allowUnknown = Array.isArray($unknownFormats);
            if ($isData) {
              var $format = "format" + $lvl,
                $isObject = "isObject" + $lvl,
                $formatType = "formatType" + $lvl;
              out +=
                " var " +
                $format +
                " = formats[" +
                $schemaValue +
                "]; var " +
                $isObject +
                " = typeof " +
                $format +
                " == 'object' && !(" +
                $format +
                " instanceof RegExp) && " +
                $format +
                ".validate; var " +
                $formatType +
                " = " +
                $isObject +
                " && " +
                $format +
                ".type || 'string'; if (" +
                $isObject +
                ") { ";
              if (it.async) {
                out += " var async" + $lvl + " = " + $format + ".async; ";
              }
              out += " " + $format + " = " + $format + ".validate; } if (  ";
              if ($isData) {
                out +=
                  " (" +
                  $schemaValue +
                  " !== undefined && typeof " +
                  $schemaValue +
                  " != 'string') || ";
              }
              out += " (";
              if ($unknownFormats != "ignore") {
                out += " (" + $schemaValue + " && !" + $format + " ";
                if ($allowUnknown) {
                  out +=
                    " && self._opts.unknownFormats.indexOf(" +
                    $schemaValue +
                    ") == -1 ";
                }
                out += ") || ";
              }
              out +=
                " (" +
                $format +
                " && " +
                $formatType +
                " == '" +
                $ruleType +
                "' && !(typeof " +
                $format +
                " == 'function' ? ";
              if (it.async) {
                out +=
                  " (/*async*/" +
                  $lvl +
                  " ? /*await*/ " +
                  $format +
                  "(" +
                  $data +
                  ") : " +
                  $format +
                  "(" +
                  $data +
                  ")) ";
              } else {
                out += " " + $format + "(" + $data + ") ";
              }
              out += " : " + $format + ".test(" + $data + "))))) {";
            } else {
              var $format = it.formats[$schema];
              if (!$format) {
                if ($unknownFormats == "ignore") {
                  it.logger.warn(
                    'unknown format "' +
                      $schema +
                      '" ignored in schema at path "' +
                      it.errSchemaPath +
                      '"'
                  );
                  if ($breakOnError) {
                    out += " if (true) { ";
                  }
                  return out;
                } else if (
                  $allowUnknown &&
                  $unknownFormats.indexOf($schema) >= 0
                ) {
                  if ($breakOnError) {
                    out += " if (true) { ";
                  }
                  return out;
                } else {
                  throw new Error(
                    'unknown format "' +
                      $schema +
                      '" is used in schema at path "' +
                      it.errSchemaPath +
                      '"'
                  );
                }
              }
              var $isObject =
                _typeof2($format) == "object" &&
                !($format instanceof RegExp) &&
                $format.validate;
              var $formatType = ($isObject && $format.type) || "string";
              if ($isObject) {
                var $async = $format.async === true;
                $format = $format.validate;
              }
              if ($formatType != $ruleType) {
                if ($breakOnError) {
                  out += " if (true) { ";
                }
                return out;
              }
              if ($async) {
                if (!it.async) throw new Error("async format in sync schema");
                var $formatRef =
                  "formats" + it.util.getProperty($schema) + ".validate";
                out += " if (!(/*await*/ " + $formatRef + "(" + $data + "))) { ";
              } else {
                out += " if (! ";
                var $formatRef = "formats" + it.util.getProperty($schema);
                if ($isObject) $formatRef += ".validate";
                if (typeof $format == "function") {
                  out += " " + $formatRef + "(" + $data + ") ";
                } else {
                  out += " " + $formatRef + ".test(" + $data + ") ";
                }
                out += ") { ";
              }
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "format" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { format:  ";
              if ($isData) {
                out += "" + $schemaValue;
              } else {
                out += "" + it.util.toQuotedString($schema);
              }
              out += "  } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should match format \"";
                if ($isData) {
                  out += "' + " + $schemaValue + " + '";
                } else {
                  out += "" + it.util.escapeQuotes($schema);
                }
                out += "\"' ";
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + it.util.toQuotedString($schema);
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      135: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_if(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $thenSch = it.schema["then"],
              $elseSch = it.schema["else"],
              $thenPresent =
                $thenSch !== undefined &&
                (it.opts.strictKeywords
                  ? (_typeof2($thenSch) == "object" &&
                      Object.keys($thenSch).length > 0) ||
                    $thenSch === false
                  : it.util.schemaHasRules($thenSch, it.RULES.all)),
              $elsePresent =
                $elseSch !== undefined &&
                (it.opts.strictKeywords
                  ? (_typeof2($elseSch) == "object" &&
                      Object.keys($elseSch).length > 0) ||
                    $elseSch === false
                  : it.util.schemaHasRules($elseSch, it.RULES.all)),
              $currentBaseId = $it.baseId;
            if ($thenPresent || $elsePresent) {
              var $ifClause;
              $it.createErrors = false;
              $it.schema = $schema;
              $it.schemaPath = $schemaPath;
              $it.errSchemaPath = $errSchemaPath;
              out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
              $it.createErrors = true;
              out +=
                "  errors = " +
                $errs +
                "; if (vErrors !== null) { if (" +
                $errs +
                ") vErrors.length = " +
                $errs +
                "; else vErrors = null; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
              if ($thenPresent) {
                out += " if (" + $nextValid + ") {  ";
                $it.schema = it.schema["then"];
                $it.schemaPath = it.schemaPath + ".then";
                $it.errSchemaPath = it.errSchemaPath + "/then";
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                out += " " + $valid + " = " + $nextValid + "; ";
                if ($thenPresent && $elsePresent) {
                  $ifClause = "ifClause" + $lvl;
                  out += " var " + $ifClause + " = 'then'; ";
                } else {
                  $ifClause = "'then'";
                }
                out += " } ";
                if ($elsePresent) {
                  out += " else { ";
                }
              } else {
                out += " if (!" + $nextValid + ") { ";
              }
              if ($elsePresent) {
                $it.schema = it.schema["else"];
                $it.schemaPath = it.schemaPath + ".else";
                $it.errSchemaPath = it.errSchemaPath + "/else";
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                out += " " + $valid + " = " + $nextValid + "; ";
                if ($thenPresent && $elsePresent) {
                  $ifClause = "ifClause" + $lvl;
                  out += " var " + $ifClause + " = 'else'; ";
                } else {
                  $ifClause = "'else'";
                }
                out += " } ";
              }
              out += " if (!" + $valid + ") {   var err =   ";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "if" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { failingKeyword: " +
                  $ifClause +
                  " } ";
                if (it.opts.messages !== false) {
                  out +=
                    " , message: 'should match \"' + " +
                    $ifClause +
                    " + '\" schema' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError(vErrors); ";
                } else {
                  out += " validate.errors = vErrors; return false; ";
                }
              }
              out += " }   ";
              if ($breakOnError) {
                out += " else { ";
              }
            } else {
              if ($breakOnError) {
                out += " if (true) { ";
              }
            }
            return out;
          };
        },
        {}
      ],
      136: [
        function (require, module, exports) {
          "use strict"; //all requires must be explicit because browserify won't work with dynamic requires
          module.exports = {
            $ref: require("./ref"),
            allOf: require("./allOf"),
            anyOf: require("./anyOf"),
            $comment: require("./comment"),
            const: require("./const"),
            contains: require("./contains"),
            dependencies: require("./dependencies"),
            enum: require("./enum"),
            format: require("./format"),
            if: require("./if"),
            items: require("./items"),
            maximum: require("./_limit"),
            minimum: require("./_limit"),
            maxItems: require("./_limitItems"),
            minItems: require("./_limitItems"),
            maxLength: require("./_limitLength"),
            minLength: require("./_limitLength"),
            maxProperties: require("./_limitProperties"),
            minProperties: require("./_limitProperties"),
            multipleOf: require("./multipleOf"),
            not: require("./not"),
            oneOf: require("./oneOf"),
            pattern: require("./pattern"),
            properties: require("./properties"),
            propertyNames: require("./propertyNames"),
            required: require("./required"),
            uniqueItems: require("./uniqueItems"),
            validate: require("./validate")
          };
        },
        {
          "./_limit": 122,
          "./_limitItems": 123,
          "./_limitLength": 124,
          "./_limitProperties": 125,
          "./allOf": 126,
          "./anyOf": 127,
          "./comment": 128,
          "./const": 129,
          "./contains": 130,
          "./dependencies": 132,
          "./enum": 133,
          "./format": 134,
          "./if": 135,
          "./items": 137,
          "./multipleOf": 138,
          "./not": 139,
          "./oneOf": 140,
          "./pattern": 141,
          "./properties": 142,
          "./propertyNames": 143,
          "./ref": 144,
          "./required": 145,
          "./uniqueItems": 146,
          "./validate": 147
        }
      ],
      137: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_items(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $idx = "i" + $lvl,
              $dataNxt = ($it.dataLevel = it.dataLevel + 1),
              $nextData = "data" + $dataNxt,
              $currentBaseId = it.baseId;
            out += "var " + $errs + " = errors;var " + $valid + ";";
            if (Array.isArray($schema)) {
              var $additionalItems = it.schema.additionalItems;
              if ($additionalItems === false) {
                out +=
                  " " +
                  $valid +
                  " = " +
                  $data +
                  ".length <= " +
                  $schema.length +
                  "; ";
                var $currErrSchemaPath = $errSchemaPath;
                $errSchemaPath = it.errSchemaPath + "/additionalItems";
                out += "  if (!" + $valid + ") {   ";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                /* istanbul ignore else */ if (it.createErrors !== false) {
                  out +=
                    " { keyword: '" +
                    "additionalItems" +
                    "' , dataPath: (dataPath || '') + " +
                    it.errorPath +
                    " , schemaPath: " +
                    it.util.toQuotedString($errSchemaPath) +
                    " , params: { limit: " +
                    $schema.length +
                    " } ";
                  if (it.opts.messages !== false) {
                    out +=
                      " , message: 'should NOT have more than " +
                      $schema.length +
                      " items' ";
                  }
                  if (it.opts.verbose) {
                    out +=
                      " , schema: false , parentSchema: validate.schema" +
                      it.schemaPath +
                      " , data: " +
                      $data +
                      " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  /* istanbul ignore if */ if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out +=
                    " var err = " +
                    __err +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  $closingBraces += "}";
                  out += " else { ";
                }
              }
              var arr1 = $schema;
              if (arr1) {
                var $sch,
                  $i = -1,
                  l1 = arr1.length - 1;
                while ($i < l1) {
                  $sch = arr1[($i += 1)];
                  if (
                    it.opts.strictKeywords
                      ? (_typeof2($sch) == "object" &&
                          Object.keys($sch).length > 0) ||
                        $sch === false
                      : it.util.schemaHasRules($sch, it.RULES.all)
                  ) {
                    out +=
                      " " +
                      $nextValid +
                      " = true; if (" +
                      $data +
                      ".length > " +
                      $i +
                      ") { ";
                    var $passData = $data + "[" + $i + "]";
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + "[" + $i + "]";
                    $it.errSchemaPath = $errSchemaPath + "/" + $i;
                    $it.errorPath = it.util.getPathExpr(
                      it.errorPath,
                      $i,
                      it.opts.jsonPointers,
                      true
                    );
                    $it.dataPathArr[$dataNxt] = $i;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                      out +=
                        " " +
                        it.util.varReplace($code, $nextData, $passData) +
                        " ";
                    } else {
                      out +=
                        " var " +
                        $nextData +
                        " = " +
                        $passData +
                        "; " +
                        $code +
                        " ";
                    }
                    out += " }  ";
                    if ($breakOnError) {
                      out += " if (" + $nextValid + ") { ";
                      $closingBraces += "}";
                    }
                  }
                }
              }
              if (
                _typeof2($additionalItems) == "object" &&
                (it.opts.strictKeywords
                  ? (_typeof2($additionalItems) == "object" &&
                      Object.keys($additionalItems).length > 0) ||
                    $additionalItems === false
                  : it.util.schemaHasRules($additionalItems, it.RULES.all))
              ) {
                $it.schema = $additionalItems;
                $it.schemaPath = it.schemaPath + ".additionalItems";
                $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
                out +=
                  " " +
                  $nextValid +
                  " = true; if (" +
                  $data +
                  ".length > " +
                  $schema.length +
                  ") {  for (var " +
                  $idx +
                  " = " +
                  $schema.length +
                  "; " +
                  $idx +
                  " < " +
                  $data +
                  ".length; " +
                  $idx +
                  "++) { ";
                $it.errorPath = it.util.getPathExpr(
                  it.errorPath,
                  $idx,
                  it.opts.jsonPointers,
                  true
                );
                var $passData = $data + "[" + $idx + "]";
                $it.dataPathArr[$dataNxt] = $idx;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out +=
                    " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out +=
                    " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
                out += " } }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            } else if (
              it.opts.strictKeywords
                ? (_typeof2($schema) == "object" &&
                    Object.keys($schema).length > 0) ||
                  $schema === false
                : it.util.schemaHasRules($schema, it.RULES.all)
            ) {
              $it.schema = $schema;
              $it.schemaPath = $schemaPath;
              $it.errSchemaPath = $errSchemaPath;
              out +=
                "  for (var " +
                $idx +
                " = " +
                0 +
                "; " +
                $idx +
                " < " +
                $data +
                ".length; " +
                $idx +
                "++) { ";
              $it.errorPath = it.util.getPathExpr(
                it.errorPath,
                $idx,
                it.opts.jsonPointers,
                true
              );
              var $passData = $data + "[" + $idx + "]";
              $it.dataPathArr[$dataNxt] = $idx;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out +=
                  " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out +=
                  " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " }";
            }
            if ($breakOnError) {
              out += " " + $closingBraces + " if (" + $errs + " == errors) {";
            }
            return out;
          };
        },
        {}
      ],
      138: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (!($isData || typeof $schema == "number")) {
              throw new Error($keyword + " must be number");
            }
            out += "var division" + $lvl + ";if (";
            if ($isData) {
              out +=
                " " +
                $schemaValue +
                " !== undefined && ( typeof " +
                $schemaValue +
                " != 'number' || ";
            }
            out +=
              " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
            if (it.opts.multipleOfPrecision) {
              out +=
                " Math.abs(Math.round(division" +
                $lvl +
                ") - division" +
                $lvl +
                ") > 1e-" +
                it.opts.multipleOfPrecision +
                " ";
            } else {
              out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
            }
            out += " ) ";
            if ($isData) {
              out += "  )  ";
            }
            out += " ) {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "multipleOf" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { multipleOf: " +
                $schemaValue +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be multiple of ";
                if ($isData) {
                  out += "' + " + $schemaValue;
                } else {
                  out += "" + $schemaValue + "'";
                }
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + $schema;
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += "} ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      139: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_not(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            if (
              it.opts.strictKeywords
                ? (_typeof2($schema) == "object" &&
                    Object.keys($schema).length > 0) ||
                  $schema === false
                : it.util.schemaHasRules($schema, it.RULES.all)
            ) {
              $it.schema = $schema;
              $it.schemaPath = $schemaPath;
              $it.errSchemaPath = $errSchemaPath;
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.createErrors = false;
              var $allErrorsOption;
              if ($it.opts.allErrors) {
                $allErrorsOption = $it.opts.allErrors;
                $it.opts.allErrors = false;
              }
              out += " " + it.validate($it) + " ";
              $it.createErrors = true;
              if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
              it.compositeRule = $it.compositeRule = $wasComposite;
              out += " if (" + $nextValid + ") {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "not" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: {} ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should NOT be valid' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out +=
                  " var err = " +
                  __err +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out +=
                " } else {  errors = " +
                $errs +
                "; if (vErrors !== null) { if (" +
                $errs +
                ") vErrors.length = " +
                $errs +
                "; else vErrors = null; } ";
              if (it.opts.allErrors) {
                out += " } ";
              }
            } else {
              out += "  var err =   ";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "not" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: {} ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should NOT be valid' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              if ($breakOnError) {
                out += " if (false) { ";
              }
            }
            return out;
          };
        },
        {}
      ],
      140: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_oneOf(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $currentBaseId = $it.baseId,
              $prevValid = "prevValid" + $lvl,
              $passingSchemas = "passingSchemas" + $lvl;
            out +=
              "var " +
              $errs +
              " = errors , " +
              $prevValid +
              " = false , " +
              $valid +
              " = false , " +
              $passingSchemas +
              " = null; ";
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            var arr1 = $schema;
            if (arr1) {
              var $sch,
                $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $sch = arr1[($i += 1)];
                if (
                  it.opts.strictKeywords
                    ? (_typeof2($sch) == "object" &&
                        Object.keys($sch).length > 0) ||
                      $sch === false
                    : it.util.schemaHasRules($sch, it.RULES.all)
                ) {
                  $it.schema = $sch;
                  $it.schemaPath = $schemaPath + "[" + $i + "]";
                  $it.errSchemaPath = $errSchemaPath + "/" + $i;
                  out += "  " + it.validate($it) + " ";
                  $it.baseId = $currentBaseId;
                } else {
                  out += " var " + $nextValid + " = true; ";
                }
                if ($i) {
                  out +=
                    " if (" +
                    $nextValid +
                    " && " +
                    $prevValid +
                    ") { " +
                    $valid +
                    " = false; " +
                    $passingSchemas +
                    " = [" +
                    $passingSchemas +
                    ", " +
                    $i +
                    "]; } else { ";
                  $closingBraces += "}";
                }
                out +=
                  " if (" +
                  $nextValid +
                  ") { " +
                  $valid +
                  " = " +
                  $prevValid +
                  " = true; " +
                  $passingSchemas +
                  " = " +
                  $i +
                  "; }";
              }
            }
            it.compositeRule = $it.compositeRule = $wasComposite;
            out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "oneOf" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { passingSchemas: " +
                $passingSchemas +
                " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should match exactly one schema in oneOf' ";
              }
              if (it.opts.verbose) {
                out +=
                  " , schema: validate.schema" +
                  $schemaPath +
                  " , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out +=
              ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError(vErrors); ";
              } else {
                out += " validate.errors = vErrors; return false; ";
              }
            }
            out +=
              "} else {  errors = " +
              $errs +
              "; if (vErrors !== null) { if (" +
              $errs +
              ") vErrors.length = " +
              $errs +
              "; else vErrors = null; }";
            if (it.opts.allErrors) {
              out += " } ";
            }
            return out;
          };
        },
        {}
      ],
      141: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_pattern(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $regexp = $isData
              ? "(new RegExp(" + $schemaValue + "))"
              : it.usePattern($schema);
            out += "if ( ";
            if ($isData) {
              out +=
                " (" +
                $schemaValue +
                " !== undefined && typeof " +
                $schemaValue +
                " != 'string') || ";
            }
            out += " !" + $regexp + ".test(" + $data + ") ) {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            /* istanbul ignore else */ if (it.createErrors !== false) {
              out +=
                " { keyword: '" +
                "pattern" +
                "' , dataPath: (dataPath || '') + " +
                it.errorPath +
                " , schemaPath: " +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { pattern:  ";
              if ($isData) {
                out += "" + $schemaValue;
              } else {
                out += "" + it.util.toQuotedString($schema);
              }
              out += "  } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should match pattern \"";
                if ($isData) {
                  out += "' + " + $schemaValue + " + '";
                } else {
                  out += "" + it.util.escapeQuotes($schema);
                }
                out += "\"' ";
              }
              if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) {
                  out += "validate.schema" + $schemaPath;
                } else {
                  out += "" + it.util.toQuotedString($schema);
                }
                out +=
                  "         , parentSchema: validate.schema" +
                  it.schemaPath +
                  " , data: " +
                  $data +
                  " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */ if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out +=
                " var err = " +
                __err +
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += "} ";
            if ($breakOnError) {
              out += " else { ";
            }
            return out;
          };
        },
        {}
      ],
      142: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_properties(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            var $key = "key" + $lvl,
              $idx = "idx" + $lvl,
              $dataNxt = ($it.dataLevel = it.dataLevel + 1),
              $nextData = "data" + $dataNxt,
              $dataProperties = "dataProperties" + $lvl;
            var $schemaKeys = Object.keys($schema || {}).filter(notProto),
              $pProperties = it.schema.patternProperties || {},
              $pPropertyKeys = Object.keys($pProperties).filter(notProto),
              $aProperties = it.schema.additionalProperties,
              $someProperties = $schemaKeys.length || $pPropertyKeys.length,
              $noAdditional = $aProperties === false,
              $additionalIsSchema =
                _typeof2($aProperties) == "object" &&
                Object.keys($aProperties).length,
              $removeAdditional = it.opts.removeAdditional,
              $checkAdditional =
                $noAdditional || $additionalIsSchema || $removeAdditional,
              $ownProperties = it.opts.ownProperties,
              $currentBaseId = it.baseId;
            var $required = it.schema.required;
            if (
              $required &&
              !(it.opts.$data && $required.$data) &&
              $required.length < it.opts.loopRequired
            ) {
              var $requiredHash = it.util.toHash($required);
            }
            function notProto(p) {
              return p !== "__proto__";
            }
            out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
            if ($ownProperties) {
              out += " var " + $dataProperties + " = undefined;";
            }
            if ($checkAdditional) {
              if ($ownProperties) {
                out +=
                  " " +
                  $dataProperties +
                  " = " +
                  $dataProperties +
                  " || Object.keys(" +
                  $data +
                  "); for (var " +
                  $idx +
                  "=0; " +
                  $idx +
                  "<" +
                  $dataProperties +
                  ".length; " +
                  $idx +
                  "++) { var " +
                  $key +
                  " = " +
                  $dataProperties +
                  "[" +
                  $idx +
                  "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              if ($someProperties) {
                out += " var isAdditional" + $lvl + " = !(false ";
                if ($schemaKeys.length) {
                  if ($schemaKeys.length > 8) {
                    out +=
                      " || validate.schema" +
                      $schemaPath +
                      ".hasOwnProperty(" +
                      $key +
                      ") ";
                  } else {
                    var arr1 = $schemaKeys;
                    if (arr1) {
                      var $propertyKey,
                        i1 = -1,
                        l1 = arr1.length - 1;
                      while (i1 < l1) {
                        $propertyKey = arr1[(i1 += 1)];
                        out +=
                          " || " +
                          $key +
                          " == " +
                          it.util.toQuotedString($propertyKey) +
                          " ";
                      }
                    }
                  }
                }
                if ($pPropertyKeys.length) {
                  var arr2 = $pPropertyKeys;
                  if (arr2) {
                    var $pProperty,
                      $i = -1,
                      l2 = arr2.length - 1;
                    while ($i < l2) {
                      $pProperty = arr2[($i += 1)];
                      out +=
                        " || " +
                        it.usePattern($pProperty) +
                        ".test(" +
                        $key +
                        ") ";
                    }
                  }
                }
                out += " ); if (isAdditional" + $lvl + ") { ";
              }
              if ($removeAdditional == "all") {
                out += " delete " + $data + "[" + $key + "]; ";
              } else {
                var $currentErrorPath = it.errorPath;
                var $additionalProperty = "' + " + $key + " + '";
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPathExpr(
                    it.errorPath,
                    $key,
                    it.opts.jsonPointers
                  );
                }
                if ($noAdditional) {
                  if ($removeAdditional) {
                    out += " delete " + $data + "[" + $key + "]; ";
                  } else {
                    out += " " + $nextValid + " = false; ";
                    var $currErrSchemaPath = $errSchemaPath;
                    $errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    /* istanbul ignore else */ if (it.createErrors !== false) {
                      out +=
                        " { keyword: '" +
                        "additionalProperties" +
                        "' , dataPath: (dataPath || '') + " +
                        it.errorPath +
                        " , schemaPath: " +
                        it.util.toQuotedString($errSchemaPath) +
                        " , params: { additionalProperty: '" +
                        $additionalProperty +
                        "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) {
                          out += "is an invalid additional property";
                        } else {
                          out += "should NOT have additional properties";
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out +=
                          " , schema: false , parentSchema: validate.schema" +
                          it.schemaPath +
                          " , data: " +
                          $data +
                          " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                      /* istanbul ignore if */ if (it.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out +=
                          " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out +=
                        " var err = " +
                        __err +
                        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    $errSchemaPath = $currErrSchemaPath;
                    if ($breakOnError) {
                      out += " break; ";
                    }
                  }
                } else if ($additionalIsSchema) {
                  if ($removeAdditional == "failing") {
                    out += " var " + $errs + " = errors;  ";
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath =
                      it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty
                      ? it.errorPath
                      : it.util.getPathExpr(
                          it.errorPath,
                          $key,
                          it.opts.jsonPointers
                        );
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                      out +=
                        " " +
                        it.util.varReplace($code, $nextData, $passData) +
                        " ";
                    } else {
                      out +=
                        " var " +
                        $nextData +
                        " = " +
                        $passData +
                        "; " +
                        $code +
                        " ";
                    }
                    out +=
                      " if (!" +
                      $nextValid +
                      ") { errors = " +
                      $errs +
                      "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " +
                      $data +
                      "[" +
                      $key +
                      "]; }  ";
                    it.compositeRule = $it.compositeRule = $wasComposite;
                  } else {
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath =
                      it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty
                      ? it.errorPath
                      : it.util.getPathExpr(
                          it.errorPath,
                          $key,
                          it.opts.jsonPointers
                        );
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                      out +=
                        " " +
                        it.util.varReplace($code, $nextData, $passData) +
                        " ";
                    } else {
                      out +=
                        " var " +
                        $nextData +
                        " = " +
                        $passData +
                        "; " +
                        $code +
                        " ";
                    }
                    if ($breakOnError) {
                      out += " if (!" + $nextValid + ") break; ";
                    }
                  }
                }
                it.errorPath = $currentErrorPath;
              }
              if ($someProperties) {
                out += " } ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
            var $useDefaults = it.opts.useDefaults && !it.compositeRule;
            if ($schemaKeys.length) {
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey,
                  i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[(i3 += 1)];
                  var $sch = $schema[$propertyKey];
                  if (
                    it.opts.strictKeywords
                      ? (_typeof2($sch) == "object" &&
                          Object.keys($sch).length > 0) ||
                        $sch === false
                      : it.util.schemaHasRules($sch, it.RULES.all)
                  ) {
                    var $prop = it.util.getProperty($propertyKey),
                      $passData = $data + $prop,
                      $hasDefault = $useDefaults && $sch["default"] !== undefined;
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + $prop;
                    $it.errSchemaPath =
                      $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
                    $it.errorPath = it.util.getPath(
                      it.errorPath,
                      $propertyKey,
                      it.opts.jsonPointers
                    );
                    $it.dataPathArr[$dataNxt] =
                      it.util.toQuotedString($propertyKey);
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                      $code = it.util.varReplace($code, $nextData, $passData);
                      var $useData = $passData;
                    } else {
                      var $useData = $nextData;
                      out += " var " + $nextData + " = " + $passData + "; ";
                    }
                    if ($hasDefault) {
                      out += " " + $code + " ";
                    } else {
                      if ($requiredHash && $requiredHash[$propertyKey]) {
                        out += " if ( " + $useData + " === undefined ";
                        if ($ownProperties) {
                          out +=
                            " || ! Object.prototype.hasOwnProperty.call(" +
                            $data +
                            ", '" +
                            it.util.escapeQuotes($propertyKey) +
                            "') ";
                        }
                        out += ") { " + $nextValid + " = false; ";
                        var $currentErrorPath = it.errorPath,
                          $currErrSchemaPath = $errSchemaPath,
                          $missingProperty = it.util.escapeQuotes($propertyKey);
                        if (it.opts._errorDataPathProperty) {
                          it.errorPath = it.util.getPath(
                            $currentErrorPath,
                            $propertyKey,
                            it.opts.jsonPointers
                          );
                        }
                        $errSchemaPath = it.errSchemaPath + "/required";
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = "";
                        /* istanbul ignore else */ if (
                          it.createErrors !== false
                        ) {
                          out +=
                            " { keyword: '" +
                            "required" +
                            "' , dataPath: (dataPath || '') + " +
                            it.errorPath +
                            " , schemaPath: " +
                            it.util.toQuotedString($errSchemaPath) +
                            " , params: { missingProperty: '" +
                            $missingProperty +
                            "' } ";
                          if (it.opts.messages !== false) {
                            out += " , message: '";
                            if (it.opts._errorDataPathProperty) {
                              out += "is a required property";
                            } else {
                              out +=
                                "should have required property \\'" +
                                $missingProperty +
                                "\\'";
                            }
                            out += "' ";
                          }
                          if (it.opts.verbose) {
                            out +=
                              " , schema: validate.schema" +
                              $schemaPath +
                              " , parentSchema: validate.schema" +
                              it.schemaPath +
                              " , data: " +
                              $data +
                              " ";
                          }
                          out += " } ";
                        } else {
                          out += " {} ";
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                          /* istanbul ignore if */ if (it.async) {
                            out +=
                              " throw new ValidationError([" + __err + "]); ";
                          } else {
                            out +=
                              " validate.errors = [" +
                              __err +
                              "]; return false; ";
                          }
                        } else {
                          out +=
                            " var err = " +
                            __err +
                            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                        }
                        $errSchemaPath = $currErrSchemaPath;
                        it.errorPath = $currentErrorPath;
                        out += " } else { ";
                      } else {
                        if ($breakOnError) {
                          out += " if ( " + $useData + " === undefined ";
                          if ($ownProperties) {
                            out +=
                              " || ! Object.prototype.hasOwnProperty.call(" +
                              $data +
                              ", '" +
                              it.util.escapeQuotes($propertyKey) +
                              "') ";
                          }
                          out += ") { " + $nextValid + " = true; } else { ";
                        } else {
                          out += " if (" + $useData + " !== undefined ";
                          if ($ownProperties) {
                            out +=
                              " &&   Object.prototype.hasOwnProperty.call(" +
                              $data +
                              ", '" +
                              it.util.escapeQuotes($propertyKey) +
                              "') ";
                          }
                          out += " ) { ";
                        }
                      }
                      out += " " + $code + " } ";
                    }
                  }
                  if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                  }
                }
              }
            }
            if ($pPropertyKeys.length) {
              var arr4 = $pPropertyKeys;
              if (arr4) {
                var $pProperty,
                  i4 = -1,
                  l4 = arr4.length - 1;
                while (i4 < l4) {
                  $pProperty = arr4[(i4 += 1)];
                  var $sch = $pProperties[$pProperty];
                  if (
                    it.opts.strictKeywords
                      ? (_typeof2($sch) == "object" &&
                          Object.keys($sch).length > 0) ||
                        $sch === false
                      : it.util.schemaHasRules($sch, it.RULES.all)
                  ) {
                    $it.schema = $sch;
                    $it.schemaPath =
                      it.schemaPath +
                      ".patternProperties" +
                      it.util.getProperty($pProperty);
                    $it.errSchemaPath =
                      it.errSchemaPath +
                      "/patternProperties/" +
                      it.util.escapeFragment($pProperty);
                    if ($ownProperties) {
                      out +=
                        " " +
                        $dataProperties +
                        " = " +
                        $dataProperties +
                        " || Object.keys(" +
                        $data +
                        "); for (var " +
                        $idx +
                        "=0; " +
                        $idx +
                        "<" +
                        $dataProperties +
                        ".length; " +
                        $idx +
                        "++) { var " +
                        $key +
                        " = " +
                        $dataProperties +
                        "[" +
                        $idx +
                        "]; ";
                    } else {
                      out += " for (var " + $key + " in " + $data + ") { ";
                    }
                    out +=
                      " if (" +
                      it.usePattern($pProperty) +
                      ".test(" +
                      $key +
                      ")) { ";
                    $it.errorPath = it.util.getPathExpr(
                      it.errorPath,
                      $key,
                      it.opts.jsonPointers
                    );
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                      out +=
                        " " +
                        it.util.varReplace($code, $nextData, $passData) +
                        " ";
                    } else {
                      out +=
                        " var " +
                        $nextData +
                        " = " +
                        $passData +
                        "; " +
                        $code +
                        " ";
                    }
                    if ($breakOnError) {
                      out += " if (!" + $nextValid + ") break; ";
                    }
                    out += " } ";
                    if ($breakOnError) {
                      out += " else " + $nextValid + " = true; ";
                    }
                    out += " }  ";
                    if ($breakOnError) {
                      out += " if (" + $nextValid + ") { ";
                      $closingBraces += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces + " if (" + $errs + " == errors) {";
            }
            return out;
          };
        },
        {}
      ],
      143: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_propertyNames(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $errs = "errs__" + $lvl;
            var $it = it.util.copy(it);
            var $closingBraces = "";
            $it.level++;
            var $nextValid = "valid" + $it.level;
            out += "var " + $errs + " = errors;";
            if (
              it.opts.strictKeywords
                ? (_typeof2($schema) == "object" &&
                    Object.keys($schema).length > 0) ||
                  $schema === false
                : it.util.schemaHasRules($schema, it.RULES.all)
            ) {
              $it.schema = $schema;
              $it.schemaPath = $schemaPath;
              $it.errSchemaPath = $errSchemaPath;
              var $key = "key" + $lvl,
                $idx = "idx" + $lvl,
                $i = "i" + $lvl,
                $invalidName = "' + " + $key + " + '",
                $dataNxt = ($it.dataLevel = it.dataLevel + 1),
                $nextData = "data" + $dataNxt,
                $dataProperties = "dataProperties" + $lvl,
                $ownProperties = it.opts.ownProperties,
                $currentBaseId = it.baseId;
              if ($ownProperties) {
                out += " var " + $dataProperties + " = undefined; ";
              }
              if ($ownProperties) {
                out +=
                  " " +
                  $dataProperties +
                  " = " +
                  $dataProperties +
                  " || Object.keys(" +
                  $data +
                  "); for (var " +
                  $idx +
                  "=0; " +
                  $idx +
                  "<" +
                  $dataProperties +
                  ".length; " +
                  $idx +
                  "++) { var " +
                  $key +
                  " = " +
                  $dataProperties +
                  "[" +
                  $idx +
                  "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " var startErrs" + $lvl + " = errors; ";
              var $passData = $key;
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out +=
                  " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out +=
                  " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              it.compositeRule = $it.compositeRule = $wasComposite;
              out +=
                " if (!" +
                $nextValid +
                ") { for (var " +
                $i +
                "=startErrs" +
                $lvl +
                "; " +
                $i +
                "<errors; " +
                $i +
                "++) { vErrors[" +
                $i +
                "].propertyName = " +
                $key +
                "; }   var err =   ";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "propertyNames" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { propertyName: '" +
                  $invalidName +
                  "' } ";
                if (it.opts.messages !== false) {
                  out +=
                    " , message: 'property name \\'" +
                    $invalidName +
                    "\\' is invalid' ";
                }
                if (it.opts.verbose) {
                  out +=
                    " , schema: validate.schema" +
                    $schemaPath +
                    " , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out +=
                ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError(vErrors); ";
                } else {
                  out += " validate.errors = vErrors; return false; ";
                }
              }
              if ($breakOnError) {
                out += " break; ";
              }
              out += " } }";
            }
            if ($breakOnError) {
              out += " " + $closingBraces + " if (" + $errs + " == errors) {";
            }
            return out;
          };
        },
        {}
      ],
      144: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_ref(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $async, $refCode;
            if ($schema == "#" || $schema == "#/") {
              if (it.isRoot) {
                $async = it.async;
                $refCode = "validate";
              } else {
                $async = it.root.schema.$async === true;
                $refCode = "root.refVal[0]";
              }
            } else {
              var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
              if ($refVal === undefined) {
                var $message = it.MissingRefError.message(it.baseId, $schema);
                if (it.opts.missingRefs == "fail") {
                  it.logger.error($message);
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      "$ref" +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { ref: '" +
                      it.util.escapeQuotes($schema) +
                      "' } ";
                    if (it.opts.messages !== false) {
                      out +=
                        " , message: 'can\\'t resolve reference " +
                        it.util.escapeQuotes($schema) +
                        "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: " +
                        it.util.toQuotedString($schema) +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  if ($breakOnError) {
                    out += " if (false) { ";
                  }
                } else if (it.opts.missingRefs == "ignore") {
                  it.logger.warn($message);
                  if ($breakOnError) {
                    out += " if (true) { ";
                  }
                } else {
                  throw new it.MissingRefError(it.baseId, $schema, $message);
                }
              } else if ($refVal.inline) {
                var $it = it.util.copy(it);
                $it.level++;
                var $nextValid = "valid" + $it.level;
                $it.schema = $refVal.schema;
                $it.schemaPath = "";
                $it.errSchemaPath = $schema;
                var $code = it
                  .validate($it)
                  .replace(/validate\.schema/g, $refVal.code);
                out += " " + $code + " ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                }
              } else {
                $async =
                  $refVal.$async === true ||
                  (it.async && $refVal.$async !== false);
                $refCode = $refVal.code;
              }
            }
            if ($refCode) {
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.opts.passContext) {
                out += " " + $refCode + ".call(this, ";
              } else {
                out += " " + $refCode + "( ";
              }
              out += " " + $data + ", (dataPath || '')";
              if (it.errorPath != '""') {
                out += " + " + it.errorPath;
              }
              var $parentData = $dataLvl
                  ? "data" + ($dataLvl - 1 || "")
                  : "parentData",
                $parentDataProperty = $dataLvl
                  ? it.dataPathArr[$dataLvl]
                  : "parentDataProperty";
              out +=
                " , " +
                $parentData +
                " , " +
                $parentDataProperty +
                ", rootData)  ";
              var __callValidate = out;
              out = $$outStack.pop();
              if ($async) {
                if (!it.async)
                  throw new Error("async schema referenced by sync schema");
                if ($breakOnError) {
                  out += " var " + $valid + "; ";
                }
                out += " try { /*await*/ " + __callValidate + "; ";
                if ($breakOnError) {
                  out += " " + $valid + " = true; ";
                }
                out +=
                  " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
                if ($breakOnError) {
                  out += " " + $valid + " = false; ";
                }
                out += " } ";
                if ($breakOnError) {
                  out += " if (" + $valid + ") { ";
                }
              } else {
                out +=
                  " if (!" +
                  __callValidate +
                  ") { if (vErrors === null) vErrors = " +
                  $refCode +
                  ".errors; else vErrors = vErrors.concat(" +
                  $refCode +
                  ".errors); errors = vErrors.length; } ";
                if ($breakOnError) {
                  out += " else { ";
                }
              }
            }
            return out;
          };
        },
        {}
      ],
      145: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_required(it, $keyword, $ruleType) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            var $vSchema = "schema" + $lvl;
            if (!$isData) {
              if (
                $schema.length < it.opts.loopRequired &&
                it.schema.properties &&
                Object.keys(it.schema.properties).length
              ) {
                var $required = [];
                var arr1 = $schema;
                if (arr1) {
                  var $property,
                    i1 = -1,
                    l1 = arr1.length - 1;
                  while (i1 < l1) {
                    $property = arr1[(i1 += 1)];
                    var $propertySch = it.schema.properties[$property];
                    if (
                      !(
                        $propertySch &&
                        (it.opts.strictKeywords
                          ? (_typeof2($propertySch) == "object" &&
                              Object.keys($propertySch).length > 0) ||
                            $propertySch === false
                          : it.util.schemaHasRules($propertySch, it.RULES.all))
                      )
                    ) {
                      $required[$required.length] = $property;
                    }
                  }
                }
              } else {
                var $required = $schema;
              }
            }
            if ($isData || $required.length) {
              var $currentErrorPath = it.errorPath,
                $loopRequired =
                  $isData || $required.length >= it.opts.loopRequired,
                $ownProperties = it.opts.ownProperties;
              if ($breakOnError) {
                out += " var missing" + $lvl + "; ";
                if ($loopRequired) {
                  if (!$isData) {
                    out +=
                      " var " +
                      $vSchema +
                      " = validate.schema" +
                      $schemaPath +
                      "; ";
                  }
                  var $i = "i" + $lvl,
                    $propertyPath = "schema" + $lvl + "[" + $i + "]",
                    $missingProperty = "' + " + $propertyPath + " + '";
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPathExpr(
                      $currentErrorPath,
                      $propertyPath,
                      it.opts.jsonPointers
                    );
                  }
                  out += " var " + $valid + " = true; ";
                  if ($isData) {
                    out +=
                      " if (schema" +
                      $lvl +
                      " === undefined) " +
                      $valid +
                      " = true; else if (!Array.isArray(schema" +
                      $lvl +
                      ")) " +
                      $valid +
                      " = false; else {";
                  }
                  out +=
                    " for (var " +
                    $i +
                    " = 0; " +
                    $i +
                    " < " +
                    $vSchema +
                    ".length; " +
                    $i +
                    "++) { " +
                    $valid +
                    " = " +
                    $data +
                    "[" +
                    $vSchema +
                    "[" +
                    $i +
                    "]] !== undefined ";
                  if ($ownProperties) {
                    out +=
                      " &&   Object.prototype.hasOwnProperty.call(" +
                      $data +
                      ", " +
                      $vSchema +
                      "[" +
                      $i +
                      "]) ";
                  }
                  out += "; if (!" + $valid + ") break; } ";
                  if ($isData) {
                    out += "  }  ";
                  }
                  out += "  if (!" + $valid + ") {   ";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      "required" +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { missingProperty: '" +
                      $missingProperty +
                      "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out +=
                          "should have required property \\'" +
                          $missingProperty +
                          "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } else { ";
                } else {
                  out += " if ( ";
                  var arr2 = $required;
                  if (arr2) {
                    var $propertyKey,
                      $i = -1,
                      l2 = arr2.length - 1;
                    while ($i < l2) {
                      $propertyKey = arr2[($i += 1)];
                      if ($i) {
                        out += " || ";
                      }
                      var $prop = it.util.getProperty($propertyKey),
                        $useData = $data + $prop;
                      out += " ( ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out +=
                          " || ! Object.prototype.hasOwnProperty.call(" +
                          $data +
                          ", '" +
                          it.util.escapeQuotes($propertyKey) +
                          "') ";
                      }
                      out +=
                        ") && (missing" +
                        $lvl +
                        " = " +
                        it.util.toQuotedString(
                          it.opts.jsonPointers ? $propertyKey : $prop
                        ) +
                        ") ) ";
                    }
                  }
                  out += ") {  ";
                  var $propertyPath = "missing" + $lvl,
                    $missingProperty = "' + " + $propertyPath + " + '";
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.opts.jsonPointers
                      ? it.util.getPathExpr(
                          $currentErrorPath,
                          $propertyPath,
                          true
                        )
                      : $currentErrorPath + " + " + $propertyPath;
                  }
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      "required" +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { missingProperty: '" +
                      $missingProperty +
                      "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out +=
                          "should have required property \\'" +
                          $missingProperty +
                          "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } else { ";
                }
              } else {
                if ($loopRequired) {
                  if (!$isData) {
                    out +=
                      " var " +
                      $vSchema +
                      " = validate.schema" +
                      $schemaPath +
                      "; ";
                  }
                  var $i = "i" + $lvl,
                    $propertyPath = "schema" + $lvl + "[" + $i + "]",
                    $missingProperty = "' + " + $propertyPath + " + '";
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPathExpr(
                      $currentErrorPath,
                      $propertyPath,
                      it.opts.jsonPointers
                    );
                  }
                  if ($isData) {
                    out +=
                      " if (" +
                      $vSchema +
                      " && !Array.isArray(" +
                      $vSchema +
                      ")) {  var err =   ";
                    /* istanbul ignore else */ if (it.createErrors !== false) {
                      out +=
                        " { keyword: '" +
                        "required" +
                        "' , dataPath: (dataPath || '') + " +
                        it.errorPath +
                        " , schemaPath: " +
                        it.util.toQuotedString($errSchemaPath) +
                        " , params: { missingProperty: '" +
                        $missingProperty +
                        "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) {
                          out += "is a required property";
                        } else {
                          out +=
                            "should have required property \\'" +
                            $missingProperty +
                            "\\'";
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out +=
                          " , schema: validate.schema" +
                          $schemaPath +
                          " , parentSchema: validate.schema" +
                          it.schemaPath +
                          " , data: " +
                          $data +
                          " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    out +=
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" +
                      $vSchema +
                      " !== undefined) { ";
                  }
                  out +=
                    " for (var " +
                    $i +
                    " = 0; " +
                    $i +
                    " < " +
                    $vSchema +
                    ".length; " +
                    $i +
                    "++) { if (" +
                    $data +
                    "[" +
                    $vSchema +
                    "[" +
                    $i +
                    "]] === undefined ";
                  if ($ownProperties) {
                    out +=
                      " || ! Object.prototype.hasOwnProperty.call(" +
                      $data +
                      ", " +
                      $vSchema +
                      "[" +
                      $i +
                      "]) ";
                  }
                  out += ") {  var err =   ";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      "required" +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { missingProperty: '" +
                      $missingProperty +
                      "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out +=
                          "should have required property \\'" +
                          $missingProperty +
                          "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out +=
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
                  if ($isData) {
                    out += "  }  ";
                  }
                } else {
                  var arr3 = $required;
                  if (arr3) {
                    var $propertyKey,
                      i3 = -1,
                      l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[(i3 += 1)];
                      var $prop = it.util.getProperty($propertyKey),
                        $missingProperty = it.util.escapeQuotes($propertyKey),
                        $useData = $data + $prop;
                      if (it.opts._errorDataPathProperty) {
                        it.errorPath = it.util.getPath(
                          $currentErrorPath,
                          $propertyKey,
                          it.opts.jsonPointers
                        );
                      }
                      out += " if ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out +=
                          " || ! Object.prototype.hasOwnProperty.call(" +
                          $data +
                          ", '" +
                          it.util.escapeQuotes($propertyKey) +
                          "') ";
                      }
                      out += ") {  var err =   ";
                      /* istanbul ignore else */ if (it.createErrors !== false) {
                        out +=
                          " { keyword: '" +
                          "required" +
                          "' , dataPath: (dataPath || '') + " +
                          it.errorPath +
                          " , schemaPath: " +
                          it.util.toQuotedString($errSchemaPath) +
                          " , params: { missingProperty: '" +
                          $missingProperty +
                          "' } ";
                        if (it.opts.messages !== false) {
                          out += " , message: '";
                          if (it.opts._errorDataPathProperty) {
                            out += "is a required property";
                          } else {
                            out +=
                              "should have required property \\'" +
                              $missingProperty +
                              "\\'";
                          }
                          out += "' ";
                        }
                        if (it.opts.verbose) {
                          out +=
                            " , schema: validate.schema" +
                            $schemaPath +
                            " , parentSchema: validate.schema" +
                            it.schemaPath +
                            " , data: " +
                            $data +
                            " ";
                        }
                        out += " } ";
                      } else {
                        out += " {} ";
                      }
                      out +=
                        ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                    }
                  }
                }
              }
              it.errorPath = $currentErrorPath;
            } else if ($breakOnError) {
              out += " if (true) {";
            }
            return out;
          };
        },
        {}
      ],
      146: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_uniqueItems(
            it,
            $keyword,
            $ruleType
          ) {
            var out = " ";
            var $lvl = it.level;
            var $dataLvl = it.dataLevel;
            var $schema = it.schema[$keyword];
            var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
            var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
            var $breakOnError = !it.opts.allErrors;
            var $data = "data" + ($dataLvl || "");
            var $valid = "valid" + $lvl;
            var $isData = it.opts.$data && $schema && $schema.$data,
              $schemaValue;
            if ($isData) {
              out +=
                " var schema" +
                $lvl +
                " = " +
                it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
                "; ";
              $schemaValue = "schema" + $lvl;
            } else {
              $schemaValue = $schema;
            }
            if (($schema || $isData) && it.opts.uniqueItems !== false) {
              if ($isData) {
                out +=
                  " var " +
                  $valid +
                  "; if (" +
                  $schemaValue +
                  " === false || " +
                  $schemaValue +
                  " === undefined) " +
                  $valid +
                  " = true; else if (typeof " +
                  $schemaValue +
                  " != 'boolean') " +
                  $valid +
                  " = false; else { ";
              }
              out +=
                " var i = " +
                $data +
                ".length , " +
                $valid +
                " = true , j; if (i > 1) { ";
              var $itemType = it.schema.items && it.schema.items.type,
                $typeIsArray = Array.isArray($itemType);
              if (
                !$itemType ||
                $itemType == "object" ||
                $itemType == "array" ||
                ($typeIsArray &&
                  ($itemType.indexOf("object") >= 0 ||
                    $itemType.indexOf("array") >= 0))
              ) {
                out +=
                  " outer: for (;i--;) { for (j = i; j--;) { if (equal(" +
                  $data +
                  "[i], " +
                  $data +
                  "[j])) { " +
                  $valid +
                  " = false; break outer; } } } ";
              } else {
                out +=
                  " var itemIndices = {}, item; for (;i--;) { var item = " +
                  $data +
                  "[i]; ";
                var $method = "checkDataType" + ($typeIsArray ? "s" : "");
                out +=
                  " if (" +
                  it.util[$method](
                    $itemType,
                    "item",
                    it.opts.strictNumbers,
                    true
                  ) +
                  ") continue; ";
                if ($typeIsArray) {
                  out += " if (typeof item == 'string') item = '\"' + item; ";
                }
                out +=
                  " if (typeof itemIndices[item] == 'number') { " +
                  $valid +
                  " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
              }
              out += " } ";
              if ($isData) {
                out += "  }  ";
              }
              out += " if (!" + $valid + ") {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              /* istanbul ignore else */ if (it.createErrors !== false) {
                out +=
                  " { keyword: '" +
                  "uniqueItems" +
                  "' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  " , schemaPath: " +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { i: i, j: j } ";
                if (it.opts.messages !== false) {
                  out +=
                    " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
                }
                if (it.opts.verbose) {
                  out += " , schema:  ";
                  if ($isData) {
                    out += "validate.schema" + $schemaPath;
                  } else {
                    out += "" + $schema;
                  }
                  out +=
                    "         , parentSchema: validate.schema" +
                    it.schemaPath +
                    " , data: " +
                    $data +
                    " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out +=
                  " var err = " +
                  __err +
                  ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else { ";
              }
            } else {
              if ($breakOnError) {
                out += " if (true) { ";
              }
            }
            return out;
          };
        },
        {}
      ],
      147: [
        function (require, module, exports) {
          "use strict";
          module.exports = function generate_validate(it, $keyword, $ruleType) {
            var out = "";
            var $async = it.schema.$async === true,
              $refKeywords = it.util.schemaHasRulesExcept(
                it.schema,
                it.RULES.all,
                "$ref"
              ),
              $id = it.self._getId(it.schema);
            if (it.opts.strictKeywords) {
              var $unknownKwd = it.util.schemaUnknownRules(
                it.schema,
                it.RULES.keywords
              );
              if ($unknownKwd) {
                var $keywordsMsg = "unknown keyword: " + $unknownKwd;
                if (it.opts.strictKeywords === "log")
                  it.logger.warn($keywordsMsg);
                else throw new Error($keywordsMsg);
              }
            }
            if (it.isTop) {
              out += " var validate = ";
              if ($async) {
                it.async = true;
                out += "async ";
              }
              out +=
                "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
              if ($id && (it.opts.sourceCode || it.opts.processCode)) {
                out += " " + ("/*# sourceURL=" + $id + " */") + " ";
              }
            }
            if (
              typeof it.schema == "boolean" ||
              !($refKeywords || it.schema.$ref)
            ) {
              var $keyword = "false schema";
              var $lvl = it.level;
              var $dataLvl = it.dataLevel;
              var $schema = it.schema[$keyword];
              var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
              var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
              var $breakOnError = !it.opts.allErrors;
              var $errorKeyword;
              var $data = "data" + ($dataLvl || "");
              var $valid = "valid" + $lvl;
              if (it.schema === false) {
                if (it.isTop) {
                  $breakOnError = true;
                } else {
                  out += " var " + $valid + " = false; ";
                }
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                /* istanbul ignore else */ if (it.createErrors !== false) {
                  out +=
                    " { keyword: '" +
                    ($errorKeyword || "false schema") +
                    "' , dataPath: (dataPath || '') + " +
                    it.errorPath +
                    " , schemaPath: " +
                    it.util.toQuotedString($errSchemaPath) +
                    " , params: {} ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'boolean schema is false' ";
                  }
                  if (it.opts.verbose) {
                    out +=
                      " , schema: false , parentSchema: validate.schema" +
                      it.schemaPath +
                      " , data: " +
                      $data +
                      " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  /* istanbul ignore if */ if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out +=
                    " var err = " +
                    __err +
                    ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
              } else {
                if (it.isTop) {
                  if ($async) {
                    out += " return data; ";
                  } else {
                    out += " validate.errors = null; return true; ";
                  }
                } else {
                  out += " var " + $valid + " = true; ";
                }
              }
              if (it.isTop) {
                out += " }; return validate; ";
              }
              return out;
            }
            if (it.isTop) {
              var $top = it.isTop,
                $lvl = (it.level = 0),
                $dataLvl = (it.dataLevel = 0),
                $data = "data";
              it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
              it.baseId = it.baseId || it.rootId;
              delete it.isTop;
              it.dataPathArr = [""];
              if (
                it.schema["default"] !== undefined &&
                it.opts.useDefaults &&
                it.opts.strictDefaults
              ) {
                var $defaultMsg = "default is ignored in the schema root";
                if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                else throw new Error($defaultMsg);
              }
              out += " var vErrors = null; ";
              out += " var errors = 0;     ";
              out += " if (rootData === undefined) rootData = data; ";
            } else {
              var $lvl = it.level,
                $dataLvl = it.dataLevel,
                $data = "data" + ($dataLvl || "");
              if ($id) it.baseId = it.resolve.url(it.baseId, $id);
              if ($async && !it.async)
                throw new Error("async schema in sync schema");
              out += " var errs_" + $lvl + " = errors;";
            }
            var $valid = "valid" + $lvl,
              $breakOnError = !it.opts.allErrors,
              $closingBraces1 = "",
              $closingBraces2 = "";
            var $errorKeyword;
            var $typeSchema = it.schema.type,
              $typeIsArray = Array.isArray($typeSchema);
            if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
              if ($typeIsArray) {
                if ($typeSchema.indexOf("null") == -1)
                  $typeSchema = $typeSchema.concat("null");
              } else if ($typeSchema != "null") {
                $typeSchema = [$typeSchema, "null"];
                $typeIsArray = true;
              }
            }
            if ($typeIsArray && $typeSchema.length == 1) {
              $typeSchema = $typeSchema[0];
              $typeIsArray = false;
            }
            if (it.schema.$ref && $refKeywords) {
              if (it.opts.extendRefs == "fail") {
                throw new Error(
                  '$ref: validation keywords used in schema at path "' +
                    it.errSchemaPath +
                    '" (see option extendRefs)'
                );
              } else if (it.opts.extendRefs !== true) {
                $refKeywords = false;
                it.logger.warn(
                  '$ref: keywords ignored in schema at path "' +
                    it.errSchemaPath +
                    '"'
                );
              }
            }
            if (it.schema.$comment && it.opts.$comment) {
              out += " " + it.RULES.all.$comment.code(it, "$comment");
            }
            if ($typeSchema) {
              if (it.opts.coerceTypes) {
                var $coerceToTypes = it.util.coerceToTypes(
                  it.opts.coerceTypes,
                  $typeSchema
                );
              }
              var $rulesGroup = it.RULES.types[$typeSchema];
              if (
                $coerceToTypes ||
                $typeIsArray ||
                $rulesGroup === true ||
                ($rulesGroup && !$shouldUseGroup($rulesGroup))
              ) {
                var $schemaPath = it.schemaPath + ".type",
                  $errSchemaPath = it.errSchemaPath + "/type";
                var $schemaPath = it.schemaPath + ".type",
                  $errSchemaPath = it.errSchemaPath + "/type",
                  $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
                out +=
                  " if (" +
                  it.util[$method](
                    $typeSchema,
                    $data,
                    it.opts.strictNumbers,
                    true
                  ) +
                  ") { ";
                if ($coerceToTypes) {
                  var $dataType = "dataType" + $lvl,
                    $coerced = "coerced" + $lvl;
                  out +=
                    " var " +
                    $dataType +
                    " = typeof " +
                    $data +
                    "; var " +
                    $coerced +
                    " = undefined; ";
                  if (it.opts.coerceTypes == "array") {
                    out +=
                      " if (" +
                      $dataType +
                      " == 'object' && Array.isArray(" +
                      $data +
                      ") && " +
                      $data +
                      ".length == 1) { " +
                      $data +
                      " = " +
                      $data +
                      "[0]; " +
                      $dataType +
                      " = typeof " +
                      $data +
                      "; if (" +
                      it.util.checkDataType(
                        it.schema.type,
                        $data,
                        it.opts.strictNumbers
                      ) +
                      ") " +
                      $coerced +
                      " = " +
                      $data +
                      "; } ";
                  }
                  out += " if (" + $coerced + " !== undefined) ; ";
                  var arr1 = $coerceToTypes;
                  if (arr1) {
                    var $type,
                      $i = -1,
                      l1 = arr1.length - 1;
                    while ($i < l1) {
                      $type = arr1[($i += 1)];
                      if ($type == "string") {
                        out +=
                          " else if (" +
                          $dataType +
                          " == 'number' || " +
                          $dataType +
                          " == 'boolean') " +
                          $coerced +
                          " = '' + " +
                          $data +
                          "; else if (" +
                          $data +
                          " === null) " +
                          $coerced +
                          " = ''; ";
                      } else if ($type == "number" || $type == "integer") {
                        out +=
                          " else if (" +
                          $dataType +
                          " == 'boolean' || " +
                          $data +
                          " === null || (" +
                          $dataType +
                          " == 'string' && " +
                          $data +
                          " && " +
                          $data +
                          " == +" +
                          $data +
                          " ";
                        if ($type == "integer") {
                          out += " && !(" + $data + " % 1)";
                        }
                        out += ")) " + $coerced + " = +" + $data + "; ";
                      } else if ($type == "boolean") {
                        out +=
                          " else if (" +
                          $data +
                          " === 'false' || " +
                          $data +
                          " === 0 || " +
                          $data +
                          " === null) " +
                          $coerced +
                          " = false; else if (" +
                          $data +
                          " === 'true' || " +
                          $data +
                          " === 1) " +
                          $coerced +
                          " = true; ";
                      } else if ($type == "null") {
                        out +=
                          " else if (" +
                          $data +
                          " === '' || " +
                          $data +
                          " === 0 || " +
                          $data +
                          " === false) " +
                          $coerced +
                          " = null; ";
                      } else if (
                        it.opts.coerceTypes == "array" &&
                        $type == "array"
                      ) {
                        out +=
                          " else if (" +
                          $dataType +
                          " == 'string' || " +
                          $dataType +
                          " == 'number' || " +
                          $dataType +
                          " == 'boolean' || " +
                          $data +
                          " == null) " +
                          $coerced +
                          " = [" +
                          $data +
                          "]; ";
                      }
                    }
                  }
                  out += " else {   ";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      ($errorKeyword || "type") +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } if (" + $coerced + " !== undefined) {  ";
                  var $parentData = $dataLvl
                      ? "data" + ($dataLvl - 1 || "")
                      : "parentData",
                    $parentDataProperty = $dataLvl
                      ? it.dataPathArr[$dataLvl]
                      : "parentDataProperty";
                  out += " " + $data + " = " + $coerced + "; ";
                  if (!$dataLvl) {
                    out += "if (" + $parentData + " !== undefined)";
                  }
                  out +=
                    " " +
                    $parentData +
                    "[" +
                    $parentDataProperty +
                    "] = " +
                    $coerced +
                    "; } ";
                } else {
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  /* istanbul ignore else */ if (it.createErrors !== false) {
                    out +=
                      " { keyword: '" +
                      ($errorKeyword || "type") +
                      "' , dataPath: (dataPath || '') + " +
                      it.errorPath +
                      " , schemaPath: " +
                      it.util.toQuotedString($errSchemaPath) +
                      " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out +=
                        " , schema: validate.schema" +
                        $schemaPath +
                        " , parentSchema: validate.schema" +
                        it.schemaPath +
                        " , data: " +
                        $data +
                        " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out +=
                      " var err = " +
                      __err +
                      ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                }
                out += " } ";
              }
            }
            if (it.schema.$ref && !$refKeywords) {
              out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
              if ($breakOnError) {
                out += " } if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            } else {
              var arr2 = it.RULES;
              if (arr2) {
                var $rulesGroup,
                  i2 = -1,
                  l2 = arr2.length - 1;
                while (i2 < l2) {
                  $rulesGroup = arr2[(i2 += 1)];
                  if ($shouldUseGroup($rulesGroup)) {
                    if ($rulesGroup.type) {
                      out +=
                        " if (" +
                        it.util.checkDataType(
                          $rulesGroup.type,
                          $data,
                          it.opts.strictNumbers
                        ) +
                        ") { ";
                    }
                    if (it.opts.useDefaults) {
                      if ($rulesGroup.type == "object" && it.schema.properties) {
                        var $schema = it.schema.properties,
                          $schemaKeys = Object.keys($schema);
                        var arr3 = $schemaKeys;
                        if (arr3) {
                          var $propertyKey,
                            i3 = -1,
                            l3 = arr3.length - 1;
                          while (i3 < l3) {
                            $propertyKey = arr3[(i3 += 1)];
                            var $sch = $schema[$propertyKey];
                            if ($sch["default"] !== undefined) {
                              var $passData =
                                $data + it.util.getProperty($propertyKey);
                              if (it.compositeRule) {
                                if (it.opts.strictDefaults) {
                                  var $defaultMsg =
                                    "default is ignored for: " + $passData;
                                  if (it.opts.strictDefaults === "log")
                                    it.logger.warn($defaultMsg);
                                  else throw new Error($defaultMsg);
                                }
                              } else {
                                out += " if (" + $passData + " === undefined ";
                                if (it.opts.useDefaults == "empty") {
                                  out +=
                                    " || " +
                                    $passData +
                                    " === null || " +
                                    $passData +
                                    " === '' ";
                                }
                                out += " ) " + $passData + " = ";
                                if (it.opts.useDefaults == "shared") {
                                  out +=
                                    " " + it.useDefault($sch["default"]) + " ";
                                } else {
                                  out +=
                                    " " + JSON.stringify($sch["default"]) + " ";
                                }
                                out += "; ";
                              }
                            }
                          }
                        }
                      } else if (
                        $rulesGroup.type == "array" &&
                        Array.isArray(it.schema.items)
                      ) {
                        var arr4 = it.schema.items;
                        if (arr4) {
                          var $sch,
                            $i = -1,
                            l4 = arr4.length - 1;
                          while ($i < l4) {
                            $sch = arr4[($i += 1)];
                            if ($sch["default"] !== undefined) {
                              var $passData = $data + "[" + $i + "]";
                              if (it.compositeRule) {
                                if (it.opts.strictDefaults) {
                                  var $defaultMsg =
                                    "default is ignored for: " + $passData;
                                  if (it.opts.strictDefaults === "log")
                                    it.logger.warn($defaultMsg);
                                  else throw new Error($defaultMsg);
                                }
                              } else {
                                out += " if (" + $passData + " === undefined ";
                                if (it.opts.useDefaults == "empty") {
                                  out +=
                                    " || " +
                                    $passData +
                                    " === null || " +
                                    $passData +
                                    " === '' ";
                                }
                                out += " ) " + $passData + " = ";
                                if (it.opts.useDefaults == "shared") {
                                  out +=
                                    " " + it.useDefault($sch["default"]) + " ";
                                } else {
                                  out +=
                                    " " + JSON.stringify($sch["default"]) + " ";
                                }
                                out += "; ";
                              }
                            }
                          }
                        }
                      }
                    }
                    var arr5 = $rulesGroup.rules;
                    if (arr5) {
                      var $rule,
                        i5 = -1,
                        l5 = arr5.length - 1;
                      while (i5 < l5) {
                        $rule = arr5[(i5 += 1)];
                        if ($shouldUseRule($rule)) {
                          var $code = $rule.code(
                            it,
                            $rule.keyword,
                            $rulesGroup.type
                          );
                          if ($code) {
                            out += " " + $code + " ";
                            if ($breakOnError) {
                              $closingBraces1 += "}";
                            }
                          }
                        }
                      }
                    }
                    if ($breakOnError) {
                      out += " " + $closingBraces1 + " ";
                      $closingBraces1 = "";
                    }
                    if ($rulesGroup.type) {
                      out += " } ";
                      if (
                        $typeSchema &&
                        $typeSchema === $rulesGroup.type &&
                        !$coerceToTypes
                      ) {
                        out += " else { ";
                        var $schemaPath = it.schemaPath + ".type",
                          $errSchemaPath = it.errSchemaPath + "/type";
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = "";
                        /* istanbul ignore else */ if (
                          it.createErrors !== false
                        ) {
                          out +=
                            " { keyword: '" +
                            ($errorKeyword || "type") +
                            "' , dataPath: (dataPath || '') + " +
                            it.errorPath +
                            " , schemaPath: " +
                            it.util.toQuotedString($errSchemaPath) +
                            " , params: { type: '";
                          if ($typeIsArray) {
                            out += "" + $typeSchema.join(",");
                          } else {
                            out += "" + $typeSchema;
                          }
                          out += "' } ";
                          if (it.opts.messages !== false) {
                            out += " , message: 'should be ";
                            if ($typeIsArray) {
                              out += "" + $typeSchema.join(",");
                            } else {
                              out += "" + $typeSchema;
                            }
                            out += "' ";
                          }
                          if (it.opts.verbose) {
                            out +=
                              " , schema: validate.schema" +
                              $schemaPath +
                              " , parentSchema: validate.schema" +
                              it.schemaPath +
                              " , data: " +
                              $data +
                              " ";
                          }
                          out += " } ";
                        } else {
                          out += " {} ";
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) {
                          /* istanbul ignore if */ if (it.async) {
                            out +=
                              " throw new ValidationError([" + __err + "]); ";
                          } else {
                            out +=
                              " validate.errors = [" +
                              __err +
                              "]; return false; ";
                          }
                        } else {
                          out +=
                            " var err = " +
                            __err +
                            ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                        }
                        out += " } ";
                      }
                    }
                    if ($breakOnError) {
                      out += " if (errors === ";
                      if ($top) {
                        out += "0";
                      } else {
                        out += "errs_" + $lvl;
                      }
                      out += ") { ";
                      $closingBraces2 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces2 + " ";
            }
            if ($top) {
              if ($async) {
                out += " if (errors === 0) return data;           ";
                out += " else throw new ValidationError(vErrors); ";
              } else {
                out += " validate.errors = vErrors; ";
                out += " return errors === 0;       ";
              }
              out += " }; return validate;";
            } else {
              out += " var " + $valid + " = errors === errs_" + $lvl + ";";
            }
            function $shouldUseGroup($rulesGroup) {
              var rules = $rulesGroup.rules;
              for (var i = 0; i < rules.length; i++) {
                if ($shouldUseRule(rules[i])) return true;
              }
            }
            function $shouldUseRule($rule) {
              return (
                it.schema[$rule.keyword] !== undefined ||
                ($rule["implements"] && $ruleImplementsSomeKeyword($rule))
              );
            }
            function $ruleImplementsSomeKeyword($rule) {
              var impl = $rule["implements"];
              for (var i = 0; i < impl.length; i++) {
                if (it.schema[impl[i]] !== undefined) return true;
              }
            }
            return out;
          };
        },
        {}
      ],
      148: [
        function (require, module, exports) {
          "use strict";
          var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
          var customRuleCode = require("./dotjs/custom");
          var definitionSchema = require("./definition_schema");
          module.exports = {
            add: addKeyword,
            get: getKeyword,
            remove: removeKeyword,
            validate: validateKeyword
          };
          /**
           * Define custom keyword
           * @this  Ajv
           * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
           * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
           * @return {Ajv} this for method chaining
           */ function addKeyword(keyword, definition) {
            /* jshint validthis: true */ /* eslint no-shadow: 0 */ var RULES =
              this.RULES;
            if (RULES.keywords[keyword])
              throw new Error("Keyword " + keyword + " is already defined");
            if (!IDENTIFIER.test(keyword))
              throw new Error(
                "Keyword " + keyword + " is not a valid identifier"
              );
            if (definition) {
              this.validateKeyword(definition, true);
              var dataType = definition.type;
              if (Array.isArray(dataType)) {
                for (var i = 0; i < dataType.length; i++) {
                  _addRule(keyword, dataType[i], definition);
                }
              } else {
                _addRule(keyword, dataType, definition);
              }
              var metaSchema = definition.metaSchema;
              if (metaSchema) {
                if (definition.$data && this._opts.$data) {
                  metaSchema = {
                    anyOf: [
                      metaSchema,
                      {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                      }
                    ]
                  };
                }
                definition.validateSchema = this.compile(metaSchema, true);
              }
            }
            RULES.keywords[keyword] = RULES.all[keyword] = true;
            function _addRule(keyword, dataType, definition) {
              var ruleGroup;
              for (var i = 0; i < RULES.length; i++) {
                var rg = RULES[i];
                if (rg.type == dataType) {
                  ruleGroup = rg;
                  break;
                }
              }
              if (!ruleGroup) {
                ruleGroup = { type: dataType, rules: [] };
                RULES.push(ruleGroup);
              }
              var rule = {
                keyword: keyword,
                definition: definition,
                custom: true,
                code: customRuleCode,
                implements: definition["implements"]
              };
              ruleGroup.rules.push(rule);
              RULES.custom[keyword] = rule;
            }
            return this;
          }
          /**
           * Get keyword
           * @this  Ajv
           * @param {String} keyword pre-defined or custom keyword.
           * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
           */ function getKeyword(keyword) {
            /* jshint validthis: true */ var rule = this.RULES.custom[keyword];
            return rule ? rule.definition : this.RULES.keywords[keyword] || false;
          }
          /**
           * Remove keyword
           * @this  Ajv
           * @param {String} keyword pre-defined or custom keyword.
           * @return {Ajv} this for method chaining
           */ function removeKeyword(keyword) {
            /* jshint validthis: true */ var RULES = this.RULES;
            delete RULES.keywords[keyword];
            delete RULES.all[keyword];
            delete RULES.custom[keyword];
            for (var i = 0; i < RULES.length; i++) {
              var rules = RULES[i].rules;
              for (var j = 0; j < rules.length; j++) {
                if (rules[j].keyword == keyword) {
                  rules.splice(j, 1);
                  break;
                }
              }
            }
            return this;
          }
          /**
           * Validate keyword definition
           * @this  Ajv
           * @param {Object} definition keyword definition object.
           * @param {Boolean} throwError true to throw exception if definition is invalid
           * @return {boolean} validation result
           */ function validateKeyword(definition, throwError) {
            validateKeyword.errors = null;
            var v = (this._validateKeyword =
              this._validateKeyword || this.compile(definitionSchema, true));
            if (v(definition)) return true;
            validateKeyword.errors = v.errors;
            if (throwError)
              throw new Error(
                "custom keyword definition is invalid: " +
                  this.errorsText(v.errors)
              );
            else return false;
          }
        },
        { "./definition_schema": 121, "./dotjs/custom": 131 }
      ],
      149: [
        function (require, module, exports) {
          module.exports = {
            $schema: "http://json-schema.org/draft-07/schema#",
            $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
            description:
              "Meta-schema for $data reference (JSON Schema extension proposal)",
            type: "object",
            required: ["$data"],
            properties: {
              $data: {
                type: "string",
                anyOf: [
                  { format: "relative-json-pointer" },
                  { format: "json-pointer" }
                ]
              }
            },
            additionalProperties: false
          };
        },
        {}
      ],
      150: [
        function (require, module, exports) {
          module.exports = {
            id: "http://json-schema.org/draft-04/schema#",
            $schema: "http://json-schema.org/draft-04/schema#",
            description: "Core schema meta-schema",
            definitions: {
              schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
              positiveInteger: { type: "integer", minimum: 0 },
              positiveIntegerDefault0: {
                allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
              },
              simpleTypes: {
                enum: [
                  "array",
                  "boolean",
                  "integer",
                  "null",
                  "number",
                  "object",
                  "string"
                ]
              },
              stringArray: {
                type: "array",
                items: { type: "string" },
                minItems: 1,
                uniqueItems: true
              }
            },
            type: "object",
            properties: {
              id: { type: "string" },
              $schema: { type: "string" },
              title: { type: "string" },
              description: { type: "string" },
              default: {},
              multipleOf: { type: "number", minimum: 0, exclusiveMinimum: true },
              maximum: { type: "number" },
              exclusiveMaximum: { type: "boolean", default: false },
              minimum: { type: "number" },
              exclusiveMinimum: { type: "boolean", default: false },
              maxLength: { $ref: "#/definitions/positiveInteger" },
              minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
              pattern: { type: "string", format: "regex" },
              additionalItems: {
                anyOf: [{ type: "boolean" }, { $ref: "#" }],
                default: {}
              },
              items: {
                anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
                default: {}
              },
              maxItems: { $ref: "#/definitions/positiveInteger" },
              minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
              uniqueItems: { type: "boolean", default: false },
              maxProperties: { $ref: "#/definitions/positiveInteger" },
              minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
              required: { $ref: "#/definitions/stringArray" },
              additionalProperties: {
                anyOf: [{ type: "boolean" }, { $ref: "#" }],
                default: {}
              },
              definitions: {
                type: "object",
                additionalProperties: { $ref: "#" },
                default: {}
              },
              properties: {
                type: "object",
                additionalProperties: { $ref: "#" },
                default: {}
              },
              patternProperties: {
                type: "object",
                additionalProperties: { $ref: "#" },
                default: {}
              },
              dependencies: {
                type: "object",
                additionalProperties: {
                  anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
                }
              },
              enum: { type: "array", minItems: 1, uniqueItems: true },
              type: {
                anyOf: [
                  { $ref: "#/definitions/simpleTypes" },
                  {
                    type: "array",
                    items: { $ref: "#/definitions/simpleTypes" },
                    minItems: 1,
                    uniqueItems: true
                  }
                ]
              },
              format: { type: "string" },
              allOf: { $ref: "#/definitions/schemaArray" },
              anyOf: { $ref: "#/definitions/schemaArray" },
              oneOf: { $ref: "#/definitions/schemaArray" },
              not: { $ref: "#" }
            },
            dependencies: {
              exclusiveMaximum: ["maximum"],
              exclusiveMinimum: ["minimum"]
            },
            default: {}
          };
        },
        {}
      ],
      151: [
        function (require, module, exports) {
          module.exports = {
            $schema: "http://json-schema.org/draft-07/schema#",
            $id: "http://json-schema.org/draft-07/schema#",
            title: "Core schema meta-schema",
            definitions: {
              schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
              nonNegativeInteger: { type: "integer", minimum: 0 },
              nonNegativeIntegerDefault0: {
                allOf: [
                  { $ref: "#/definitions/nonNegativeInteger" },
                  { default: 0 }
                ]
              },
              simpleTypes: {
                enum: [
                  "array",
                  "boolean",
                  "integer",
                  "null",
                  "number",
                  "object",
                  "string"
                ]
              },
              stringArray: {
                type: "array",
                items: { type: "string" },
                uniqueItems: true,
                default: []
              }
            },
            type: ["object", "boolean"],
            properties: {
              $id: { type: "string", format: "uri-reference" },
              $schema: { type: "string", format: "uri" },
              $ref: { type: "string", format: "uri-reference" },
              $comment: { type: "string" },
              title: { type: "string" },
              description: { type: "string" },
              default: true,
              readOnly: { type: "boolean", default: false },
              examples: { type: "array", items: true },
              multipleOf: { type: "number", exclusiveMinimum: 0 },
              maximum: { type: "number" },
              exclusiveMaximum: { type: "number" },
              minimum: { type: "number" },
              exclusiveMinimum: { type: "number" },
              maxLength: { $ref: "#/definitions/nonNegativeInteger" },
              minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
              pattern: { type: "string", format: "regex" },
              additionalItems: { $ref: "#" },
              items: {
                anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
                default: true
              },
              maxItems: { $ref: "#/definitions/nonNegativeInteger" },
              minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
              uniqueItems: { type: "boolean", default: false },
              contains: { $ref: "#" },
              maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
              minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
              required: { $ref: "#/definitions/stringArray" },
              additionalProperties: { $ref: "#" },
              definitions: {
                type: "object",
                additionalProperties: { $ref: "#" },
                default: {}
              },
              properties: {
                type: "object",
                additionalProperties: { $ref: "#" },
                default: {}
              },
              patternProperties: {
                type: "object",
                additionalProperties: { $ref: "#" },
                propertyNames: { format: "regex" },
                default: {}
              },
              dependencies: {
                type: "object",
                additionalProperties: {
                  anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
                }
              },
              propertyNames: { $ref: "#" },
              const: true,
              enum: {
                type: "array",
                items: true,
                minItems: 1,
                uniqueItems: true
              },
              type: {
                anyOf: [
                  { $ref: "#/definitions/simpleTypes" },
                  {
                    type: "array",
                    items: { $ref: "#/definitions/simpleTypes" },
                    minItems: 1,
                    uniqueItems: true
                  }
                ]
              },
              format: { type: "string" },
              contentMediaType: { type: "string" },
              contentEncoding: { type: "string" },
              if: { $ref: "#" },
              then: { $ref: "#" },
              else: { $ref: "#" },
              allOf: { $ref: "#/definitions/schemaArray" },
              anyOf: { $ref: "#/definitions/schemaArray" },
              oneOf: { $ref: "#/definitions/schemaArray" },
              not: { $ref: "#" }
            },
            default: true
          };
        },
        {}
      ],
      152: [
        function (require, module, exports) {
          (function (process, global) {
            (function () {
              "use strict";
              var next =
                (global.process && process.nextTick) ||
                global.setImmediate ||
                function (f) {
                  setTimeout(f, 0);
                };
              module.exports = function maybe(cb, promise) {
                if (cb) {
                  promise.then(
                    function (result) {
                      next(function () {
                        cb(null, result);
                      });
                    },
                    function (err) {
                      next(function () {
                        cb(err);
                      });
                    }
                  );
                  return undefined;
                } else {
                  return promise;
                }
              };
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        { _process: 246 }
      ],
      153: [
        function (require, module, exports) {
          "use strict"; // do not edit .js files directly - edit src/index.jst
          module.exports = function equal(a, b) {
            if (a === b) return true;
            if (a && b && _typeof2(a) == "object" && _typeof2(b) == "object") {
              if (a.constructor !== b.constructor) return false;
              var length, i, keys;
              if (Array.isArray(a)) {
                length = a.length;
                if (length != b.length) return false;
                for (i = length; i-- !== 0; ) {
                  if (!equal(a[i], b[i])) return false;
                }
                return true;
              }
              if (a.constructor === RegExp)
                return a.source === b.source && a.flags === b.flags;
              if (a.valueOf !== Object.prototype.valueOf)
                return a.valueOf() === b.valueOf();
              if (a.toString !== Object.prototype.toString)
                return a.toString() === b.toString();
              keys = Object.keys(a);
              length = keys.length;
              if (length !== Object.keys(b).length) return false;
              for (i = length; i-- !== 0; ) {
                if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
                  return false;
              }
              for (i = length; i-- !== 0; ) {
                var key = keys[i];
                if (!equal(a[key], b[key])) return false;
              }
              return true;
            } // true if both NaN, false otherwise
            return a !== a && b !== b;
          };
        },
        {}
      ],
      154: [
        function (require, module, exports) {
          "use strict";
          module.exports = function (data, opts) {
            if (!opts) opts = {};
            if (typeof opts === "function") opts = { cmp: opts };
            var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
            var cmp =
              opts.cmp &&
              (function (f) {
                return function (node) {
                  return function (a, b) {
                    var aobj = { key: a, value: node[a] };
                    var bobj = { key: b, value: node[b] };
                    return f(aobj, bobj);
                  };
                };
              })(opts.cmp);
            var seen = [];
            return (function stringify(node) {
              if (node && node.toJSON && typeof node.toJSON === "function") {
                node = node.toJSON();
              }
              if (node === undefined) return;
              if (typeof node == "number")
                return isFinite(node) ? "" + node : "null";
              if (_typeof2(node) !== "object") return JSON.stringify(node);
              var i, out;
              if (Array.isArray(node)) {
                out = "[";
                for (i = 0; i < node.length; i++) {
                  if (i) out += ",";
                  out += stringify(node[i]) || "null";
                }
                return out + "]";
              }
              if (node === null) return "null";
              if (seen.indexOf(node) !== -1) {
                if (cycles) return JSON.stringify("__cycle__");
                throw new TypeError("Converting circular structure to JSON");
              }
              var seenIndex = seen.push(node) - 1;
              var keys = Object.keys(node).sort(cmp && cmp(node));
              out = "";
              for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node[key]);
                if (!value) continue;
                if (out) out += ",";
                out += JSON.stringify(key) + ":" + value;
              }
              seen.splice(seenIndex, 1);
              return "{" + out + "}";
            })(data);
          };
        },
        {}
      ],
      155: [
        function (require, module, exports) {
          "use strict";
          var yaml = require("./lib/js-yaml.js");
          module.exports = yaml;
        },
        { "./lib/js-yaml.js": 156 }
      ],
      156: [
        function (require, module, exports) {
          "use strict";
          var loader = require("./js-yaml/loader");
          var dumper = require("./js-yaml/dumper");
          function deprecated(name) {
            return function () {
              throw new Error(
                "Function " + name + " is deprecated and cannot be used."
              );
            };
          }
          module.exports.Type = require("./js-yaml/type");
          module.exports.Schema = require("./js-yaml/schema");
          module.exports.FAILSAFE_SCHEMA = require("./js-yaml/schema/failsafe");
          module.exports.JSON_SCHEMA = require("./js-yaml/schema/json");
          module.exports.CORE_SCHEMA = require("./js-yaml/schema/core");
          module.exports.DEFAULT_SAFE_SCHEMA = require("./js-yaml/schema/default_safe");
          module.exports.DEFAULT_FULL_SCHEMA = require("./js-yaml/schema/default_full");
          module.exports.load = loader.load;
          module.exports.loadAll = loader.loadAll;
          module.exports.safeLoad = loader.safeLoad;
          module.exports.safeLoadAll = loader.safeLoadAll;
          module.exports.dump = dumper.dump;
          module.exports.safeDump = dumper.safeDump;
          module.exports.YAMLException = require("./js-yaml/exception"); // Deprecated schema names from JS-YAML 2.0.x
          module.exports.MINIMAL_SCHEMA = require("./js-yaml/schema/failsafe");
          module.exports.SAFE_SCHEMA = require("./js-yaml/schema/default_safe");
          module.exports.DEFAULT_SCHEMA = require("./js-yaml/schema/default_full"); // Deprecated functions from JS-YAML 1.x.x
          module.exports.scan = deprecated("scan");
          module.exports.parse = deprecated("parse");
          module.exports.compose = deprecated("compose");
          module.exports.addConstructor = deprecated("addConstructor");
        },
        {
          "./js-yaml/dumper": 158,
          "./js-yaml/exception": 159,
          "./js-yaml/loader": 160,
          "./js-yaml/schema": 162,
          "./js-yaml/schema/core": 163,
          "./js-yaml/schema/default_full": 164,
          "./js-yaml/schema/default_safe": 165,
          "./js-yaml/schema/failsafe": 166,
          "./js-yaml/schema/json": 167,
          "./js-yaml/type": 168
        }
      ],
      157: [
        function (require, module, exports) {
          arguments[4][21][0].apply(exports, arguments);
        },
        { dup: 21 }
      ],
      158: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable no-use-before-define*/ var common = require("./common");
          var YAMLException = require("./exception");
          var DEFAULT_FULL_SCHEMA = require("./schema/default_full");
          var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");
          var _toString = Object.prototype.toString;
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CHAR_TAB = 0x09;
          /* Tab */ var CHAR_LINE_FEED = 0x0a;
          /* LF */ var CHAR_CARRIAGE_RETURN = 0x0d;
          /* CR */ var CHAR_SPACE = 0x20;
          /* Space */ var CHAR_EXCLAMATION = 0x21;
          /* ! */ var CHAR_DOUBLE_QUOTE = 0x22;
          /* " */ var CHAR_SHARP = 0x23;
          /* # */ var CHAR_PERCENT = 0x25;
          /* % */ var CHAR_AMPERSAND = 0x26;
          /* & */ var CHAR_SINGLE_QUOTE = 0x27;
          /* ' */ var CHAR_ASTERISK = 0x2a;
          /* * */ var CHAR_COMMA = 0x2c;
          /* , */ var CHAR_MINUS = 0x2d;
          /* - */ var CHAR_COLON = 0x3a;
          /* : */ var CHAR_EQUALS = 0x3d;
          /* = */ var CHAR_GREATER_THAN = 0x3e;
          /* > */ var CHAR_QUESTION = 0x3f;
          /* ? */ var CHAR_COMMERCIAL_AT = 0x40;
          /* @ */ var CHAR_LEFT_SQUARE_BRACKET = 0x5b;
          /* [ */ var CHAR_RIGHT_SQUARE_BRACKET = 0x5d;
          /* ] */ var CHAR_GRAVE_ACCENT = 0x60;
          /* ` */ var CHAR_LEFT_CURLY_BRACKET = 0x7b;
          /* { */ var CHAR_VERTICAL_LINE = 0x7c;
          /* | */ var CHAR_RIGHT_CURLY_BRACKET = 0x7d;
          /* } */ var ESCAPE_SEQUENCES = {};
          ESCAPE_SEQUENCES[0x00] = "\\0";
          ESCAPE_SEQUENCES[0x07] = "\\a";
          ESCAPE_SEQUENCES[0x08] = "\\b";
          ESCAPE_SEQUENCES[0x09] = "\\t";
          ESCAPE_SEQUENCES[0x0a] = "\\n";
          ESCAPE_SEQUENCES[0x0b] = "\\v";
          ESCAPE_SEQUENCES[0x0c] = "\\f";
          ESCAPE_SEQUENCES[0x0d] = "\\r";
          ESCAPE_SEQUENCES[0x1b] = "\\e";
          ESCAPE_SEQUENCES[0x22] = '\\"';
          ESCAPE_SEQUENCES[0x5c] = "\\\\";
          ESCAPE_SEQUENCES[0x85] = "\\N";
          ESCAPE_SEQUENCES[0xa0] = "\\_";
          ESCAPE_SEQUENCES[0x2028] = "\\L";
          ESCAPE_SEQUENCES[0x2029] = "\\P";
          var DEPRECATED_BOOLEANS_SYNTAX = [
            "y",
            "Y",
            "yes",
            "Yes",
            "YES",
            "on",
            "On",
            "ON",
            "n",
            "N",
            "no",
            "No",
            "NO",
            "off",
            "Off",
            "OFF"
          ];
          function compileStyleMap(schema, map) {
            var result, keys, index, length, tag, style, type;
            if (map === null) return {};
            result = {};
            keys = Object.keys(map);
            for (index = 0, length = keys.length; index < length; index += 1) {
              tag = keys[index];
              style = String(map[tag]);
              if (tag.slice(0, 2) === "!!") {
                tag = "tag:yaml.org,2002:" + tag.slice(2);
              }
              type = schema.compiledTypeMap["fallback"][tag];
              if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                style = type.styleAliases[style];
              }
              result[tag] = style;
            }
            return result;
          }
          function encodeHex(character) {
            var string, handle, length;
            string = character.toString(16).toUpperCase();
            if (character <= 0xff) {
              handle = "x";
              length = 2;
            } else if (character <= 0xffff) {
              handle = "u";
              length = 4;
            } else if (character <= 0xffffffff) {
              handle = "U";
              length = 8;
            } else {
              throw new YAMLException(
                "code point within a string may not be greater than 0xFFFFFFFF"
              );
            }
            return (
              "\\" + handle + common.repeat("0", length - string.length) + string
            );
          }
          function State(options) {
            this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
            this.indent = Math.max(1, options["indent"] || 2);
            this.noArrayIndent = options["noArrayIndent"] || false;
            this.skipInvalid = options["skipInvalid"] || false;
            this.flowLevel = common.isNothing(options["flowLevel"])
              ? -1
              : options["flowLevel"];
            this.styleMap = compileStyleMap(
              this.schema,
              options["styles"] || null
            );
            this.sortKeys = options["sortKeys"] || false;
            this.lineWidth = options["lineWidth"] || 80;
            this.noRefs = options["noRefs"] || false;
            this.noCompatMode = options["noCompatMode"] || false;
            this.condenseFlow = options["condenseFlow"] || false;
            this.implicitTypes = this.schema.compiledImplicit;
            this.explicitTypes = this.schema.compiledExplicit;
            this.tag = null;
            this.result = "";
            this.duplicates = [];
            this.usedDuplicates = null;
          } // Indents every line in a string. Empty lines (\n only) are not indented.
          function indentString(string, spaces) {
            var ind = common.repeat(" ", spaces),
              position = 0,
              next = -1,
              result = "",
              line,
              length = string.length;
            while (position < length) {
              next = string.indexOf("\n", position);
              if (next === -1) {
                line = string.slice(position);
                position = length;
              } else {
                line = string.slice(position, next + 1);
                position = next + 1;
              }
              if (line.length && line !== "\n") result += ind;
              result += line;
            }
            return result;
          }
          function generateNextLine(state, level) {
            return "\n" + common.repeat(" ", state.indent * level);
          }
          function testImplicitResolving(state, str) {
            var index, length, type;
            for (
              index = 0, length = state.implicitTypes.length;
              index < length;
              index += 1
            ) {
              type = state.implicitTypes[index];
              if (type.resolve(str)) {
                return true;
              }
            }
            return false;
          } // [33] s-white ::= s-space | s-tab
          function isWhitespace(c) {
            return c === CHAR_SPACE || c === CHAR_TAB;
          } // Returns true if the character can be printed without escaping.
          // From YAML 1.2: "any allowed characters known to be non-printable
          // should also be escaped. [However,] This isn’t mandatory"
          // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
          function isPrintable(c) {
            return (
              (0x00020 <= c && c <= 0x00007e) ||
              (0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
              (0x0e000 <= c && c <= 0x00fffd && c !== 0xfeff) /* BOM */ ||
              (0x10000 <= c && c <= 0x10ffff)
            );
          } // [34] ns-char ::= nb-char - s-white
          // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
          // [26] b-char  ::= b-line-feed | b-carriage-return
          // [24] b-line-feed       ::=     #xA    /* LF */
          // [25] b-carriage-return ::=     #xD    /* CR */
          // [3]  c-byte-order-mark ::=     #xFEFF
          function isNsChar(c) {
            return (
              isPrintable(c) &&
              !isWhitespace(c) && // byte-order-mark
              c !== 0xfeff && // b-char
              c !== CHAR_CARRIAGE_RETURN &&
              c !== CHAR_LINE_FEED
            );
          } // Simplified test for values allowed after the first character in plain style.
          function isPlainSafe(c, prev) {
            // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
            // where nb-char ::= c-printable - b-char - c-byte-order-mark.
            return (
              isPrintable(c) &&
              c !== 0xfeff && // - c-flow-indicator
              c !== CHAR_COMMA &&
              c !== CHAR_LEFT_SQUARE_BRACKET &&
              c !== CHAR_RIGHT_SQUARE_BRACKET &&
              c !== CHAR_LEFT_CURLY_BRACKET &&
              c !== CHAR_RIGHT_CURLY_BRACKET && // - ":" - "#"
              // /* An ns-char preceding */ "#"
              c !== CHAR_COLON &&
              (c !== CHAR_SHARP || (prev && isNsChar(prev)))
            );
          } // Simplified test for values allowed as the first character in plain style.
          function isPlainSafeFirst(c) {
            // Uses a subset of ns-char - c-indicator
            // where ns-char = nb-char - s-white.
            return (
              isPrintable(c) &&
              c !== 0xfeff &&
              !isWhitespace(c) && // - s-white
              // - (c-indicator ::=
              // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
              c !== CHAR_MINUS &&
              c !== CHAR_QUESTION &&
              c !== CHAR_COLON &&
              c !== CHAR_COMMA &&
              c !== CHAR_LEFT_SQUARE_BRACKET &&
              c !== CHAR_RIGHT_SQUARE_BRACKET &&
              c !== CHAR_LEFT_CURLY_BRACKET &&
              c !== CHAR_RIGHT_CURLY_BRACKET && // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
              c !== CHAR_SHARP &&
              c !== CHAR_AMPERSAND &&
              c !== CHAR_ASTERISK &&
              c !== CHAR_EXCLAMATION &&
              c !== CHAR_VERTICAL_LINE &&
              c !== CHAR_EQUALS &&
              c !== CHAR_GREATER_THAN &&
              c !== CHAR_SINGLE_QUOTE &&
              c !== CHAR_DOUBLE_QUOTE && // | “%” | “@” | “`”)
              c !== CHAR_PERCENT &&
              c !== CHAR_COMMERCIAL_AT &&
              c !== CHAR_GRAVE_ACCENT
            );
          } // Determines whether block indentation indicator is required.
          function needIndentIndicator(string) {
            var leadingSpaceRe = /^\n* /;
            return leadingSpaceRe.test(string);
          }
          var STYLE_PLAIN = 1,
            STYLE_SINGLE = 2,
            STYLE_LITERAL = 3,
            STYLE_FOLDED = 4,
            STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
          // lineWidth = -1 => no limit.
          // Pre-conditions: str.length > 0.
          // Post-conditions:
          //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
          //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
          //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
          function chooseScalarStyle(
            string,
            singleLineOnly,
            indentPerLevel,
            lineWidth,
            testAmbiguousType
          ) {
            var i;
            var _char3, prev_char;
            var hasLineBreak = false;
            var hasFoldableLine = false; // only checked if shouldTrackWidth
            var shouldTrackWidth = lineWidth !== -1;
            var previousLineBreak = -1; // count the first line correctly
            var plain =
              isPlainSafeFirst(string.charCodeAt(0)) &&
              !isWhitespace(string.charCodeAt(string.length - 1));
            if (singleLineOnly) {
              // Case: no block styles.
              // Check for disallowed characters to rule out plain and single.
              for (i = 0; i < string.length; i++) {
                _char3 = string.charCodeAt(i);
                if (!isPrintable(_char3)) {
                  return STYLE_DOUBLE;
                }
                prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
                plain = plain && isPlainSafe(_char3, prev_char);
              }
            } else {
              // Case: block styles permitted.
              for (i = 0; i < string.length; i++) {
                _char3 = string.charCodeAt(i);
                if (_char3 === CHAR_LINE_FEED) {
                  hasLineBreak = true; // Check if any line can be folded.
                  if (shouldTrackWidth) {
                    hasFoldableLine =
                      hasFoldableLine || // Foldable line = too long, and not more-indented.
                      (i - previousLineBreak - 1 > lineWidth &&
                        string[previousLineBreak + 1] !== " ");
                    previousLineBreak = i;
                  }
                } else if (!isPrintable(_char3)) {
                  return STYLE_DOUBLE;
                }
                prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
                plain = plain && isPlainSafe(_char3, prev_char);
              } // in case the end is missing a \n
              hasFoldableLine =
                hasFoldableLine ||
                (shouldTrackWidth &&
                  i - previousLineBreak - 1 > lineWidth &&
                  string[previousLineBreak + 1] !== " ");
            } // Although every style can represent \n without escaping, prefer block styles
            // for multiline, since they're more readable and they don't add empty lines.
            // Also prefer folding a super-long line.
            if (!hasLineBreak && !hasFoldableLine) {
              // Strings interpretable as another type have to be quoted;
              // e.g. the string 'true' vs. the boolean true.
              return plain && !testAmbiguousType(string)
                ? STYLE_PLAIN
                : STYLE_SINGLE;
            } // Edge case: block indentation indicator can only have one digit.
            if (indentPerLevel > 9 && needIndentIndicator(string)) {
              return STYLE_DOUBLE;
            } // At this point we know block styles are valid.
            // Prefer literal style unless we want to fold.
            return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
          } // Note: line breaking/folding is implemented for only the folded style.
          // NB. We drop the last trailing newline (if any) of a returned block scalar
          //  since the dumper adds its own newline. This always works:
          //    • No ending newline => unaffected; already using strip "-" chomping.
          //    • Ending newline    => removed then restored.
          //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
          function writeScalar(state, string, level, iskey) {
            state.dump = (function () {
              if (string.length === 0) {
                return "''";
              }
              if (
                !state.noCompatMode &&
                DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1
              ) {
                return "'" + string + "'";
              }
              var indent = state.indent * Math.max(1, level); // no 0-indent scalars
              // As indentation gets deeper, let the width decrease monotonically
              // to the lower bound min(state.lineWidth, 40).
              // Note that this implies
              //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
              //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
              // This behaves better than a constant minimum width which disallows narrower options,
              // or an indent threshold which causes the width to suddenly increase.
              var lineWidth =
                state.lineWidth === -1
                  ? -1
                  : Math.max(
                      Math.min(state.lineWidth, 40),
                      state.lineWidth - indent
                    ); // Without knowing if keys are implicit/explicit, assume implicit for safety.
              var singleLineOnly =
                iskey || // No block styles in flow mode.
                (state.flowLevel > -1 && level >= state.flowLevel);
              function testAmbiguity(string) {
                return testImplicitResolving(state, string);
              }
              switch (
                chooseScalarStyle(
                  string,
                  singleLineOnly,
                  state.indent,
                  lineWidth,
                  testAmbiguity
                )
              ) {
                case STYLE_PLAIN:
                  return string;
                case STYLE_SINGLE:
                  return "'" + string.replace(/'/g, "''") + "'";
                case STYLE_LITERAL:
                  return (
                    "|" +
                    blockHeader(string, state.indent) +
                    dropEndingNewline(indentString(string, indent))
                  );
                case STYLE_FOLDED:
                  return (
                    ">" +
                    blockHeader(string, state.indent) +
                    dropEndingNewline(
                      indentString(foldString(string, lineWidth), indent)
                    )
                  );
                case STYLE_DOUBLE:
                  return '"' + escapeString(string, lineWidth) + '"';
                default:
                  throw new YAMLException(
                    "impossible error: invalid scalar style"
                  );
              }
            })();
          } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
          function blockHeader(string, indentPerLevel) {
            var indentIndicator = needIndentIndicator(string)
              ? String(indentPerLevel)
              : ""; // note the special case: the string '\n' counts as a "trailing" empty line.
            var clip = string[string.length - 1] === "\n";
            var keep =
              clip && (string[string.length - 2] === "\n" || string === "\n");
            var chomp = keep ? "+" : clip ? "" : "-";
            return indentIndicator + chomp + "\n";
          } // (See the note for writeScalar.)
          function dropEndingNewline(string) {
            return string[string.length - 1] === "\n"
              ? string.slice(0, -1)
              : string;
          } // Note: a long line without a suitable break point will exceed the width limit.
          // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
          function foldString(string, width) {
            // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
            // unless they're before or after a more-indented line, or at the very
            // beginning or end, in which case $k$ maps to $k$.
            // Therefore, parse each chunk as newline(s) followed by a content line.
            var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)
            var result = (function () {
              var nextLF = string.indexOf("\n");
              nextLF = nextLF !== -1 ? nextLF : string.length;
              lineRe.lastIndex = nextLF;
              return foldLine(string.slice(0, nextLF), width);
            })(); // If we haven't reached the first content line yet, don't add an extra \n.
            var prevMoreIndented = string[0] === "\n" || string[0] === " ";
            var moreIndented; // rest of the lines
            var match;
            while ((match = lineRe.exec(string))) {
              var prefix = match[1],
                line = match[2];
              moreIndented = line[0] === " ";
              result +=
                prefix +
                (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") +
                foldLine(line, width);
              prevMoreIndented = moreIndented;
            }
            return result;
          } // Greedy line breaking.
          // Picks the longest line under the limit each time,
          // otherwise settles for the shortest line over the limit.
          // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
          function foldLine(line, width) {
            if (line === "" || line[0] === " ") return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.
            var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
            var match; // start is an inclusive index. end, curr, and next are exclusive.
            var start = 0,
              end,
              curr = 0,
              next = 0;
            var result = ""; // Invariants: 0 <= start <= length-1.
            //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
            // Inside the loop:
            //   A match implies length >= 2, so curr and next are <= length-2.
            while ((match = breakRe.exec(line))) {
              next = match.index; // maintain invariant: curr - start <= width
              if (next - start > width) {
                end = curr > start ? curr : next; // derive end <= length-2
                result += "\n" + line.slice(start, end); // skip the space that was output as \n
                start = end + 1; // derive start <= length-1
              }
              curr = next;
            } // By the invariants, start <= length-1, so there is something left over.
            // It is either the whole string or a part starting from non-whitespace.
            result += "\n"; // Insert a break if the remainder is too long and there is a break available.
            if (line.length - start > width && curr > start) {
              result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
            } else {
              result += line.slice(start);
            }
            return result.slice(1); // drop extra \n joiner
          } // Escapes a double-quoted string.
          function escapeString(string) {
            var result = "";
            var _char4, nextChar;
            var escapeSeq;
            for (var i = 0; i < string.length; i++) {
              _char4 = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
              if (_char4 >= 0xd800 && _char4 <= 0xdbff /* high surrogate */) {
                nextChar = string.charCodeAt(i + 1);
                if (
                  nextChar >= 0xdc00 &&
                  nextChar <= 0xdfff /* low surrogate */
                ) {
                  // Combine the surrogate pair and store it escaped.
                  result += encodeHex(
                    (_char4 - 0xd800) * 0x400 + nextChar - 0xdc00 + 0x10000
                  ); // Advance index one extra since we already used that char here.
                  i++;
                  continue;
                }
              }
              escapeSeq = ESCAPE_SEQUENCES[_char4];
              result +=
                !escapeSeq && isPrintable(_char4)
                  ? string[i]
                  : escapeSeq || encodeHex(_char4);
            }
            return result;
          }
          function writeFlowSequence(state, level, object) {
            var _result = "",
              _tag = state.tag,
              index,
              length;
            for (index = 0, length = object.length; index < length; index += 1) {
              // Write only valid elements.
              if (writeNode(state, level, object[index], false, false)) {
                if (index !== 0)
                  _result += "," + (!state.condenseFlow ? " " : "");
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = "[" + _result + "]";
          }
          function writeBlockSequence(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              index,
              length;
            for (index = 0, length = object.length; index < length; index += 1) {
              // Write only valid elements.
              if (writeNode(state, level + 1, object[index], true, true)) {
                if (!compact || index !== 0) {
                  _result += generateNextLine(state, level);
                }
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  _result += "-";
                } else {
                  _result += "- ";
                }
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = _result || "[]"; // Empty sequence if no valid values.
          }
          function writeFlowMapping(state, level, object) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              pairBuffer;
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (index !== 0) pairBuffer += ", ";
              if (state.condenseFlow) pairBuffer += '"';
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (!writeNode(state, level, objectKey, false, false)) {
                continue; // Skip this pair because of invalid key;
              }
              if (state.dump.length > 1024) pairBuffer += "? ";
              pairBuffer +=
                state.dump +
                (state.condenseFlow ? '"' : "") +
                ":" +
                (state.condenseFlow ? "" : " ");
              if (!writeNode(state, level, objectValue, false, false)) {
                continue; // Skip this pair because of invalid value.
              }
              pairBuffer += state.dump; // Both key and value are valid.
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = "{" + _result + "}";
          }
          function writeBlockMapping(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              explicitPair,
              pairBuffer; // Allow sorting keys so that the output file is deterministic
            if (state.sortKeys === true) {
              // Default sorting
              objectKeyList.sort();
            } else if (typeof state.sortKeys === "function") {
              // Custom sort function
              objectKeyList.sort(state.sortKeys);
            } else if (state.sortKeys) {
              // Something is wrong
              throw new YAMLException("sortKeys must be a boolean or a function");
            }
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (!compact || index !== 0) {
                pairBuffer += generateNextLine(state, level);
              }
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (!writeNode(state, level + 1, objectKey, true, true, true)) {
                continue; // Skip this pair because of invalid key.
              }
              explicitPair =
                (state.tag !== null && state.tag !== "?") ||
                (state.dump && state.dump.length > 1024);
              if (explicitPair) {
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += "?";
                } else {
                  pairBuffer += "? ";
                }
              }
              pairBuffer += state.dump;
              if (explicitPair) {
                pairBuffer += generateNextLine(state, level);
              }
              if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                continue; // Skip this pair because of invalid value.
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += ":";
              } else {
                pairBuffer += ": ";
              }
              pairBuffer += state.dump; // Both key and value are valid.
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = _result || "{}"; // Empty mapping if no valid pairs.
          }
          function detectType(state, object, explicit) {
            var _result, typeList, index, length, type, style;
            typeList = explicit ? state.explicitTypes : state.implicitTypes;
            for (
              index = 0, length = typeList.length;
              index < length;
              index += 1
            ) {
              type = typeList[index];
              if (
                (type.instanceOf || type.predicate) &&
                (!type.instanceOf ||
                  (_typeof2(object) === "object" &&
                    object instanceof type.instanceOf)) &&
                (!type.predicate || type.predicate(object))
              ) {
                state.tag = explicit ? type.tag : "?";
                if (type.represent) {
                  style = state.styleMap[type.tag] || type.defaultStyle;
                  if (_toString.call(type.represent) === "[object Function]") {
                    _result = type.represent(object, style);
                  } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                  } else {
                    throw new YAMLException(
                      "!<" +
                        type.tag +
                        '> tag resolver accepts not "' +
                        style +
                        '" style'
                    );
                  }
                  state.dump = _result;
                }
                return true;
              }
            }
            return false;
          } // Serializes `object` and writes it to global `result`.
          // Returns true on success, or false on invalid object.
          //
          function writeNode(state, level, object, block, compact, iskey) {
            state.tag = null;
            state.dump = object;
            if (!detectType(state, object, false)) {
              detectType(state, object, true);
            }
            var type = _toString.call(state.dump);
            if (block) {
              block = state.flowLevel < 0 || state.flowLevel > level;
            }
            var objectOrArray =
                type === "[object Object]" || type === "[object Array]",
              duplicateIndex,
              duplicate;
            if (objectOrArray) {
              duplicateIndex = state.duplicates.indexOf(object);
              duplicate = duplicateIndex !== -1;
            }
            if (
              (state.tag !== null && state.tag !== "?") ||
              duplicate ||
              (state.indent !== 2 && level > 0)
            ) {
              compact = false;
            }
            if (duplicate && state.usedDuplicates[duplicateIndex]) {
              state.dump = "*ref_" + duplicateIndex;
            } else {
              if (
                objectOrArray &&
                duplicate &&
                !state.usedDuplicates[duplicateIndex]
              ) {
                state.usedDuplicates[duplicateIndex] = true;
              }
              if (type === "[object Object]") {
                if (block && Object.keys(state.dump).length !== 0) {
                  writeBlockMapping(state, level, state.dump, compact);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowMapping(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object Array]") {
                var arrayLevel =
                  state.noArrayIndent && level > 0 ? level - 1 : level;
                if (block && state.dump.length !== 0) {
                  writeBlockSequence(state, arrayLevel, state.dump, compact);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowSequence(state, arrayLevel, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object String]") {
                if (state.tag !== "?") {
                  writeScalar(state, state.dump, level, iskey);
                }
              } else {
                if (state.skipInvalid) return false;
                throw new YAMLException(
                  "unacceptable kind of an object to dump " + type
                );
              }
              if (state.tag !== null && state.tag !== "?") {
                state.dump = "!<" + state.tag + "> " + state.dump;
              }
            }
            return true;
          }
          function getDuplicateReferences(object, state) {
            var objects = [],
              duplicatesIndexes = [],
              index,
              length;
            inspectNode(object, objects, duplicatesIndexes);
            for (
              index = 0, length = duplicatesIndexes.length;
              index < length;
              index += 1
            ) {
              state.duplicates.push(objects[duplicatesIndexes[index]]);
            }
            state.usedDuplicates = new Array(length);
          }
          function inspectNode(object, objects, duplicatesIndexes) {
            var objectKeyList, index, length;
            if (object !== null && _typeof2(object) === "object") {
              index = objects.indexOf(object);
              if (index !== -1) {
                if (duplicatesIndexes.indexOf(index) === -1) {
                  duplicatesIndexes.push(index);
                }
              } else {
                objects.push(object);
                if (Array.isArray(object)) {
                  for (
                    index = 0, length = object.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(object[index], objects, duplicatesIndexes);
                  }
                } else {
                  objectKeyList = Object.keys(object);
                  for (
                    index = 0, length = objectKeyList.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(
                      object[objectKeyList[index]],
                      objects,
                      duplicatesIndexes
                    );
                  }
                }
              }
            }
          }
          function dump(input, options) {
            options = options || {};
            var state = new State(options);
            if (!state.noRefs) getDuplicateReferences(input, state);
            if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
            return "";
          }
          function safeDump(input, options) {
            return dump(
              input,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          module.exports.dump = dump;
          module.exports.safeDump = safeDump;
        },
        {
          "./common": 157,
          "./exception": 159,
          "./schema/default_full": 164,
          "./schema/default_safe": 165
        }
      ],
      159: [
        function (require, module, exports) {
          // YAML error class. http://stackoverflow.com/questions/8458984
          //
          "use strict";
          function YAMLException(reason, mark) {
            // Super constructor
            Error.call(this);
            this.name = "YAMLException";
            this.reason = reason;
            this.mark = mark;
            this.message =
              (this.reason || "(unknown reason)") +
              (this.mark ? " " + this.mark.toString() : ""); // Include stack trace in error object
            if (Error.captureStackTrace) {
              // Chrome and NodeJS
              Error.captureStackTrace(this, this.constructor);
            } else {
              // FF, IE 10+ and Safari 6+. Fallback for others
              this.stack = new Error().stack || "";
            }
          } // Inherit from Error
          YAMLException.prototype = Object.create(Error.prototype);
          YAMLException.prototype.constructor = YAMLException;
          YAMLException.prototype.toString = function toString(compact) {
            var result = this.name + ": ";
            result += this.reason || "(unknown reason)";
            if (!compact && this.mark) {
              result += " " + this.mark.toString();
            }
            return result;
          };
          module.exports = YAMLException;
        },
        {}
      ],
      160: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable max-len,no-use-before-define*/ var common = require("./common");
          var YAMLException = require("./exception");
          var Mark = require("./mark");
          var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");
          var DEFAULT_FULL_SCHEMA = require("./schema/default_full");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CONTEXT_FLOW_IN = 1;
          var CONTEXT_FLOW_OUT = 2;
          var CONTEXT_BLOCK_IN = 3;
          var CONTEXT_BLOCK_OUT = 4;
          var CHOMPING_CLIP = 1;
          var CHOMPING_STRIP = 2;
          var CHOMPING_KEEP = 3;
          var PATTERN_NON_PRINTABLE =
            /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
          var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
          var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
          var PATTERN_TAG_URI =
            /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
          function _class(obj) {
            return Object.prototype.toString.call(obj);
          }
          function is_EOL(c) {
            return c === 0x0a /* LF */ || c === 0x0d /* CR */;
          }
          function is_WHITE_SPACE(c) {
            return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
          }
          function is_WS_OR_EOL(c) {
            return (
              c === 0x09 /* Tab */ ||
              c === 0x20 /* Space */ ||
              c === 0x0a /* LF */ ||
              c === 0x0d /* CR */
            );
          }
          function is_FLOW_INDICATOR(c) {
            return (
              c === 0x2c /* , */ ||
              c === 0x5b /* [ */ ||
              c === 0x5d /* ] */ ||
              c === 0x7b /* { */ ||
              c === 0x7d /* } */
            );
          }
          function fromHexCode(c) {
            var lc;
            if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
              return c - 0x30;
            }
            /*eslint-disable no-bitwise*/ lc = c | 0x20;
            if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
              return lc - 0x61 + 10;
            }
            return -1;
          }
          function escapedHexLen(c) {
            if (c === 0x78 /* x */) {
              return 2;
            }
            if (c === 0x75 /* u */) {
              return 4;
            }
            if (c === 0x55 /* U */) {
              return 8;
            }
            return 0;
          }
          function fromDecimalCode(c) {
            if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
              return c - 0x30;
            }
            return -1;
          }
          function simpleEscapeSequence(c) {
            /* eslint-disable indent */ return c === 0x30 /* 0 */
              ? "\x00"
              : c === 0x61 /* a */
              ? "\x07"
              : c === 0x62 /* b */
              ? "\x08"
              : c === 0x74 /* t */
              ? "\x09"
              : c === 0x09 /* Tab */
              ? "\x09"
              : c === 0x6e /* n */
              ? "\x0A"
              : c === 0x76 /* v */
              ? "\x0B"
              : c === 0x66 /* f */
              ? "\x0C"
              : c === 0x72 /* r */
              ? "\x0D"
              : c === 0x65 /* e */
              ? "\x1B"
              : c === 0x20 /* Space */
              ? " "
              : c === 0x22 /* " */
              ? "\x22"
              : c === 0x2f /* / */
              ? "/"
              : c === 0x5c /* \ */
              ? "\x5C"
              : c === 0x4e /* N */
              ? "\x85"
              : c === 0x5f /* _ */
              ? "\xA0"
              : c === 0x4c /* L */
              ? "\u2028"
              : c === 0x50 /* P */
              ? "\u2029"
              : "";
          }
          function charFromCodepoint(c) {
            if (c <= 0xffff) {
              return String.fromCharCode(c);
            } // Encode UTF-16 surrogate pair
            // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
            return String.fromCharCode(
              ((c - 0x010000) >> 10) + 0xd800,
              ((c - 0x010000) & 0x03ff) + 0xdc00
            );
          }
          var simpleEscapeCheck = new Array(256); // integer, for fast access
          var simpleEscapeMap = new Array(256);
          for (var i = 0; i < 256; i++) {
            simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
            simpleEscapeMap[i] = simpleEscapeSequence(i);
          }
          function State(input, options) {
            this.input = input;
            this.filename = options["filename"] || null;
            this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
            this.onWarning = options["onWarning"] || null;
            this.legacy = options["legacy"] || false;
            this.json = options["json"] || false;
            this.listener = options["listener"] || null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.typeMap = this.schema.compiledTypeMap;
            this.length = input.length;
            this.position = 0;
            this.line = 0;
            this.lineStart = 0;
            this.lineIndent = 0;
            this.documents = []; /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/
          }
          function generateError(state, message) {
            return new YAMLException(
              message,
              new Mark(
                state.filename,
                state.input,
                state.position,
                state.line,
                state.position - state.lineStart
              )
            );
          }
          function throwError(state, message) {
            throw generateError(state, message);
          }
          function throwWarning(state, message) {
            if (state.onWarning) {
              state.onWarning.call(null, generateError(state, message));
            }
          }
          var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (state.version !== null) {
                throwError(state, "duplication of %YAML directive");
              }
              if (args.length !== 1) {
                throwError(state, "YAML directive accepts exactly one argument");
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (match === null) {
                throwError(state, "ill-formed argument of the YAML directive");
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (major !== 1) {
                throwError(state, "unacceptable YAML version of the document");
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (minor !== 1 && minor !== 2) {
                throwWarning(state, "unsupported YAML version of the document");
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (args.length !== 2) {
                throwError(state, "TAG directive accepts exactly two arguments");
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(
                  state,
                  "ill-formed tag handle (first argument) of the TAG directive"
                );
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(
                  state,
                  'there is a previously declared suffix for "' +
                    handle +
                    '" tag handle'
                );
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(
                  state,
                  "ill-formed tag prefix (second argument) of the TAG directive"
                );
              }
              state.tagMap[handle] = prefix;
            }
          };
          function captureSegment(state, start, end, checkJson) {
            var _position, _length, _character, _result;
            if (start < end) {
              _result = state.input.slice(start, end);
              if (checkJson) {
                for (
                  _position = 0, _length = _result.length;
                  _position < _length;
                  _position += 1
                ) {
                  _character = _result.charCodeAt(_position);
                  if (
                    !(
                      _character === 0x09 ||
                      (0x20 <= _character && _character <= 0x10ffff)
                    )
                  ) {
                    throwError(state, "expected valid JSON character");
                  }
                }
              } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                throwError(state, "the stream contains non-printable characters");
              }
              state.result += _result;
            }
          }
          function mergeMappings(state, destination, source, overridableKeys) {
            var sourceKeys, key, index, quantity;
            if (!common.isObject(source)) {
              throwError(
                state,
                "cannot merge mappings; the provided source object is unacceptable"
              );
            }
            sourceKeys = Object.keys(source);
            for (
              index = 0, quantity = sourceKeys.length;
              index < quantity;
              index += 1
            ) {
              key = sourceKeys[index];
              if (!_hasOwnProperty.call(destination, key)) {
                destination[key] = source[key];
                overridableKeys[key] = true;
              }
            }
          }
          function storeMappingPair(
            state,
            _result,
            overridableKeys,
            keyTag,
            keyNode,
            valueNode,
            startLine,
            startPos
          ) {
            var index, quantity; // The output is a plain object here, so keys can only be strings.
            // We need to convert keyNode to a string, but doing so can hang the process
            // (deeply nested arrays that explode exponentially using aliases).
            if (Array.isArray(keyNode)) {
              keyNode = Array.prototype.slice.call(keyNode);
              for (
                index = 0, quantity = keyNode.length;
                index < quantity;
                index += 1
              ) {
                if (Array.isArray(keyNode[index])) {
                  throwError(
                    state,
                    "nested arrays are not supported inside keys"
                  );
                }
                if (
                  _typeof2(keyNode) === "object" &&
                  _class(keyNode[index]) === "[object Object]"
                ) {
                  keyNode[index] = "[object Object]";
                }
              }
            } // Avoid code execution in load() via toString property
            // (still use its own toString for arrays, timestamps,
            // and whatever user schema extensions happen to have @@toStringTag)
            if (
              _typeof2(keyNode) === "object" &&
              _class(keyNode) === "[object Object]"
            ) {
              keyNode = "[object Object]";
            }
            keyNode = String(keyNode);
            if (_result === null) {
              _result = {};
            }
            if (keyTag === "tag:yaml.org,2002:merge") {
              if (Array.isArray(valueNode)) {
                for (
                  index = 0, quantity = valueNode.length;
                  index < quantity;
                  index += 1
                ) {
                  mergeMappings(
                    state,
                    _result,
                    valueNode[index],
                    overridableKeys
                  );
                }
              } else {
                mergeMappings(state, _result, valueNode, overridableKeys);
              }
            } else {
              if (
                !state.json &&
                !_hasOwnProperty.call(overridableKeys, keyNode) &&
                _hasOwnProperty.call(_result, keyNode)
              ) {
                state.line = startLine || state.line;
                state.position = startPos || state.position;
                throwError(state, "duplicated mapping key");
              }
              _result[keyNode] = valueNode;
              delete overridableKeys[keyNode];
            }
            return _result;
          }
          function readLineBreak(state) {
            var ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x0a /* LF */) {
              state.position++;
            } else if (ch === 0x0d /* CR */) {
              state.position++;
              if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
                state.position++;
              }
            } else {
              throwError(state, "a line break is expected");
            }
            state.line += 1;
            state.lineStart = state.position;
          }
          function skipSeparationSpace(state, allowComments, checkIndent) {
            var lineBreaks = 0,
              ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (allowComments && ch === 0x23 /* # */) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (
                  ch !== 0x0a /* LF */ &&
                  ch !== 0x0d /* CR */ &&
                  ch !== 0
                );
              }
              if (is_EOL(ch)) {
                readLineBreak(state);
                ch = state.input.charCodeAt(state.position);
                lineBreaks++;
                state.lineIndent = 0;
                while (ch === 0x20 /* Space */) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
              } else {
                break;
              }
            }
            if (
              checkIndent !== -1 &&
              lineBreaks !== 0 &&
              state.lineIndent < checkIndent
            ) {
              throwWarning(state, "deficient indentation");
            }
            return lineBreaks;
          }
          function testDocumentSeparator(state) {
            var _position = state.position,
              ch;
            ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
            // in parent on each call, for efficiency. No needs to test here again.
            if (
              (ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
              ch === state.input.charCodeAt(_position + 1) &&
              ch === state.input.charCodeAt(_position + 2)
            ) {
              _position += 3;
              ch = state.input.charCodeAt(_position);
              if (ch === 0 || is_WS_OR_EOL(ch)) {
                return true;
              }
            }
            return false;
          }
          function writeFoldedLines(state, count) {
            if (count === 1) {
              state.result += " ";
            } else if (count > 1) {
              state.result += common.repeat("\n", count - 1);
            }
          }
          function readPlainScalar(state, nodeIndent, withinFlowCollection) {
            var preceding,
              following,
              captureStart,
              captureEnd,
              hasPendingContent,
              _line,
              _lineStart,
              _lineIndent,
              _kind = state.kind,
              _result = state.result,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (
              is_WS_OR_EOL(ch) ||
              is_FLOW_INDICATOR(ch) ||
              ch === 0x23 /* # */ ||
              ch === 0x26 /* & */ ||
              ch === 0x2a /* * */ ||
              ch === 0x21 /* ! */ ||
              ch === 0x7c /* | */ ||
              ch === 0x3e /* > */ ||
              ch === 0x27 /* ' */ ||
              ch === 0x22 /* " */ ||
              ch === 0x25 /* % */ ||
              ch === 0x40 /* @ */ ||
              ch === 0x60 /* ` */
            ) {
              return false;
            }
            if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
              following = state.input.charCodeAt(state.position + 1);
              if (
                is_WS_OR_EOL(following) ||
                (withinFlowCollection && is_FLOW_INDICATOR(following))
              ) {
                return false;
              }
            }
            state.kind = "scalar";
            state.result = "";
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
            while (ch !== 0) {
              if (ch === 0x3a /* : */) {
                following = state.input.charCodeAt(state.position + 1);
                if (
                  is_WS_OR_EOL(following) ||
                  (withinFlowCollection && is_FLOW_INDICATOR(following))
                ) {
                  break;
                }
              } else if (ch === 0x23 /* # */) {
                preceding = state.input.charCodeAt(state.position - 1);
                if (is_WS_OR_EOL(preceding)) {
                  break;
                }
              } else if (
                (state.position === state.lineStart &&
                  testDocumentSeparator(state)) ||
                (withinFlowCollection && is_FLOW_INDICATOR(ch))
              ) {
                break;
              } else if (is_EOL(ch)) {
                _line = state.line;
                _lineStart = state.lineStart;
                _lineIndent = state.lineIndent;
                skipSeparationSpace(state, false, -1);
                if (state.lineIndent >= nodeIndent) {
                  hasPendingContent = true;
                  ch = state.input.charCodeAt(state.position);
                  continue;
                } else {
                  state.position = captureEnd;
                  state.line = _line;
                  state.lineStart = _lineStart;
                  state.lineIndent = _lineIndent;
                  break;
                }
              }
              if (hasPendingContent) {
                captureSegment(state, captureStart, captureEnd, false);
                writeFoldedLines(state, state.line - _line);
                captureStart = captureEnd = state.position;
                hasPendingContent = false;
              }
              if (!is_WHITE_SPACE(ch)) {
                captureEnd = state.position + 1;
              }
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, captureEnd, false);
            if (state.result) {
              return true;
            }
            state.kind = _kind;
            state.result = _result;
            return false;
          }
          function readSingleQuotedScalar(state, nodeIndent) {
            var ch, captureStart, captureEnd;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x27 /* ' */) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 0x27 /* ' */) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (ch === 0x27 /* ' */) {
                  captureStart = state.position;
                  state.position++;
                  captureEnd = state.position;
                } else {
                  return true;
                }
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a single quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a single quoted scalar"
            );
          }
          function readDoubleQuotedScalar(state, nodeIndent) {
            var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x22 /* " */) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 0x22 /* " */) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                return true;
              } else if (ch === 0x5c /* \ */) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) {
                  skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
                } else if (ch < 256 && simpleEscapeCheck[ch]) {
                  state.result += simpleEscapeMap[ch];
                  state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                  hexLength = tmp;
                  hexResult = 0;
                  for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                      hexResult = (hexResult << 4) + tmp;
                    } else {
                      throwError(state, "expected hexadecimal character");
                    }
                  }
                  state.result += charFromCodepoint(hexResult);
                  state.position++;
                } else {
                  throwError(state, "unknown escape sequence");
                }
                captureStart = captureEnd = state.position;
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a double quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a double quoted scalar"
            );
          }
          function readFlowCollection(state, nodeIndent) {
            var readNext = true,
              _line,
              _tag = state.tag,
              _result,
              _anchor = state.anchor,
              following,
              terminator,
              isPair,
              isExplicitPair,
              isMapping,
              overridableKeys = {},
              keyNode,
              keyTag,
              valueNode,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x5b /* [ */) {
              terminator = 0x5d;
              /* ] */ isMapping = false;
              _result = [];
            } else if (ch === 0x7b /* { */) {
              terminator = 0x7d;
              /* } */ isMapping = true;
              _result = {};
            } else {
              return false;
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(++state.position);
            while (ch !== 0) {
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === terminator) {
                state.position++;
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = isMapping ? "mapping" : "sequence";
                state.result = _result;
                return true;
              } else if (!readNext) {
                throwError(state, "missed comma between flow collection entries");
              }
              keyTag = keyNode = valueNode = null;
              isPair = isExplicitPair = false;
              if (ch === 0x3f /* ? */) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following)) {
                  isPair = isExplicitPair = true;
                  state.position++;
                  skipSeparationSpace(state, true, nodeIndent);
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              keyTag = state.tag;
              keyNode = state.result;
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (
                (isExplicitPair || state.line === _line) &&
                ch === 0x3a /* : */
              ) {
                isPair = true;
                ch = state.input.charCodeAt(++state.position);
                skipSeparationSpace(state, true, nodeIndent);
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                valueNode = state.result;
              }
              if (isMapping) {
                storeMappingPair(
                  state,
                  _result,
                  overridableKeys,
                  keyTag,
                  keyNode,
                  valueNode
                );
              } else if (isPair) {
                _result.push(
                  storeMappingPair(
                    state,
                    null,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    valueNode
                  )
                );
              } else {
                _result.push(keyNode);
              }
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === 0x2c /* , */) {
                readNext = true;
                ch = state.input.charCodeAt(++state.position);
              } else {
                readNext = false;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a flow collection"
            );
          }
          function readBlockScalar(state, nodeIndent) {
            var captureStart,
              folding,
              chomping = CHOMPING_CLIP,
              didReadContent = false,
              detectedIndent = false,
              textIndent = nodeIndent,
              emptyLines = 0,
              atMoreIndented = false,
              tmp,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x7c /* | */) {
              folding = false;
            } else if (ch === 0x3e /* > */) {
              folding = true;
            } else {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            while (ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
              if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
                if (CHOMPING_CLIP === chomping) {
                  chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
                } else {
                  throwError(state, "repeat of a chomping mode identifier");
                }
              } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                if (tmp === 0) {
                  throwError(
                    state,
                    "bad explicit indentation width of a block scalar; it cannot be less than one"
                  );
                } else if (!detectedIndent) {
                  textIndent = nodeIndent + tmp - 1;
                  detectedIndent = true;
                } else {
                  throwError(state, "repeat of an indentation width identifier");
                }
              } else {
                break;
              }
            }
            if (is_WHITE_SPACE(ch)) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (is_WHITE_SPACE(ch));
              if (ch === 0x23 /* # */) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (!is_EOL(ch) && ch !== 0);
              }
            }
            while (ch !== 0) {
              readLineBreak(state);
              state.lineIndent = 0;
              ch = state.input.charCodeAt(state.position);
              while (
                (!detectedIndent || state.lineIndent < textIndent) &&
                ch === 0x20 /* Space */
              ) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
              if (!detectedIndent && state.lineIndent > textIndent) {
                textIndent = state.lineIndent;
              }
              if (is_EOL(ch)) {
                emptyLines++;
                continue;
              } // End of the scalar.
              if (state.lineIndent < textIndent) {
                // Perform the chomping.
                if (chomping === CHOMPING_KEEP) {
                  state.result += common.repeat(
                    "\n",
                    didReadContent ? 1 + emptyLines : emptyLines
                  );
                } else if (chomping === CHOMPING_CLIP) {
                  if (didReadContent) {
                    // i.e. only if the scalar is not empty.
                    state.result += "\n";
                  }
                } // Break this `while` cycle and go to the funciton's epilogue.
                break;
              } // Folded style: use fancy rules to handle line breaks.
              if (folding) {
                // Lines starting with white space characters (more-indented lines) are not folded.
                if (is_WHITE_SPACE(ch)) {
                  atMoreIndented = true; // except for the first content line (cf. Example 8.1)
                  state.result += common.repeat(
                    "\n",
                    didReadContent ? 1 + emptyLines : emptyLines
                  ); // End of more-indented block.
                } else if (atMoreIndented) {
                  atMoreIndented = false;
                  state.result += common.repeat("\n", emptyLines + 1); // Just one line break - perceive as the same line.
                } else if (emptyLines === 0) {
                  if (didReadContent) {
                    // i.e. only if we have already read some scalar content.
                    state.result += " ";
                  } // Several line breaks - perceive as different lines.
                } else {
                  state.result += common.repeat("\n", emptyLines);
                } // Literal style: just add exact number of line breaks between content lines.
              } else {
                // Keep all line breaks except the header line break.
                state.result += common.repeat(
                  "\n",
                  didReadContent ? 1 + emptyLines : emptyLines
                );
              }
              didReadContent = true;
              detectedIndent = true;
              emptyLines = 0;
              captureStart = state.position;
              while (!is_EOL(ch) && ch !== 0) {
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, state.position, false);
            }
            return true;
          }
          function readBlockSequence(state, nodeIndent) {
            var _line,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = [],
              following,
              detected = false,
              ch;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              if (ch !== 0x2d /* - */) {
                break;
              }
              following = state.input.charCodeAt(state.position + 1);
              if (!is_WS_OR_EOL(following)) {
                break;
              }
              detected = true;
              state.position++;
              if (skipSeparationSpace(state, true, -1)) {
                if (state.lineIndent <= nodeIndent) {
                  _result.push(null);
                  ch = state.input.charCodeAt(state.position);
                  continue;
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
              _result.push(state.result);
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (
                (state.line === _line || state.lineIndent > nodeIndent) &&
                ch !== 0
              ) {
                throwError(state, "bad indentation of a sequence entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "sequence";
              state.result = _result;
              return true;
            }
            return false;
          }
          function readBlockMapping(state, nodeIndent, flowIndent) {
            var following,
              allowCompact,
              _line,
              _pos,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = {},
              overridableKeys = {},
              keyTag = null,
              keyNode = null,
              valueNode = null,
              atExplicitKey = false,
              detected = false,
              ch;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              following = state.input.charCodeAt(state.position + 1);
              _line = state.line; // Save the current line.
              _pos = state.position; //
              // Explicit notation case. There are two separate blocks:
              // first for the key (denoted by "?") and second for the value (denoted by ":")
              //
              if (
                (ch === 0x3f /* ? */ || ch === 0x3a /*: */) &&
                is_WS_OR_EOL(following)
              ) {
                if (ch === 0x3f /* ? */) {
                  if (atExplicitKey) {
                    storeMappingPair(
                      state,
                      _result,
                      overridableKeys,
                      keyTag,
                      keyNode,
                      null
                    );
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = true;
                  allowCompact = true;
                } else if (atExplicitKey) {
                  // i.e. 0x3A/* : */ === character after the explicit key.
                  atExplicitKey = false;
                  allowCompact = true;
                } else {
                  throwError(
                    state,
                    "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"
                  );
                }
                state.position += 1;
                ch = following; //
                // Implicit notation case. Flow-style node as the key first, then ":", and the value.
                //
              } else if (
                composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
              ) {
                if (state.line === _line) {
                  ch = state.input.charCodeAt(state.position);
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (ch === 0x3a /* : */) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                      throwError(
                        state,
                        "a whitespace character is expected after the key-value separator within a block mapping"
                      );
                    }
                    if (atExplicitKey) {
                      storeMappingPair(
                        state,
                        _result,
                        overridableKeys,
                        keyTag,
                        keyNode,
                        null
                      );
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                  } else if (detected) {
                    throwError(
                      state,
                      "can not read an implicit mapping pair; a colon is missed"
                    );
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                  }
                } else if (detected) {
                  throwError(
                    state,
                    "can not read a block mapping entry; a multiline key may not be an implicit key"
                  );
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true; // Keep the result of `composeNode`.
                }
              } else {
                break; // Reading is done. Go to the epilogue.
              } //
              // Common reading code for both explicit and implicit notations.
              //
              if (state.line === _line || state.lineIndent > nodeIndent) {
                if (
                  composeNode(
                    state,
                    nodeIndent,
                    CONTEXT_BLOCK_OUT,
                    true,
                    allowCompact
                  )
                ) {
                  if (atExplicitKey) {
                    keyNode = state.result;
                  } else {
                    valueNode = state.result;
                  }
                }
                if (!atExplicitKey) {
                  storeMappingPair(
                    state,
                    _result,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    valueNode,
                    _line,
                    _pos
                  );
                  keyTag = keyNode = valueNode = null;
                }
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
              }
              if (state.lineIndent > nodeIndent && ch !== 0) {
                throwError(state, "bad indentation of a mapping entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            } //
            // Epilogue.
            //
            // Special case: last mapping's node contains only the key in explicit notation.
            if (atExplicitKey) {
              storeMappingPair(
                state,
                _result,
                overridableKeys,
                keyTag,
                keyNode,
                null
              );
            } // Expose the resulting mapping.
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "mapping";
              state.result = _result;
            }
            return detected;
          }
          function readTagProperty(state) {
            var _position,
              isVerbatim = false,
              isNamed = false,
              tagHandle,
              tagName,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x21 /* ! */) return false;
            if (state.tag !== null) {
              throwError(state, "duplication of a tag property");
            }
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x3c /* < */) {
              isVerbatim = true;
              ch = state.input.charCodeAt(++state.position);
            } else if (ch === 0x21 /* ! */) {
              isNamed = true;
              tagHandle = "!!";
              ch = state.input.charCodeAt(++state.position);
            } else {
              tagHandle = "!";
            }
            _position = state.position;
            if (isVerbatim) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && ch !== 0x3e /* > */);
              if (state.position < state.length) {
                tagName = state.input.slice(_position, state.position);
                ch = state.input.charCodeAt(++state.position);
              } else {
                throwError(
                  state,
                  "unexpected end of the stream within a verbatim tag"
                );
              }
            } else {
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                if (ch === 0x21 /* ! */) {
                  if (!isNamed) {
                    tagHandle = state.input.slice(
                      _position - 1,
                      state.position + 1
                    );
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                      throwError(
                        state,
                        "named tag handle cannot contain such characters"
                      );
                    }
                    isNamed = true;
                    _position = state.position + 1;
                  } else {
                    throwError(
                      state,
                      "tag suffix cannot contain exclamation marks"
                    );
                  }
                }
                ch = state.input.charCodeAt(++state.position);
              }
              tagName = state.input.slice(_position, state.position);
              if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                throwError(
                  state,
                  "tag suffix cannot contain flow indicator characters"
                );
              }
            }
            if (tagName && !PATTERN_TAG_URI.test(tagName)) {
              throwError(
                state,
                "tag name cannot contain such characters: " + tagName
              );
            }
            if (isVerbatim) {
              state.tag = tagName;
            } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
              state.tag = state.tagMap[tagHandle] + tagName;
            } else if (tagHandle === "!") {
              state.tag = "!" + tagName;
            } else if (tagHandle === "!!") {
              state.tag = "tag:yaml.org,2002:" + tagName;
            } else {
              throwError(state, 'undeclared tag handle "' + tagHandle + '"');
            }
            return true;
          }
          function readAnchorProperty(state) {
            var _position, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x26 /* & */) return false;
            if (state.anchor !== null) {
              throwError(state, "duplication of an anchor property");
            }
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(
                state,
                "name of an anchor node must contain at least one character"
              );
            }
            state.anchor = state.input.slice(_position, state.position);
            return true;
          }
          function readAlias(state) {
            var _position, alias, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 0x2a /* * */) return false;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(
                state,
                "name of an alias node must contain at least one character"
              );
            }
            alias = state.input.slice(_position, state.position);
            if (!_hasOwnProperty.call(state.anchorMap, alias)) {
              throwError(state, 'unidentified alias "' + alias + '"');
            }
            state.result = state.anchorMap[alias];
            skipSeparationSpace(state, true, -1);
            return true;
          }
          function composeNode(
            state,
            parentIndent,
            nodeContext,
            allowToSeek,
            allowCompact
          ) {
            var allowBlockStyles,
              allowBlockScalars,
              allowBlockCollections,
              indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
              atNewLine = false,
              hasContent = false,
              typeIndex,
              typeQuantity,
              type,
              flowIndent,
              blockIndent;
            if (state.listener !== null) {
              state.listener("open", state);
            }
            state.tag = null;
            state.anchor = null;
            state.kind = null;
            state.result = null;
            allowBlockStyles =
              allowBlockScalars =
              allowBlockCollections =
                CONTEXT_BLOCK_OUT === nodeContext ||
                CONTEXT_BLOCK_IN === nodeContext;
            if (allowToSeek) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              }
            }
            if (indentStatus === 1) {
              while (readTagProperty(state) || readAnchorProperty(state)) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  allowBlockCollections = allowBlockStyles;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                } else {
                  allowBlockCollections = false;
                }
              }
            }
            if (allowBlockCollections) {
              allowBlockCollections = atNewLine || allowCompact;
            }
            if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
              if (
                CONTEXT_FLOW_IN === nodeContext ||
                CONTEXT_FLOW_OUT === nodeContext
              ) {
                flowIndent = parentIndent;
              } else {
                flowIndent = parentIndent + 1;
              }
              blockIndent = state.position - state.lineStart;
              if (indentStatus === 1) {
                if (
                  (allowBlockCollections &&
                    (readBlockSequence(state, blockIndent) ||
                      readBlockMapping(state, blockIndent, flowIndent))) ||
                  readFlowCollection(state, flowIndent)
                ) {
                  hasContent = true;
                } else {
                  if (
                    (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                    readSingleQuotedScalar(state, flowIndent) ||
                    readDoubleQuotedScalar(state, flowIndent)
                  ) {
                    hasContent = true;
                  } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                      throwError(
                        state,
                        "alias node should not have any properties"
                      );
                    }
                  } else if (
                    readPlainScalar(
                      state,
                      flowIndent,
                      CONTEXT_FLOW_IN === nodeContext
                    )
                  ) {
                    hasContent = true;
                    if (state.tag === null) {
                      state.tag = "?";
                    }
                  }
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              } else if (indentStatus === 0) {
                // Special case: block sequences are allowed to have same indentation level as the parent.
                // http://www.yaml.org/spec/1.2/spec.html#id2799784
                hasContent =
                  allowBlockCollections && readBlockSequence(state, blockIndent);
              }
            }
            if (state.tag !== null && state.tag !== "!") {
              if (state.tag === "?") {
                // Implicit resolving is not allowed for non-scalar types, and '?'
                // non-specific tag is only automatically assigned to plain scalars.
                //
                // We only need to check kind conformity in case user explicitly assigns '?'
                // tag, for example like this: "!<?> [0]"
                //
                if (state.result !== null && state.kind !== "scalar") {
                  throwError(
                    state,
                    'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
                      state.kind +
                      '"'
                  );
                }
                for (
                  typeIndex = 0, typeQuantity = state.implicitTypes.length;
                  typeIndex < typeQuantity;
                  typeIndex += 1
                ) {
                  type = state.implicitTypes[typeIndex];
                  if (type.resolve(state.result)) {
                    // `state.result` updated in resolver if matched
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) {
                      state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                  }
                }
              } else if (
                _hasOwnProperty.call(
                  state.typeMap[state.kind || "fallback"],
                  state.tag
                )
              ) {
                type = state.typeMap[state.kind || "fallback"][state.tag];
                if (state.result !== null && type.kind !== state.kind) {
                  throwError(
                    state,
                    "unacceptable node kind for !<" +
                      state.tag +
                      '> tag; it should be "' +
                      type.kind +
                      '", not "' +
                      state.kind +
                      '"'
                  );
                }
                if (!type.resolve(state.result)) {
                  // `state.result` updated in resolver if matched
                  throwError(
                    state,
                    "cannot resolve a node with !<" + state.tag + "> explicit tag"
                  );
                } else {
                  state.result = type.construct(state.result);
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              } else {
                throwError(state, "unknown tag !<" + state.tag + ">");
              }
            }
            if (state.listener !== null) {
              state.listener("close", state);
            }
            return state.tag !== null || state.anchor !== null || hasContent;
          }
          function readDocument(state) {
            var documentStart = state.position,
              _position,
              directiveName,
              directiveArgs,
              hasDirectives = false,
              ch;
            state.version = null;
            state.checkLineBreaks = state.legacy;
            state.tagMap = {};
            state.anchorMap = {};
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
                break;
              }
              hasDirectives = true;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveName = state.input.slice(_position, state.position);
              directiveArgs = [];
              if (directiveName.length < 1) {
                throwError(
                  state,
                  "directive name must not be less than one character in length"
                );
              }
              while (ch !== 0) {
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x23 /* # */) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 0 && !is_EOL(ch));
                  break;
                }
                if (is_EOL(ch)) break;
                _position = state.position;
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveArgs.push(state.input.slice(_position, state.position));
              }
              if (ch !== 0) readLineBreak(state);
              if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                directiveHandlers[directiveName](
                  state,
                  directiveName,
                  directiveArgs
                );
              } else {
                throwWarning(
                  state,
                  'unknown document directive "' + directiveName + '"'
                );
              }
            }
            skipSeparationSpace(state, true, -1);
            if (
              state.lineIndent === 0 &&
              state.input.charCodeAt(state.position) === 0x2d /* - */ &&
              state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
              state.input.charCodeAt(state.position + 2) === 0x2d /* - */
            ) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) {
              throwError(state, "directives end mark is expected");
            }
            composeNode(
              state,
              state.lineIndent - 1,
              CONTEXT_BLOCK_OUT,
              false,
              true
            );
            skipSeparationSpace(state, true, -1);
            if (
              state.checkLineBreaks &&
              PATTERN_NON_ASCII_LINE_BREAKS.test(
                state.input.slice(documentStart, state.position)
              )
            ) {
              throwWarning(
                state,
                "non-ASCII line breaks are interpreted as content"
              );
            }
            state.documents.push(state.result);
            if (
              state.position === state.lineStart &&
              testDocumentSeparator(state)
            ) {
              if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              }
              return;
            }
            if (state.position < state.length - 1) {
              throwError(
                state,
                "end of the stream or a document separator is expected"
              );
            } else {
              return;
            }
          }
          function loadDocuments(input, options) {
            input = String(input);
            options = options || {};
            if (input.length !== 0) {
              // Add tailing `\n` if not exists
              if (
                input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
                input.charCodeAt(input.length - 1) !== 0x0d /* CR */
              ) {
                input += "\n";
              } // Strip BOM
              if (input.charCodeAt(0) === 0xfeff) {
                input = input.slice(1);
              }
            }
            var state = new State(input, options);
            var nullpos = input.indexOf("\0");
            if (nullpos !== -1) {
              state.position = nullpos;
              throwError(state, "null byte is not allowed in input");
            } // Use 0 as string terminator. That significantly simplifies bounds check.
            state.input += "\0";
            while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
              state.lineIndent += 1;
              state.position += 1;
            }
            while (state.position < state.length - 1) {
              readDocument(state);
            }
            return state.documents;
          }
          function loadAll(input, iterator, options) {
            if (
              iterator !== null &&
              _typeof2(iterator) === "object" &&
              typeof options === "undefined"
            ) {
              options = iterator;
              iterator = null;
            }
            var documents = loadDocuments(input, options);
            if (typeof iterator !== "function") {
              return documents;
            }
            for (
              var index = 0, length = documents.length;
              index < length;
              index += 1
            ) {
              iterator(documents[index]);
            }
          }
          function load(input, options) {
            var documents = loadDocuments(input, options);
            if (documents.length === 0) {
              /*eslint-disable no-undefined*/ return undefined;
            } else if (documents.length === 1) {
              return documents[0];
            }
            throw new YAMLException(
              "expected a single document in the stream, but found more"
            );
          }
          function safeLoadAll(input, iterator, options) {
            if (
              _typeof2(iterator) === "object" &&
              iterator !== null &&
              typeof options === "undefined"
            ) {
              options = iterator;
              iterator = null;
            }
            return loadAll(
              input,
              iterator,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          function safeLoad(input, options) {
            return load(
              input,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          module.exports.loadAll = loadAll;
          module.exports.load = load;
          module.exports.safeLoadAll = safeLoadAll;
          module.exports.safeLoad = safeLoad;
        },
        {
          "./common": 157,
          "./exception": 159,
          "./mark": 161,
          "./schema/default_full": 164,
          "./schema/default_safe": 165
        }
      ],
      161: [
        function (require, module, exports) {
          "use strict";
          var common = require("./common");
          function Mark(name, buffer, position, line, column) {
            this.name = name;
            this.buffer = buffer;
            this.position = position;
            this.line = line;
            this.column = column;
          }
          Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
            var head, start, tail, end, snippet;
            if (!this.buffer) return null;
            indent = indent || 4;
            maxLength = maxLength || 75;
            head = "";
            start = this.position;
            while (
              start > 0 &&
              "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) ===
                -1
            ) {
              start -= 1;
              if (this.position - start > maxLength / 2 - 1) {
                head = " ... ";
                start += 5;
                break;
              }
            }
            tail = "";
            end = this.position;
            while (
              end < this.buffer.length &&
              "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1
            ) {
              end += 1;
              if (end - this.position > maxLength / 2 - 1) {
                tail = " ... ";
                end -= 5;
                break;
              }
            }
            snippet = this.buffer.slice(start, end);
            return (
              common.repeat(" ", indent) +
              head +
              snippet +
              tail +
              "\n" +
              common.repeat(" ", indent + this.position - start + head.length) +
              "^"
            );
          };
          Mark.prototype.toString = function toString(compact) {
            var snippet,
              where = "";
            if (this.name) {
              where += 'in "' + this.name + '" ';
            }
            where +=
              "at line " + (this.line + 1) + ", column " + (this.column + 1);
            if (!compact) {
              snippet = this.getSnippet();
              if (snippet) {
                where += ":\n" + snippet;
              }
            }
            return where;
          };
          module.exports = Mark;
        },
        { "./common": 157 }
      ],
      162: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable max-len*/ var common = require("./common");
          var YAMLException = require("./exception");
          var Type = require("./type");
          function compileList(schema, name, result) {
            var exclude = [];
            schema.include.forEach(function (includedSchema) {
              result = compileList(includedSchema, name, result);
            });
            schema[name].forEach(function (currentType) {
              result.forEach(function (previousType, previousIndex) {
                if (
                  previousType.tag === currentType.tag &&
                  previousType.kind === currentType.kind
                ) {
                  exclude.push(previousIndex);
                }
              });
              result.push(currentType);
            });
            return result.filter(function (type, index) {
              return exclude.indexOf(index) === -1;
            });
          }
          function /* lists... */ compileMap() {
            var result = { scalar: {}, sequence: {}, mapping: {}, fallback: {} },
              index,
              length;
            function collectType(type) {
              result[type.kind][type.tag] = result["fallback"][type.tag] = type;
            }
            for (
              index = 0, length = arguments.length;
              index < length;
              index += 1
            ) {
              arguments[index].forEach(collectType);
            }
            return result;
          }
          function Schema(definition) {
            this.include = definition.include || [];
            this.implicit = definition.implicit || [];
            this.explicit = definition.explicit || [];
            this.implicit.forEach(function (type) {
              if (type.loadKind && type.loadKind !== "scalar") {
                throw new YAMLException(
                  "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
                );
              }
            });
            this.compiledImplicit = compileList(this, "implicit", []);
            this.compiledExplicit = compileList(this, "explicit", []);
            this.compiledTypeMap = compileMap(
              this.compiledImplicit,
              this.compiledExplicit
            );
          }
          Schema.DEFAULT = null;
          Schema.create = function createSchema() {
            var schemas, types;
            switch (arguments.length) {
              case 1:
                schemas = Schema.DEFAULT;
                types = arguments[0];
                break;
              case 2:
                schemas = arguments[0];
                types = arguments[1];
                break;
              default:
                throw new YAMLException(
                  "Wrong number of arguments for Schema.create function"
                );
            }
            schemas = common.toArray(schemas);
            types = common.toArray(types);
            if (
              !schemas.every(function (schema) {
                return schema instanceof Schema;
              })
            ) {
              throw new YAMLException(
                "Specified list of super schemas (or a single Schema object) contains a non-Schema object."
              );
            }
            if (
              !types.every(function (type) {
                return type instanceof Type;
              })
            ) {
              throw new YAMLException(
                "Specified list of YAML types (or a single Type object) contains a non-Type object."
              );
            }
            return new Schema({ include: schemas, explicit: types });
          };
          module.exports = Schema;
        },
        { "./common": 157, "./exception": 159, "./type": 168 }
      ],
      163: [
        function (require, module, exports) {
          // Standard YAML's Core schema.
          // http://www.yaml.org/spec/1.2/spec.html#id2804923
          //
          // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
          // So, Core schema has no distinctions from JSON schema is JS-YAML.
          "use strict";
          var Schema = require("../schema");
          module.exports = new Schema({ include: [require("./json")] });
        },
        { "../schema": 162, "./json": 167 }
      ],
      164: [
        function (require, module, exports) {
          // JS-YAML's default schema for `load` function.
          // It is not described in the YAML specification.
          //
          // This schema is based on JS-YAML's default safe schema and includes
          // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
          //
          // Also this schema is used as default base schema at `Schema.create` function.
          "use strict";
          var Schema = require("../schema");
          module.exports = Schema.DEFAULT = new Schema({
            include: [require("./default_safe")],
            explicit: [
              require("../type/js/undefined"),
              require("../type/js/regexp"),
              require("../type/js/function")
            ]
          });
        },
        {
          "../schema": 162,
          "../type/js/function": 173,
          "../type/js/regexp": 174,
          "../type/js/undefined": 175,
          "./default_safe": 165
        }
      ],
      165: [
        function (require, module, exports) {
          // JS-YAML's default schema for `safeLoad` function.
          // It is not described in the YAML specification.
          //
          // This schema is based on standard YAML's Core schema and includes most of
          // extra types described at YAML tag repository. (http://yaml.org/type/)
          "use strict";
          var Schema = require("../schema");
          module.exports = new Schema({
            include: [require("./core")],
            implicit: [require("../type/timestamp"), require("../type/merge")],
            explicit: [
              require("../type/binary"),
              require("../type/omap"),
              require("../type/pairs"),
              require("../type/set")
            ]
          });
        },
        {
          "../schema": 162,
          "../type/binary": 169,
          "../type/merge": 177,
          "../type/omap": 179,
          "../type/pairs": 180,
          "../type/set": 182,
          "../type/timestamp": 184,
          "./core": 163
        }
      ],
      166: [
        function (require, module, exports) {
          arguments[4][28][0].apply(exports, arguments);
        },
        {
          "../schema": 162,
          "../type/map": 176,
          "../type/seq": 181,
          "../type/str": 183,
          dup: 28
        }
      ],
      167: [
        function (require, module, exports) {
          // Standard YAML's JSON schema.
          // http://www.yaml.org/spec/1.2/spec.html#id2803231
          //
          // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
          // So, this schema is not such strict as defined in the YAML specification.
          // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
          "use strict";
          var Schema = require("../schema");
          module.exports = new Schema({
            include: [require("./failsafe")],
            implicit: [
              require("../type/null"),
              require("../type/bool"),
              require("../type/int"),
              require("../type/float")
            ]
          });
        },
        {
          "../schema": 162,
          "../type/bool": 170,
          "../type/float": 171,
          "../type/int": 172,
          "../type/null": 178,
          "./failsafe": 166
        }
      ],
      168: [
        function (require, module, exports) {
          "use strict";
          var YAMLException = require("./exception");
          var TYPE_CONSTRUCTOR_OPTIONS = [
            "kind",
            "resolve",
            "construct",
            "instanceOf",
            "predicate",
            "represent",
            "defaultStyle",
            "styleAliases"
          ];
          var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
          function compileStyleAliases(map) {
            var result = {};
            if (map !== null) {
              Object.keys(map).forEach(function (style) {
                map[style].forEach(function (alias) {
                  result[String(alias)] = style;
                });
              });
            }
            return result;
          }
          function Type(tag, options) {
            options = options || {};
            Object.keys(options).forEach(function (name) {
              if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
                throw new YAMLException(
                  'Unknown option "' +
                    name +
                    '" is met in definition of "' +
                    tag +
                    '" YAML type.'
                );
              }
            }); // TODO: Add tag format check.
            this.tag = tag;
            this.kind = options["kind"] || null;
            this.resolve =
              options["resolve"] ||
              function () {
                return true;
              };
            this.construct =
              options["construct"] ||
              function (data) {
                return data;
              };
            this.instanceOf = options["instanceOf"] || null;
            this.predicate = options["predicate"] || null;
            this.represent = options["represent"] || null;
            this.defaultStyle = options["defaultStyle"] || null;
            this.styleAliases = compileStyleAliases(
              options["styleAliases"] || null
            );
            if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
              throw new YAMLException(
                'Unknown kind "' +
                  this.kind +
                  '" is specified for "' +
                  tag +
                  '" YAML type.'
              );
            }
          }
          module.exports = Type;
        },
        { "./exception": 159 }
      ],
      169: [
        function (require, module, exports) {
          "use strict";
          /*eslint-disable no-bitwise*/ var NodeBuffer;
          try {
            // A trick for browserified version, to not include `Buffer` shim
            var _require = require;
            NodeBuffer = _require("buffer").Buffer;
          } catch (__) {}
          var Type = require("../type"); // [ 64, 65, 66 ] -> [ padding, CR, LF ]
          var BASE64_MAP =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
          function resolveYamlBinary(data) {
            if (data === null) return false;
            var code,
              idx,
              bitlen = 0,
              max = data.length,
              map = BASE64_MAP; // Convert one by one.
            for (idx = 0; idx < max; idx++) {
              code = map.indexOf(data.charAt(idx)); // Skip CR/LF
              if (code > 64) continue; // Fail on illegal characters
              if (code < 0) return false;
              bitlen += 6;
            } // If there are any bits left, source was corrupted
            return bitlen % 8 === 0;
          }
          function constructYamlBinary(data) {
            var idx,
              tailbits,
              input = data.replace(/[\r\n=]/g, ""), // remove CR/LF & padding to simplify scan
              max = input.length,
              map = BASE64_MAP,
              bits = 0,
              result = []; // Collect by 6*4 bits (3 bytes)
            for (idx = 0; idx < max; idx++) {
              if (idx % 4 === 0 && idx) {
                result.push((bits >> 16) & 0xff);
                result.push((bits >> 8) & 0xff);
                result.push(bits & 0xff);
              }
              bits = (bits << 6) | map.indexOf(input.charAt(idx));
            } // Dump tail
            tailbits = (max % 4) * 6;
            if (tailbits === 0) {
              result.push((bits >> 16) & 0xff);
              result.push((bits >> 8) & 0xff);
              result.push(bits & 0xff);
            } else if (tailbits === 18) {
              result.push((bits >> 10) & 0xff);
              result.push((bits >> 2) & 0xff);
            } else if (tailbits === 12) {
              result.push((bits >> 4) & 0xff);
            } // Wrap into Buffer for NodeJS and leave Array for browser
            if (NodeBuffer) {
              // Support node 6.+ Buffer API when available
              return NodeBuffer.from
                ? NodeBuffer.from(result)
                : new NodeBuffer(result);
            }
            return result;
          }
          function representYamlBinary(object /*, style*/) {
            var result = "",
              bits = 0,
              idx,
              tail,
              max = object.length,
              map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.
            for (idx = 0; idx < max; idx++) {
              if (idx % 3 === 0 && idx) {
                result += map[(bits >> 18) & 0x3f];
                result += map[(bits >> 12) & 0x3f];
                result += map[(bits >> 6) & 0x3f];
                result += map[bits & 0x3f];
              }
              bits = (bits << 8) + object[idx];
            } // Dump tail
            tail = max % 3;
            if (tail === 0) {
              result += map[(bits >> 18) & 0x3f];
              result += map[(bits >> 12) & 0x3f];
              result += map[(bits >> 6) & 0x3f];
              result += map[bits & 0x3f];
            } else if (tail === 2) {
              result += map[(bits >> 10) & 0x3f];
              result += map[(bits >> 4) & 0x3f];
              result += map[(bits << 2) & 0x3f];
              result += map[64];
            } else if (tail === 1) {
              result += map[(bits >> 2) & 0x3f];
              result += map[(bits << 4) & 0x3f];
              result += map[64];
              result += map[64];
            }
            return result;
          }
          function isBinary(object) {
            return NodeBuffer && NodeBuffer.isBuffer(object);
          }
          module.exports = new Type("tag:yaml.org,2002:binary", {
            kind: "scalar",
            resolve: resolveYamlBinary,
            construct: constructYamlBinary,
            predicate: isBinary,
            represent: representYamlBinary
          });
        },
        { "../type": 168 }
      ],
      170: [
        function (require, module, exports) {
          arguments[4][33][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 33 }
      ],
      171: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var Type = require("../type");
          var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
            "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + // .2e4, .2
              // special case, seems not from spec
              "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + // 20:59
              "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + // .inf
              "|[-+]?\\.(?:inf|Inf|INF)" + // .nan
              "|\\.(?:nan|NaN|NAN))$"
          );
          function resolveYamlFloat(data) {
            if (data === null) return false;
            if (
              !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
              // Probably should update regexp & check speed
              data[data.length - 1] === "_"
            ) {
              return false;
            }
            return true;
          }
          function constructYamlFloat(data) {
            var value, sign, base, digits;
            value = data.replace(/_/g, "").toLowerCase();
            sign = value[0] === "-" ? -1 : 1;
            digits = [];
            if ("+-".indexOf(value[0]) >= 0) {
              value = value.slice(1);
            }
            if (value === ".inf") {
              return sign === 1
                ? Number.POSITIVE_INFINITY
                : Number.NEGATIVE_INFINITY;
            } else if (value === ".nan") {
              return NaN;
            } else if (value.indexOf(":") >= 0) {
              value.split(":").forEach(function (v) {
                digits.unshift(parseFloat(v, 10));
              });
              value = 0.0;
              base = 1;
              digits.forEach(function (d) {
                value += d * base;
                base *= 60;
              });
              return sign * value;
            }
            return sign * parseFloat(value, 10);
          }
          var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
          function representYamlFloat(object, style) {
            var res;
            if (isNaN(object)) {
              switch (style) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            } else if (Number.POSITIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            } else if (Number.NEGATIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            } else if (common.isNegativeZero(object)) {
              return "-0.0";
            }
            res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
            // while YAML requres dot: 5.e-100. Fix it with simple hack
            return SCIENTIFIC_WITHOUT_DOT.test(res)
              ? res.replace("e", ".e")
              : res;
          }
          function isFloat(object) {
            return (
              Object.prototype.toString.call(object) === "[object Number]" &&
              (object % 1 !== 0 || common.isNegativeZero(object))
            );
          }
          module.exports = new Type("tag:yaml.org,2002:float", {
            kind: "scalar",
            resolve: resolveYamlFloat,
            construct: constructYamlFloat,
            predicate: isFloat,
            represent: representYamlFloat,
            defaultStyle: "lowercase"
          });
        },
        { "../common": 157, "../type": 168 }
      ],
      172: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var Type = require("../type");
          function isHexCode(c) {
            return (
              (0x30 /* 0 */ <= c && c <= 0x39) /* 9 */ ||
              (0x41 /* A */ <= c && c <= 0x46) /* F */ ||
              (0x61 /* a */ <= c && c <= 0x66) /* f */
            );
          }
          function isOctCode(c) {
            return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
          }
          function isDecCode(c) {
            return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
          }
          function resolveYamlInteger(data) {
            if (data === null) return false;
            var max = data.length,
              index = 0,
              hasDigits = false,
              ch;
            if (!max) return false;
            ch = data[index]; // sign
            if (ch === "-" || ch === "+") {
              ch = data[++index];
            }
            if (ch === "0") {
              // 0
              if (index + 1 === max) return true;
              ch = data[++index]; // base 2, base 8, base 16
              if (ch === "b") {
                // base 2
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (ch !== "0" && ch !== "1") return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
              if (ch === "x") {
                // base 16
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (!isHexCode(data.charCodeAt(index))) return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              } // base 8
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_") continue;
                if (!isOctCode(data.charCodeAt(index))) return false;
                hasDigits = true;
              }
              return hasDigits && ch !== "_";
            } // base 10 (except 0) or base 60
            // value should not start with `_`;
            if (ch === "_") return false;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (ch === ":") break;
              if (!isDecCode(data.charCodeAt(index))) {
                return false;
              }
              hasDigits = true;
            } // Should have digits and should not end with `_`
            if (!hasDigits || ch === "_") return false; // if !base60 - done;
            if (ch !== ":") return true; // base60 almost not used, no needs to optimize
            return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
          }
          function constructYamlInteger(data) {
            var value = data,
              sign = 1,
              ch,
              base,
              digits = [];
            if (value.indexOf("_") !== -1) {
              value = value.replace(/_/g, "");
            }
            ch = value[0];
            if (ch === "-" || ch === "+") {
              if (ch === "-") sign = -1;
              value = value.slice(1);
              ch = value[0];
            }
            if (value === "0") return 0;
            if (ch === "0") {
              if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
              if (value[1] === "x") return sign * parseInt(value, 16);
              return sign * parseInt(value, 8);
            }
            if (value.indexOf(":") !== -1) {
              value.split(":").forEach(function (v) {
                digits.unshift(parseInt(v, 10));
              });
              value = 0;
              base = 1;
              digits.forEach(function (d) {
                value += d * base;
                base *= 60;
              });
              return sign * value;
            }
            return sign * parseInt(value, 10);
          }
          function isInteger(object) {
            return (
              Object.prototype.toString.call(object) === "[object Number]" &&
              object % 1 === 0 &&
              !common.isNegativeZero(object)
            );
          }
          module.exports = new Type("tag:yaml.org,2002:int", {
            kind: "scalar",
            resolve: resolveYamlInteger,
            construct: constructYamlInteger,
            predicate: isInteger,
            represent: {
              binary: function binary(obj) {
                return obj >= 0
                  ? "0b" + obj.toString(2)
                  : "-0b" + obj.toString(2).slice(1);
              },
              octal: function octal(obj) {
                return obj >= 0
                  ? "0" + obj.toString(8)
                  : "-0" + obj.toString(8).slice(1);
              },
              decimal: function decimal(obj) {
                return obj.toString(10);
              },
              /* eslint-disable max-len */ hexadecimal: function hexadecimal(
                obj
              ) {
                return obj >= 0
                  ? "0x" + obj.toString(16).toUpperCase()
                  : "-0x" + obj.toString(16).toUpperCase().slice(1);
              }
            },
            defaultStyle: "decimal",
            styleAliases: {
              binary: [2, "bin"],
              octal: [8, "oct"],
              decimal: [10, "dec"],
              hexadecimal: [16, "hex"]
            }
          });
        },
        { "../common": 157, "../type": 168 }
      ],
      173: [
        function (require, module, exports) {
          "use strict";
          var esprima; // Browserified version does not have esprima
          //
          // 1. For node.js just require module as deps
          // 2. For browser try to require mudule via external AMD system.
          //    If not found - try to fallback to window.esprima. If not
          //    found too - then fail to parse.
          //
          try {
            // workaround to exclude package from browserify list.
            var _require = require;
            esprima = _require("esprima");
          } catch (_) {
            /* eslint-disable no-redeclare */ /* global window */ if (
              typeof window !== "undefined"
            )
              esprima = window.esprima;
          }
          var Type = require("../../type");
          function resolveJavascriptFunction(data) {
            if (data === null) return false;
            try {
              var source = "(" + data + ")",
                ast = esprima.parse(source, { range: true });
              if (
                ast.type !== "Program" ||
                ast.body.length !== 1 ||
                ast.body[0].type !== "ExpressionStatement" ||
                (ast.body[0].expression.type !== "ArrowFunctionExpression" &&
                  ast.body[0].expression.type !== "FunctionExpression")
              ) {
                return false;
              }
              return true;
            } catch (err) {
              return false;
            }
          }
          function constructJavascriptFunction(data) {
            /*jslint evil:true*/ var source = "(" + data + ")",
              ast = esprima.parse(source, { range: true }),
              params = [],
              body;
            if (
              ast.type !== "Program" ||
              ast.body.length !== 1 ||
              ast.body[0].type !== "ExpressionStatement" ||
              (ast.body[0].expression.type !== "ArrowFunctionExpression" &&
                ast.body[0].expression.type !== "FunctionExpression")
            ) {
              throw new Error("Failed to resolve function");
            }
            ast.body[0].expression.params.forEach(function (param) {
              params.push(param.name);
            });
            body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on
            // function expressions. So cut them out.
            if (ast.body[0].expression.body.type === "BlockStatement") {
              /*eslint-disable no-new-func*/ return new Function(
                params,
                source.slice(body[0] + 1, body[1] - 1)
              );
            } // ES6 arrow functions can omit the BlockStatement. In that case, just return
            // the body.
            /*eslint-disable no-new-func*/ return new Function(
              params,
              "return " + source.slice(body[0], body[1])
            );
          }
          function representJavascriptFunction(object /*, style*/) {
            return object.toString();
          }
          function isFunction(object) {
            return Object.prototype.toString.call(object) === "[object Function]";
          }
          module.exports = new Type("tag:yaml.org,2002:js/function", {
            kind: "scalar",
            resolve: resolveJavascriptFunction,
            construct: constructJavascriptFunction,
            predicate: isFunction,
            represent: representJavascriptFunction
          });
        },
        { "../../type": 168 }
      ],
      174: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../../type");
          function resolveJavascriptRegExp(data) {
            if (data === null) return false;
            if (data.length === 0) return false;
            var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = ""; // if regexp starts with '/' it can have modifiers and must be properly closed
            // `/foo/gim` - modifiers tail can be maximum 3 chars
            if (regexp[0] === "/") {
              if (tail) modifiers = tail[1];
              if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated
              if (regexp[regexp.length - modifiers.length - 1] !== "/")
                return false;
            }
            return true;
          }
          function constructJavascriptRegExp(data) {
            var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = ""; // `/foo/gim` - tail can be maximum 4 chars
            if (regexp[0] === "/") {
              if (tail) modifiers = tail[1];
              regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
            }
            return new RegExp(regexp, modifiers);
          }
          function representJavascriptRegExp(object /*, style*/) {
            var result = "/" + object.source + "/";
            if (object.global) result += "g";
            if (object.multiline) result += "m";
            if (object.ignoreCase) result += "i";
            return result;
          }
          function isRegExp(object) {
            return Object.prototype.toString.call(object) === "[object RegExp]";
          }
          module.exports = new Type("tag:yaml.org,2002:js/regexp", {
            kind: "scalar",
            resolve: resolveJavascriptRegExp,
            construct: constructJavascriptRegExp,
            predicate: isRegExp,
            represent: representJavascriptRegExp
          });
        },
        { "../../type": 168 }
      ],
      175: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../../type");
          function resolveJavascriptUndefined() {
            return true;
          }
          function constructJavascriptUndefined() {
            /*eslint-disable no-undefined*/ return undefined;
          }
          function representJavascriptUndefined() {
            return "";
          }
          function isUndefined(object) {
            return typeof object === "undefined";
          }
          module.exports = new Type("tag:yaml.org,2002:js/undefined", {
            kind: "scalar",
            resolve: resolveJavascriptUndefined,
            construct: constructJavascriptUndefined,
            predicate: isUndefined,
            represent: representJavascriptUndefined
          });
        },
        { "../../type": 168 }
      ],
      176: [
        function (require, module, exports) {
          arguments[4][36][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 36 }
      ],
      177: [
        function (require, module, exports) {
          arguments[4][37][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 37 }
      ],
      178: [
        function (require, module, exports) {
          "use strict";
          var Type = require("../type");
          function resolveYamlNull(data) {
            if (data === null) return true;
            var max = data.length;
            return (
              (max === 1 && data === "~") ||
              (max === 4 &&
                (data === "null" || data === "Null" || data === "NULL"))
            );
          }
          function constructYamlNull() {
            return null;
          }
          function isNull(object) {
            return object === null;
          }
          module.exports = new Type("tag:yaml.org,2002:null", {
            kind: "scalar",
            resolve: resolveYamlNull,
            construct: constructYamlNull,
            predicate: isNull,
            represent: {
              canonical: function canonical() {
                return "~";
              },
              lowercase: function lowercase() {
                return "null";
              },
              uppercase: function uppercase() {
                return "NULL";
              },
              camelcase: function camelcase() {
                return "Null";
              }
            },
            defaultStyle: "lowercase"
          });
        },
        { "../type": 168 }
      ],
      179: [
        function (require, module, exports) {
          arguments[4][39][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 39 }
      ],
      180: [
        function (require, module, exports) {
          arguments[4][40][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 40 }
      ],
      181: [
        function (require, module, exports) {
          arguments[4][41][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 41 }
      ],
      182: [
        function (require, module, exports) {
          arguments[4][42][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 42 }
      ],
      183: [
        function (require, module, exports) {
          arguments[4][43][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 43 }
      ],
      184: [
        function (require, module, exports) {
          arguments[4][44][0].apply(exports, arguments);
        },
        { "../type": 168, dup: 44 }
      ],
      185: [
        function (require, module, exports) {
          "use strict";
          var traverse = (module.exports = function (schema, opts, cb) {
            // Legacy support for v0.3.1 and earlier.
            if (typeof opts == "function") {
              cb = opts;
              opts = {};
            }
            cb = opts.cb || cb;
            var pre = typeof cb == "function" ? cb : cb.pre || function () {};
            var post = cb.post || function () {};
            _traverse(opts, pre, post, schema, "", schema);
          });
          traverse.keywords = {
            additionalItems: true,
            items: true,
            contains: true,
            additionalProperties: true,
            propertyNames: true,
            not: true
          };
          traverse.arrayKeywords = {
            items: true,
            allOf: true,
            anyOf: true,
            oneOf: true
          };
          traverse.propsKeywords = {
            definitions: true,
            properties: true,
            patternProperties: true,
            dependencies: true
          };
          traverse.skipKeywords = {
            default: true,
            enum: true,
            const: true,
            required: true,
            maximum: true,
            minimum: true,
            exclusiveMaximum: true,
            exclusiveMinimum: true,
            multipleOf: true,
            maxLength: true,
            minLength: true,
            pattern: true,
            format: true,
            maxItems: true,
            minItems: true,
            uniqueItems: true,
            maxProperties: true,
            minProperties: true
          };
          function _traverse(
            opts,
            pre,
            post,
            schema,
            jsonPtr,
            rootSchema,
            parentJsonPtr,
            parentKeyword,
            parentSchema,
            keyIndex
          ) {
            if (
              schema &&
              _typeof2(schema) == "object" &&
              !Array.isArray(schema)
            ) {
              pre(
                schema,
                jsonPtr,
                rootSchema,
                parentJsonPtr,
                parentKeyword,
                parentSchema,
                keyIndex
              );
              for (var key in schema) {
                var sch = schema[key];
                if (Array.isArray(sch)) {
                  if (key in traverse.arrayKeywords) {
                    for (var i = 0; i < sch.length; i++) {
                      _traverse(
                        opts,
                        pre,
                        post,
                        sch[i],
                        jsonPtr + "/" + key + "/" + i,
                        rootSchema,
                        jsonPtr,
                        key,
                        schema,
                        i
                      );
                    }
                  }
                } else if (key in traverse.propsKeywords) {
                  if (sch && _typeof2(sch) == "object") {
                    for (var prop in sch) {
                      _traverse(
                        opts,
                        pre,
                        post,
                        sch[prop],
                        jsonPtr + "/" + key + "/" + escapeJsonPtr(prop),
                        rootSchema,
                        jsonPtr,
                        key,
                        schema,
                        prop
                      );
                    }
                  }
                } else if (
                  key in traverse.keywords ||
                  (opts.allKeys && !(key in traverse.skipKeywords))
                ) {
                  _traverse(
                    opts,
                    pre,
                    post,
                    sch,
                    jsonPtr + "/" + key,
                    rootSchema,
                    jsonPtr,
                    key,
                    schema
                  );
                }
              }
              post(
                schema,
                jsonPtr,
                rootSchema,
                parentJsonPtr,
                parentKeyword,
                parentSchema,
                keyIndex
              );
            }
          }
          function escapeJsonPtr(str) {
            return str.replace(/~/g, "~0").replace(/\//g, "~1");
          }
        },
        {}
      ],
      186: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              (function (global, factory) {
                _typeof2(exports) === "object" && typeof module !== "undefined"
                  ? (module.exports = factory())
                  : typeof define === "function" && define.amd
                  ? define(factory)
                  : (global.jsonToAst = factory());
              })(this, function () {
                "use strict";
                var commonjsGlobal =
                  typeof window !== "undefined"
                    ? window
                    : typeof global !== "undefined"
                    ? global
                    : typeof self !== "undefined"
                    ? self
                    : {};
                function createCommonjsModule(fn, module) {
                  return (
                    (module = { exports: {} }),
                    fn(module, module.exports),
                    module.exports
                  );
                }
                var graphemeSplitter = createCommonjsModule(function (module) {
                  /*
   Breaks a Javascript string into individual user-perceived "characters" 
   called extended grapheme clusters by implementing the Unicode UAX-29 standard, version 10.0.0
   
   Usage:
   var splitter = new GraphemeSplitter();
   //returns an array of strings, one string for each grapheme cluster
   var graphemes = splitter.splitGraphemes(string); 
   
   */ function GraphemeSplitter() {
                    var CR = 0,
                      LF = 1,
                      Control = 2,
                      Extend = 3,
                      Regional_Indicator = 4,
                      SpacingMark = 5,
                      L = 6,
                      V = 7,
                      T = 8,
                      LV = 9,
                      LVT = 10,
                      Other = 11,
                      Prepend = 12,
                      E_Base = 13,
                      E_Modifier = 14,
                      ZWJ = 15,
                      Glue_After_Zwj = 16,
                      E_Base_GAZ = 17; // BreakTypes
                    var NotBreak = 0,
                      BreakStart = 1,
                      Break = 2,
                      BreakLastRegional = 3,
                      BreakPenultimateRegional = 4;
                    function isSurrogate(str, pos) {
                      return (
                        0xd800 <= str.charCodeAt(pos) &&
                        str.charCodeAt(pos) <= 0xdbff &&
                        0xdc00 <= str.charCodeAt(pos + 1) &&
                        str.charCodeAt(pos + 1) <= 0xdfff
                      );
                    } // Private function, gets a Unicode code point from a JavaScript UTF-16 string
                    // handling surrogate pairs appropriately
                    function codePointAt(str, idx) {
                      if (idx === undefined) {
                        idx = 0;
                      }
                      var code = str.charCodeAt(idx); // if a high surrogate
                      if (
                        0xd800 <= code &&
                        code <= 0xdbff &&
                        idx < str.length - 1
                      ) {
                        var hi = code;
                        var low = str.charCodeAt(idx + 1);
                        if (0xdc00 <= low && low <= 0xdfff) {
                          return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;
                        }
                        return hi;
                      } // if a low surrogate
                      if (0xdc00 <= code && code <= 0xdfff && idx >= 1) {
                        var hi = str.charCodeAt(idx - 1);
                        var low = code;
                        if (0xd800 <= hi && hi <= 0xdbff) {
                          return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;
                        }
                        return low;
                      } //just return the char if an unmatched surrogate half or a
                      //single-char codepoint
                      return code;
                    } // Private function, returns whether a break is allowed between the
                    // two given grapheme breaking classes
                    function shouldBreak(start, mid, end) {
                      var all = [start].concat(mid).concat([end]);
                      var previous = all[all.length - 2];
                      var next = end; // Lookahead termintor for:
                      // GB10. (E_Base | EBG) Extend* ?	E_Modifier
                      var eModifierIndex = all.lastIndexOf(E_Modifier);
                      if (
                        eModifierIndex > 1 &&
                        all.slice(1, eModifierIndex).every(function (c) {
                          return c == Extend;
                        }) &&
                        [Extend, E_Base, E_Base_GAZ].indexOf(start) == -1
                      ) {
                        return Break;
                      } // Lookahead termintor for:
                      // GB12. ^ (RI RI)* RI	?	RI
                      // GB13. [^RI] (RI RI)* RI	?	RI
                      var rIIndex = all.lastIndexOf(Regional_Indicator);
                      if (
                        rIIndex > 0 &&
                        all.slice(1, rIIndex).every(function (c) {
                          return c == Regional_Indicator;
                        }) &&
                        [Prepend, Regional_Indicator].indexOf(previous) == -1
                      ) {
                        if (
                          all.filter(function (c) {
                            return c == Regional_Indicator;
                          }).length %
                            2 ==
                          1
                        ) {
                          return BreakLastRegional;
                        } else {
                          return BreakPenultimateRegional;
                        }
                      } // GB3. CR X LF
                      if (previous == CR && next == LF) {
                        return NotBreak;
                      } // GB4. (Control|CR|LF) ÷
                      else if (
                        previous == Control ||
                        previous == CR ||
                        previous == LF
                      ) {
                        if (
                          next == E_Modifier &&
                          mid.every(function (c) {
                            return c == Extend;
                          })
                        ) {
                          return Break;
                        } else {
                          return BreakStart;
                        }
                      } // GB5. ÷ (Control|CR|LF)
                      else if (next == Control || next == CR || next == LF) {
                        return BreakStart;
                      } // GB6. L X (L|V|LV|LVT)
                      else if (
                        previous == L &&
                        (next == L || next == V || next == LV || next == LVT)
                      ) {
                        return NotBreak;
                      } // GB7. (LV|V) X (V|T)
                      else if (
                        (previous == LV || previous == V) &&
                        (next == V || next == T)
                      ) {
                        return NotBreak;
                      } // GB8. (LVT|T) X (T)
                      else if ((previous == LVT || previous == T) && next == T) {
                        return NotBreak;
                      } // GB9. X (Extend|ZWJ)
                      else if (next == Extend || next == ZWJ) {
                        return NotBreak;
                      } // GB9a. X SpacingMark
                      else if (next == SpacingMark) {
                        return NotBreak;
                      } // GB9b. Prepend X
                      else if (previous == Prepend) {
                        return NotBreak;
                      } // GB10. (E_Base | EBG) Extend* ?	E_Modifier
                      var previousNonExtendIndex =
                        all.indexOf(Extend) != -1
                          ? all.lastIndexOf(Extend) - 1
                          : all.length - 2;
                      if (
                        [E_Base, E_Base_GAZ].indexOf(
                          all[previousNonExtendIndex]
                        ) != -1 &&
                        all
                          .slice(previousNonExtendIndex + 1, -1)
                          .every(function (c) {
                            return c == Extend;
                          }) &&
                        next == E_Modifier
                      ) {
                        return NotBreak;
                      } // GB11. ZWJ ? (Glue_After_Zwj | EBG)
                      if (
                        previous == ZWJ &&
                        [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1
                      ) {
                        return NotBreak;
                      } // GB12. ^ (RI RI)* RI ? RI
                      // GB13. [^RI] (RI RI)* RI ? RI
                      if (mid.indexOf(Regional_Indicator) != -1) {
                        return Break;
                      }
                      if (
                        previous == Regional_Indicator &&
                        next == Regional_Indicator
                      ) {
                        return NotBreak;
                      } // GB999. Any ? Any
                      return BreakStart;
                    } // Returns the next grapheme break in the string after the given index
                    this.nextBreak = function (string, index) {
                      if (index === undefined) {
                        index = 0;
                      }
                      if (index < 0) {
                        return 0;
                      }
                      if (index >= string.length - 1) {
                        return string.length;
                      }
                      var prev = getGraphemeBreakProperty(
                        codePointAt(string, index)
                      );
                      var mid = [];
                      for (var i = index + 1; i < string.length; i++) {
                        // check for already processed low surrogates
                        if (isSurrogate(string, i - 1)) {
                          continue;
                        }
                        var next = getGraphemeBreakProperty(
                          codePointAt(string, i)
                        );
                        if (shouldBreak(prev, mid, next)) {
                          return i;
                        }
                        mid.push(next);
                      }
                      return string.length;
                    }; // Breaks the given string into an array of grapheme cluster strings
                    this.splitGraphemes = function (str) {
                      var res = [];
                      var index = 0;
                      var brk;
                      while ((brk = this.nextBreak(str, index)) < str.length) {
                        res.push(str.slice(index, brk));
                        index = brk;
                      }
                      if (index < str.length) {
                        res.push(str.slice(index));
                      }
                      return res;
                    }; // Returns the iterator of grapheme clusters there are in the given string
                    this.iterateGraphemes = function (str) {
                      var index = 0;
                      var res = {
                        next: function () {
                          var value;
                          var brk;
                          if ((brk = this.nextBreak(str, index)) < str.length) {
                            value = str.slice(index, brk);
                            index = brk;
                            return { value: value, done: false };
                          }
                          if (index < str.length) {
                            value = str.slice(index);
                            index = str.length;
                            return { value: value, done: false };
                          }
                          return { value: undefined, done: true };
                        }.bind(this)
                      }; // ES2015 @@iterator method (iterable) for spread syntax and for...of statement
                      if (typeof Symbol !== "undefined" && Symbol.iterator) {
                        res[Symbol.iterator] = function () {
                          return res;
                        };
                      }
                      return res;
                    }; // Returns the number of grapheme clusters there are in the given string
                    this.countGraphemes = function (str) {
                      var count = 0;
                      var index = 0;
                      var brk;
                      while ((brk = this.nextBreak(str, index)) < str.length) {
                        index = brk;
                        count++;
                      }
                      if (index < str.length) {
                        count++;
                      }
                      return count;
                    }; //given a Unicode code point, determines this symbol's grapheme break property
                    function getGraphemeBreakProperty(code) {
                      //grapheme break property for Unicode 10.0.0,
                      //taken from http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
                      //and adapted to JavaScript rules
                      if (
                        (0x0600 <= code && code <= 0x0605) || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
                        0x06dd == code || // Cf       ARABIC END OF AYAH
                        0x070f == code || // Cf       SYRIAC ABBREVIATION MARK
                        0x08e2 == code || // Cf       ARABIC DISPUTED END OF AYAH
                        0x0d4e == code || // Lo       MALAYALAM LETTER DOT REPH
                        0x110bd == code || // Cf       KAITHI NUMBER SIGN
                        (0x111c2 <= code && code <= 0x111c3) || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
                        0x11a3a == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
                        (0x11a86 <= code && code <= 0x11a89) || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
                        0x11d46 == code // Lo       MASARAM GONDI REPHA
                      ) {
                        return Prepend;
                      }
                      if (
                        0x000d == code // Cc       <control-000D>
                      ) {
                        return CR;
                      }
                      if (
                        0x000a == code // Cc       <control-000A>
                      ) {
                        return LF;
                      }
                      if (
                        (0x0000 <= code && code <= 0x0009) || // Cc  [10] <control-0000>..<control-0009>
                        (0x000b <= code && code <= 0x000c) || // Cc   [2] <control-000B>..<control-000C>
                        (0x000e <= code && code <= 0x001f) || // Cc  [18] <control-000E>..<control-001F>
                        (0x007f <= code && code <= 0x009f) || // Cc  [33] <control-007F>..<control-009F>
                        0x00ad == code || // Cf       SOFT HYPHEN
                        0x061c == code || // Cf       ARABIC LETTER MARK
                        0x180e == code || // Cf       MONGOLIAN VOWEL SEPARATOR
                        0x200b == code || // Cf       ZERO WIDTH SPACE
                        (0x200e <= code && code <= 0x200f) || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
                        0x2028 == code || // Zl       LINE SEPARATOR
                        0x2029 == code || // Zp       PARAGRAPH SEPARATOR
                        (0x202a <= code && code <= 0x202e) || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
                        (0x2060 <= code && code <= 0x2064) || // Cf   [5] WORD JOINER..INVISIBLE PLUS
                        0x2065 == code || // Cn       <reserved-2065>
                        (0x2066 <= code && code <= 0x206f) || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
                        (0xd800 <= code && code <= 0xdfff) || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
                        0xfeff == code || // Cf       ZERO WIDTH NO-BREAK SPACE
                        (0xfff0 <= code && code <= 0xfff8) || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
                        (0xfff9 <= code && code <= 0xfffb) || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
                        (0x1bca0 <= code && code <= 0x1bca3) || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
                        (0x1d173 <= code && code <= 0x1d17a) || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
                        0xe0000 == code || // Cn       <reserved-E0000>
                        0xe0001 == code || // Cf       LANGUAGE TAG
                        (0xe0002 <= code && code <= 0xe001f) || // Cn  [30] <reserved-E0002>..<reserved-E001F>
                        (0xe0080 <= code && code <= 0xe00ff) || // Cn [128] <reserved-E0080>..<reserved-E00FF>
                        (0xe01f0 <= code && code <= 0xe0fff) // Cn [3600] <reserved-E01F0>..<reserved-E0FFF>
                      ) {
                        return Control;
                      }
                      if (
                        (0x0300 <= code && code <= 0x036f) || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
                        (0x0483 <= code && code <= 0x0487) || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
                        (0x0488 <= code && code <= 0x0489) || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
                        (0x0591 <= code && code <= 0x05bd) || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
                        0x05bf == code || // Mn       HEBREW POINT RAFE
                        (0x05c1 <= code && code <= 0x05c2) || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
                        (0x05c4 <= code && code <= 0x05c5) || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
                        0x05c7 == code || // Mn       HEBREW POINT QAMATS QATAN
                        (0x0610 <= code && code <= 0x061a) || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
                        (0x064b <= code && code <= 0x065f) || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
                        0x0670 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
                        (0x06d6 <= code && code <= 0x06dc) || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
                        (0x06df <= code && code <= 0x06e4) || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
                        (0x06e7 <= code && code <= 0x06e8) || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
                        (0x06ea <= code && code <= 0x06ed) || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
                        0x0711 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
                        (0x0730 <= code && code <= 0x074a) || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
                        (0x07a6 <= code && code <= 0x07b0) || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
                        (0x07eb <= code && code <= 0x07f3) || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
                        (0x0816 <= code && code <= 0x0819) || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
                        (0x081b <= code && code <= 0x0823) || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
                        (0x0825 <= code && code <= 0x0827) || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
                        (0x0829 <= code && code <= 0x082d) || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
                        (0x0859 <= code && code <= 0x085b) || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
                        (0x08d4 <= code && code <= 0x08e1) || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
                        (0x08e3 <= code && code <= 0x0902) || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
                        0x093a == code || // Mn       DEVANAGARI VOWEL SIGN OE
                        0x093c == code || // Mn       DEVANAGARI SIGN NUKTA
                        (0x0941 <= code && code <= 0x0948) || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
                        0x094d == code || // Mn       DEVANAGARI SIGN VIRAMA
                        (0x0951 <= code && code <= 0x0957) || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
                        (0x0962 <= code && code <= 0x0963) || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
                        0x0981 == code || // Mn       BENGALI SIGN CANDRABINDU
                        0x09bc == code || // Mn       BENGALI SIGN NUKTA
                        0x09be == code || // Mc       BENGALI VOWEL SIGN AA
                        (0x09c1 <= code && code <= 0x09c4) || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
                        0x09cd == code || // Mn       BENGALI SIGN VIRAMA
                        0x09d7 == code || // Mc       BENGALI AU LENGTH MARK
                        (0x09e2 <= code && code <= 0x09e3) || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
                        (0x0a01 <= code && code <= 0x0a02) || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
                        0x0a3c == code || // Mn       GURMUKHI SIGN NUKTA
                        (0x0a41 <= code && code <= 0x0a42) || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
                        (0x0a47 <= code && code <= 0x0a48) || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
                        (0x0a4b <= code && code <= 0x0a4d) || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
                        0x0a51 == code || // Mn       GURMUKHI SIGN UDAAT
                        (0x0a70 <= code && code <= 0x0a71) || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
                        0x0a75 == code || // Mn       GURMUKHI SIGN YAKASH
                        (0x0a81 <= code && code <= 0x0a82) || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
                        0x0abc == code || // Mn       GUJARATI SIGN NUKTA
                        (0x0ac1 <= code && code <= 0x0ac5) || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
                        (0x0ac7 <= code && code <= 0x0ac8) || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
                        0x0acd == code || // Mn       GUJARATI SIGN VIRAMA
                        (0x0ae2 <= code && code <= 0x0ae3) || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
                        (0x0afa <= code && code <= 0x0aff) || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
                        0x0b01 == code || // Mn       ORIYA SIGN CANDRABINDU
                        0x0b3c == code || // Mn       ORIYA SIGN NUKTA
                        0x0b3e == code || // Mc       ORIYA VOWEL SIGN AA
                        0x0b3f == code || // Mn       ORIYA VOWEL SIGN I
                        (0x0b41 <= code && code <= 0x0b44) || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
                        0x0b4d == code || // Mn       ORIYA SIGN VIRAMA
                        0x0b56 == code || // Mn       ORIYA AI LENGTH MARK
                        0x0b57 == code || // Mc       ORIYA AU LENGTH MARK
                        (0x0b62 <= code && code <= 0x0b63) || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
                        0x0b82 == code || // Mn       TAMIL SIGN ANUSVARA
                        0x0bbe == code || // Mc       TAMIL VOWEL SIGN AA
                        0x0bc0 == code || // Mn       TAMIL VOWEL SIGN II
                        0x0bcd == code || // Mn       TAMIL SIGN VIRAMA
                        0x0bd7 == code || // Mc       TAMIL AU LENGTH MARK
                        0x0c00 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
                        (0x0c3e <= code && code <= 0x0c40) || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
                        (0x0c46 <= code && code <= 0x0c48) || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
                        (0x0c4a <= code && code <= 0x0c4d) || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
                        (0x0c55 <= code && code <= 0x0c56) || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
                        (0x0c62 <= code && code <= 0x0c63) || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
                        0x0c81 == code || // Mn       KANNADA SIGN CANDRABINDU
                        0x0cbc == code || // Mn       KANNADA SIGN NUKTA
                        0x0cbf == code || // Mn       KANNADA VOWEL SIGN I
                        0x0cc2 == code || // Mc       KANNADA VOWEL SIGN UU
                        0x0cc6 == code || // Mn       KANNADA VOWEL SIGN E
                        (0x0ccc <= code && code <= 0x0ccd) || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
                        (0x0cd5 <= code && code <= 0x0cd6) || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
                        (0x0ce2 <= code && code <= 0x0ce3) || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
                        (0x0d00 <= code && code <= 0x0d01) || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
                        (0x0d3b <= code && code <= 0x0d3c) || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
                        0x0d3e == code || // Mc       MALAYALAM VOWEL SIGN AA
                        (0x0d41 <= code && code <= 0x0d44) || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
                        0x0d4d == code || // Mn       MALAYALAM SIGN VIRAMA
                        0x0d57 == code || // Mc       MALAYALAM AU LENGTH MARK
                        (0x0d62 <= code && code <= 0x0d63) || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
                        0x0dca == code || // Mn       SINHALA SIGN AL-LAKUNA
                        0x0dcf == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
                        (0x0dd2 <= code && code <= 0x0dd4) || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
                        0x0dd6 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
                        0x0ddf == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
                        0x0e31 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
                        (0x0e34 <= code && code <= 0x0e3a) || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
                        (0x0e47 <= code && code <= 0x0e4e) || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
                        0x0eb1 == code || // Mn       LAO VOWEL SIGN MAI KAN
                        (0x0eb4 <= code && code <= 0x0eb9) || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
                        (0x0ebb <= code && code <= 0x0ebc) || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
                        (0x0ec8 <= code && code <= 0x0ecd) || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
                        (0x0f18 <= code && code <= 0x0f19) || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
                        0x0f35 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
                        0x0f37 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
                        0x0f39 == code || // Mn       TIBETAN MARK TSA -PHRU
                        (0x0f71 <= code && code <= 0x0f7e) || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
                        (0x0f80 <= code && code <= 0x0f84) || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
                        (0x0f86 <= code && code <= 0x0f87) || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
                        (0x0f8d <= code && code <= 0x0f97) || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
                        (0x0f99 <= code && code <= 0x0fbc) || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
                        0x0fc6 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
                        (0x102d <= code && code <= 0x1030) || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
                        (0x1032 <= code && code <= 0x1037) || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
                        (0x1039 <= code && code <= 0x103a) || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
                        (0x103d <= code && code <= 0x103e) || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
                        (0x1058 <= code && code <= 0x1059) || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
                        (0x105e <= code && code <= 0x1060) || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
                        (0x1071 <= code && code <= 0x1074) || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
                        0x1082 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
                        (0x1085 <= code && code <= 0x1086) || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
                        0x108d == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
                        0x109d == code || // Mn       MYANMAR VOWEL SIGN AITON AI
                        (0x135d <= code && code <= 0x135f) || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
                        (0x1712 <= code && code <= 0x1714) || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
                        (0x1732 <= code && code <= 0x1734) || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
                        (0x1752 <= code && code <= 0x1753) || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
                        (0x1772 <= code && code <= 0x1773) || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
                        (0x17b4 <= code && code <= 0x17b5) || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
                        (0x17b7 <= code && code <= 0x17bd) || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
                        0x17c6 == code || // Mn       KHMER SIGN NIKAHIT
                        (0x17c9 <= code && code <= 0x17d3) || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
                        0x17dd == code || // Mn       KHMER SIGN ATTHACAN
                        (0x180b <= code && code <= 0x180d) || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
                        (0x1885 <= code && code <= 0x1886) || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
                        0x18a9 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
                        (0x1920 <= code && code <= 0x1922) || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
                        (0x1927 <= code && code <= 0x1928) || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
                        0x1932 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
                        (0x1939 <= code && code <= 0x193b) || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
                        (0x1a17 <= code && code <= 0x1a18) || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
                        0x1a1b == code || // Mn       BUGINESE VOWEL SIGN AE
                        0x1a56 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
                        (0x1a58 <= code && code <= 0x1a5e) || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
                        0x1a60 == code || // Mn       TAI THAM SIGN SAKOT
                        0x1a62 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
                        (0x1a65 <= code && code <= 0x1a6c) || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
                        (0x1a73 <= code && code <= 0x1a7c) || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
                        0x1a7f == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
                        (0x1ab0 <= code && code <= 0x1abd) || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
                        0x1abe == code || // Me       COMBINING PARENTHESES OVERLAY
                        (0x1b00 <= code && code <= 0x1b03) || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
                        0x1b34 == code || // Mn       BALINESE SIGN REREKAN
                        (0x1b36 <= code && code <= 0x1b3a) || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
                        0x1b3c == code || // Mn       BALINESE VOWEL SIGN LA LENGA
                        0x1b42 == code || // Mn       BALINESE VOWEL SIGN PEPET
                        (0x1b6b <= code && code <= 0x1b73) || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
                        (0x1b80 <= code && code <= 0x1b81) || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
                        (0x1ba2 <= code && code <= 0x1ba5) || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
                        (0x1ba8 <= code && code <= 0x1ba9) || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
                        (0x1bab <= code && code <= 0x1bad) || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
                        0x1be6 == code || // Mn       BATAK SIGN TOMPI
                        (0x1be8 <= code && code <= 0x1be9) || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
                        0x1bed == code || // Mn       BATAK VOWEL SIGN KARO O
                        (0x1bef <= code && code <= 0x1bf1) || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
                        (0x1c2c <= code && code <= 0x1c33) || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
                        (0x1c36 <= code && code <= 0x1c37) || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
                        (0x1cd0 <= code && code <= 0x1cd2) || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
                        (0x1cd4 <= code && code <= 0x1ce0) || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
                        (0x1ce2 <= code && code <= 0x1ce8) || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
                        0x1ced == code || // Mn       VEDIC SIGN TIRYAK
                        0x1cf4 == code || // Mn       VEDIC TONE CANDRA ABOVE
                        (0x1cf8 <= code && code <= 0x1cf9) || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
                        (0x1dc0 <= code && code <= 0x1df9) || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
                        (0x1dfb <= code && code <= 0x1dff) || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
                        0x200c == code || // Cf       ZERO WIDTH NON-JOINER
                        (0x20d0 <= code && code <= 0x20dc) || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
                        (0x20dd <= code && code <= 0x20e0) || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
                        0x20e1 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
                        (0x20e2 <= code && code <= 0x20e4) || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
                        (0x20e5 <= code && code <= 0x20f0) || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
                        (0x2cef <= code && code <= 0x2cf1) || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
                        0x2d7f == code || // Mn       TIFINAGH CONSONANT JOINER
                        (0x2de0 <= code && code <= 0x2dff) || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
                        (0x302a <= code && code <= 0x302d) || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
                        (0x302e <= code && code <= 0x302f) || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
                        (0x3099 <= code && code <= 0x309a) || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
                        0xa66f == code || // Mn       COMBINING CYRILLIC VZMET
                        (0xa670 <= code && code <= 0xa672) || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
                        (0xa674 <= code && code <= 0xa67d) || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
                        (0xa69e <= code && code <= 0xa69f) || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
                        (0xa6f0 <= code && code <= 0xa6f1) || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
                        0xa802 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
                        0xa806 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
                        0xa80b == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
                        (0xa825 <= code && code <= 0xa826) || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
                        (0xa8c4 <= code && code <= 0xa8c5) || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
                        (0xa8e0 <= code && code <= 0xa8f1) || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
                        (0xa926 <= code && code <= 0xa92d) || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
                        (0xa947 <= code && code <= 0xa951) || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
                        (0xa980 <= code && code <= 0xa982) || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
                        0xa9b3 == code || // Mn       JAVANESE SIGN CECAK TELU
                        (0xa9b6 <= code && code <= 0xa9b9) || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
                        0xa9bc == code || // Mn       JAVANESE VOWEL SIGN PEPET
                        0xa9e5 == code || // Mn       MYANMAR SIGN SHAN SAW
                        (0xaa29 <= code && code <= 0xaa2e) || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
                        (0xaa31 <= code && code <= 0xaa32) || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
                        (0xaa35 <= code && code <= 0xaa36) || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
                        0xaa43 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
                        0xaa4c == code || // Mn       CHAM CONSONANT SIGN FINAL M
                        0xaa7c == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
                        0xaab0 == code || // Mn       TAI VIET MAI KANG
                        (0xaab2 <= code && code <= 0xaab4) || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
                        (0xaab7 <= code && code <= 0xaab8) || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
                        (0xaabe <= code && code <= 0xaabf) || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
                        0xaac1 == code || // Mn       TAI VIET TONE MAI THO
                        (0xaaec <= code && code <= 0xaaed) || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
                        0xaaf6 == code || // Mn       MEETEI MAYEK VIRAMA
                        0xabe5 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
                        0xabe8 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
                        0xabed == code || // Mn       MEETEI MAYEK APUN IYEK
                        0xfb1e == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
                        (0xfe00 <= code && code <= 0xfe0f) || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
                        (0xfe20 <= code && code <= 0xfe2f) || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
                        (0xff9e <= code && code <= 0xff9f) || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
                        0x101fd == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
                        0x102e0 == code || // Mn       COPTIC EPACT THOUSANDS MARK
                        (0x10376 <= code && code <= 0x1037a) || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
                        (0x10a01 <= code && code <= 0x10a03) || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
                        (0x10a05 <= code && code <= 0x10a06) || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
                        (0x10a0c <= code && code <= 0x10a0f) || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
                        (0x10a38 <= code && code <= 0x10a3a) || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
                        0x10a3f == code || // Mn       KHAROSHTHI VIRAMA
                        (0x10ae5 <= code && code <= 0x10ae6) || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
                        0x11001 == code || // Mn       BRAHMI SIGN ANUSVARA
                        (0x11038 <= code && code <= 0x11046) || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
                        (0x1107f <= code && code <= 0x11081) || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
                        (0x110b3 <= code && code <= 0x110b6) || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
                        (0x110b9 <= code && code <= 0x110ba) || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
                        (0x11100 <= code && code <= 0x11102) || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
                        (0x11127 <= code && code <= 0x1112b) || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
                        (0x1112d <= code && code <= 0x11134) || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
                        0x11173 == code || // Mn       MAHAJANI SIGN NUKTA
                        (0x11180 <= code && code <= 0x11181) || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
                        (0x111b6 <= code && code <= 0x111be) || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
                        (0x111ca <= code && code <= 0x111cc) || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
                        (0x1122f <= code && code <= 0x11231) || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
                        0x11234 == code || // Mn       KHOJKI SIGN ANUSVARA
                        (0x11236 <= code && code <= 0x11237) || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
                        0x1123e == code || // Mn       KHOJKI SIGN SUKUN
                        0x112df == code || // Mn       KHUDAWADI SIGN ANUSVARA
                        (0x112e3 <= code && code <= 0x112ea) || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
                        (0x11300 <= code && code <= 0x11301) || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
                        0x1133c == code || // Mn       GRANTHA SIGN NUKTA
                        0x1133e == code || // Mc       GRANTHA VOWEL SIGN AA
                        0x11340 == code || // Mn       GRANTHA VOWEL SIGN II
                        0x11357 == code || // Mc       GRANTHA AU LENGTH MARK
                        (0x11366 <= code && code <= 0x1136c) || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
                        (0x11370 <= code && code <= 0x11374) || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
                        (0x11438 <= code && code <= 0x1143f) || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
                        (0x11442 <= code && code <= 0x11444) || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
                        0x11446 == code || // Mn       NEWA SIGN NUKTA
                        0x114b0 == code || // Mc       TIRHUTA VOWEL SIGN AA
                        (0x114b3 <= code && code <= 0x114b8) || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
                        0x114ba == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
                        0x114bd == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
                        (0x114bf <= code && code <= 0x114c0) || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
                        (0x114c2 <= code && code <= 0x114c3) || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
                        0x115af == code || // Mc       SIDDHAM VOWEL SIGN AA
                        (0x115b2 <= code && code <= 0x115b5) || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
                        (0x115bc <= code && code <= 0x115bd) || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
                        (0x115bf <= code && code <= 0x115c0) || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
                        (0x115dc <= code && code <= 0x115dd) || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
                        (0x11633 <= code && code <= 0x1163a) || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
                        0x1163d == code || // Mn       MODI SIGN ANUSVARA
                        (0x1163f <= code && code <= 0x11640) || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
                        0x116ab == code || // Mn       TAKRI SIGN ANUSVARA
                        0x116ad == code || // Mn       TAKRI VOWEL SIGN AA
                        (0x116b0 <= code && code <= 0x116b5) || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
                        0x116b7 == code || // Mn       TAKRI SIGN NUKTA
                        (0x1171d <= code && code <= 0x1171f) || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
                        (0x11722 <= code && code <= 0x11725) || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
                        (0x11727 <= code && code <= 0x1172b) || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
                        (0x11a01 <= code && code <= 0x11a06) || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
                        (0x11a09 <= code && code <= 0x11a0a) || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
                        (0x11a33 <= code && code <= 0x11a38) || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
                        (0x11a3b <= code && code <= 0x11a3e) || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
                        0x11a47 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
                        (0x11a51 <= code && code <= 0x11a56) || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
                        (0x11a59 <= code && code <= 0x11a5b) || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
                        (0x11a8a <= code && code <= 0x11a96) || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
                        (0x11a98 <= code && code <= 0x11a99) || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
                        (0x11c30 <= code && code <= 0x11c36) || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
                        (0x11c38 <= code && code <= 0x11c3d) || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
                        0x11c3f == code || // Mn       BHAIKSUKI SIGN VIRAMA
                        (0x11c92 <= code && code <= 0x11ca7) || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
                        (0x11caa <= code && code <= 0x11cb0) || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
                        (0x11cb2 <= code && code <= 0x11cb3) || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
                        (0x11cb5 <= code && code <= 0x11cb6) || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
                        (0x11d31 <= code && code <= 0x11d36) || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
                        0x11d3a == code || // Mn       MASARAM GONDI VOWEL SIGN E
                        (0x11d3c <= code && code <= 0x11d3d) || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
                        (0x11d3f <= code && code <= 0x11d45) || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
                        0x11d47 == code || // Mn       MASARAM GONDI RA-KARA
                        (0x16af0 <= code && code <= 0x16af4) || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
                        (0x16b30 <= code && code <= 0x16b36) || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
                        (0x16f8f <= code && code <= 0x16f92) || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
                        (0x1bc9d <= code && code <= 0x1bc9e) || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
                        0x1d165 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
                        (0x1d167 <= code && code <= 0x1d169) || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
                        (0x1d16e <= code && code <= 0x1d172) || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
                        (0x1d17b <= code && code <= 0x1d182) || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
                        (0x1d185 <= code && code <= 0x1d18b) || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
                        (0x1d1aa <= code && code <= 0x1d1ad) || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
                        (0x1d242 <= code && code <= 0x1d244) || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
                        (0x1da00 <= code && code <= 0x1da36) || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
                        (0x1da3b <= code && code <= 0x1da6c) || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
                        0x1da75 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
                        0x1da84 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
                        (0x1da9b <= code && code <= 0x1da9f) || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
                        (0x1daa1 <= code && code <= 0x1daaf) || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
                        (0x1e000 <= code && code <= 0x1e006) || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
                        (0x1e008 <= code && code <= 0x1e018) || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
                        (0x1e01b <= code && code <= 0x1e021) || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
                        (0x1e023 <= code && code <= 0x1e024) || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
                        (0x1e026 <= code && code <= 0x1e02a) || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
                        (0x1e8d0 <= code && code <= 0x1e8d6) || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
                        (0x1e944 <= code && code <= 0x1e94a) || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
                        (0xe0020 <= code && code <= 0xe007f) || // Cf  [96] TAG SPACE..CANCEL TAG
                        (0xe0100 <= code && code <= 0xe01ef) // Mn [240] VARIATION SELECTOR-17..VARIATION SELECTOR-256
                      ) {
                        return Extend;
                      }
                      if (0x1f1e6 <= code && code <= 0x1f1ff) {
                        // So  [26] REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z
                        return Regional_Indicator;
                      }
                      if (
                        0x0903 == code || // Mc       DEVANAGARI SIGN VISARGA
                        0x093b == code || // Mc       DEVANAGARI VOWEL SIGN OOE
                        (0x093e <= code && code <= 0x0940) || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
                        (0x0949 <= code && code <= 0x094c) || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
                        (0x094e <= code && code <= 0x094f) || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
                        (0x0982 <= code && code <= 0x0983) || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
                        (0x09bf <= code && code <= 0x09c0) || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
                        (0x09c7 <= code && code <= 0x09c8) || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
                        (0x09cb <= code && code <= 0x09cc) || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
                        0x0a03 == code || // Mc       GURMUKHI SIGN VISARGA
                        (0x0a3e <= code && code <= 0x0a40) || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
                        0x0a83 == code || // Mc       GUJARATI SIGN VISARGA
                        (0x0abe <= code && code <= 0x0ac0) || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
                        0x0ac9 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
                        (0x0acb <= code && code <= 0x0acc) || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
                        (0x0b02 <= code && code <= 0x0b03) || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
                        0x0b40 == code || // Mc       ORIYA VOWEL SIGN II
                        (0x0b47 <= code && code <= 0x0b48) || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
                        (0x0b4b <= code && code <= 0x0b4c) || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
                        0x0bbf == code || // Mc       TAMIL VOWEL SIGN I
                        (0x0bc1 <= code && code <= 0x0bc2) || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
                        (0x0bc6 <= code && code <= 0x0bc8) || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
                        (0x0bca <= code && code <= 0x0bcc) || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
                        (0x0c01 <= code && code <= 0x0c03) || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
                        (0x0c41 <= code && code <= 0x0c44) || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
                        (0x0c82 <= code && code <= 0x0c83) || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
                        0x0cbe == code || // Mc       KANNADA VOWEL SIGN AA
                        (0x0cc0 <= code && code <= 0x0cc1) || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
                        (0x0cc3 <= code && code <= 0x0cc4) || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
                        (0x0cc7 <= code && code <= 0x0cc8) || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
                        (0x0cca <= code && code <= 0x0ccb) || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
                        (0x0d02 <= code && code <= 0x0d03) || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
                        (0x0d3f <= code && code <= 0x0d40) || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
                        (0x0d46 <= code && code <= 0x0d48) || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
                        (0x0d4a <= code && code <= 0x0d4c) || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
                        (0x0d82 <= code && code <= 0x0d83) || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
                        (0x0dd0 <= code && code <= 0x0dd1) || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
                        (0x0dd8 <= code && code <= 0x0dde) || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
                        (0x0df2 <= code && code <= 0x0df3) || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
                        0x0e33 == code || // Lo       THAI CHARACTER SARA AM
                        0x0eb3 == code || // Lo       LAO VOWEL SIGN AM
                        (0x0f3e <= code && code <= 0x0f3f) || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
                        0x0f7f == code || // Mc       TIBETAN SIGN RNAM BCAD
                        0x1031 == code || // Mc       MYANMAR VOWEL SIGN E
                        (0x103b <= code && code <= 0x103c) || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
                        (0x1056 <= code && code <= 0x1057) || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
                        0x1084 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
                        0x17b6 == code || // Mc       KHMER VOWEL SIGN AA
                        (0x17be <= code && code <= 0x17c5) || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
                        (0x17c7 <= code && code <= 0x17c8) || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
                        (0x1923 <= code && code <= 0x1926) || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
                        (0x1929 <= code && code <= 0x192b) || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
                        (0x1930 <= code && code <= 0x1931) || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
                        (0x1933 <= code && code <= 0x1938) || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
                        (0x1a19 <= code && code <= 0x1a1a) || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
                        0x1a55 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
                        0x1a57 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
                        (0x1a6d <= code && code <= 0x1a72) || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
                        0x1b04 == code || // Mc       BALINESE SIGN BISAH
                        0x1b35 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
                        0x1b3b == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
                        (0x1b3d <= code && code <= 0x1b41) || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
                        (0x1b43 <= code && code <= 0x1b44) || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
                        0x1b82 == code || // Mc       SUNDANESE SIGN PANGWISAD
                        0x1ba1 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
                        (0x1ba6 <= code && code <= 0x1ba7) || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
                        0x1baa == code || // Mc       SUNDANESE SIGN PAMAAEH
                        0x1be7 == code || // Mc       BATAK VOWEL SIGN E
                        (0x1bea <= code && code <= 0x1bec) || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
                        0x1bee == code || // Mc       BATAK VOWEL SIGN U
                        (0x1bf2 <= code && code <= 0x1bf3) || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
                        (0x1c24 <= code && code <= 0x1c2b) || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
                        (0x1c34 <= code && code <= 0x1c35) || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
                        0x1ce1 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
                        (0x1cf2 <= code && code <= 0x1cf3) || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
                        0x1cf7 == code || // Mc       VEDIC SIGN ATIKRAMA
                        (0xa823 <= code && code <= 0xa824) || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
                        0xa827 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
                        (0xa880 <= code && code <= 0xa881) || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
                        (0xa8b4 <= code && code <= 0xa8c3) || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
                        (0xa952 <= code && code <= 0xa953) || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
                        0xa983 == code || // Mc       JAVANESE SIGN WIGNYAN
                        (0xa9b4 <= code && code <= 0xa9b5) || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
                        (0xa9ba <= code && code <= 0xa9bb) || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
                        (0xa9bd <= code && code <= 0xa9c0) || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
                        (0xaa2f <= code && code <= 0xaa30) || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
                        (0xaa33 <= code && code <= 0xaa34) || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
                        0xaa4d == code || // Mc       CHAM CONSONANT SIGN FINAL H
                        0xaaeb == code || // Mc       MEETEI MAYEK VOWEL SIGN II
                        (0xaaee <= code && code <= 0xaaef) || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
                        0xaaf5 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
                        (0xabe3 <= code && code <= 0xabe4) || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
                        (0xabe6 <= code && code <= 0xabe7) || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
                        (0xabe9 <= code && code <= 0xabea) || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
                        0xabec == code || // Mc       MEETEI MAYEK LUM IYEK
                        0x11000 == code || // Mc       BRAHMI SIGN CANDRABINDU
                        0x11002 == code || // Mc       BRAHMI SIGN VISARGA
                        0x11082 == code || // Mc       KAITHI SIGN VISARGA
                        (0x110b0 <= code && code <= 0x110b2) || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
                        (0x110b7 <= code && code <= 0x110b8) || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
                        0x1112c == code || // Mc       CHAKMA VOWEL SIGN E
                        0x11182 == code || // Mc       SHARADA SIGN VISARGA
                        (0x111b3 <= code && code <= 0x111b5) || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
                        (0x111bf <= code && code <= 0x111c0) || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
                        (0x1122c <= code && code <= 0x1122e) || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
                        (0x11232 <= code && code <= 0x11233) || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
                        0x11235 == code || // Mc       KHOJKI SIGN VIRAMA
                        (0x112e0 <= code && code <= 0x112e2) || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
                        (0x11302 <= code && code <= 0x11303) || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
                        0x1133f == code || // Mc       GRANTHA VOWEL SIGN I
                        (0x11341 <= code && code <= 0x11344) || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
                        (0x11347 <= code && code <= 0x11348) || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
                        (0x1134b <= code && code <= 0x1134d) || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
                        (0x11362 <= code && code <= 0x11363) || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
                        (0x11435 <= code && code <= 0x11437) || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
                        (0x11440 <= code && code <= 0x11441) || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
                        0x11445 == code || // Mc       NEWA SIGN VISARGA
                        (0x114b1 <= code && code <= 0x114b2) || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
                        0x114b9 == code || // Mc       TIRHUTA VOWEL SIGN E
                        (0x114bb <= code && code <= 0x114bc) || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
                        0x114be == code || // Mc       TIRHUTA VOWEL SIGN AU
                        0x114c1 == code || // Mc       TIRHUTA SIGN VISARGA
                        (0x115b0 <= code && code <= 0x115b1) || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
                        (0x115b8 <= code && code <= 0x115bb) || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
                        0x115be == code || // Mc       SIDDHAM SIGN VISARGA
                        (0x11630 <= code && code <= 0x11632) || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
                        (0x1163b <= code && code <= 0x1163c) || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
                        0x1163e == code || // Mc       MODI SIGN VISARGA
                        0x116ac == code || // Mc       TAKRI SIGN VISARGA
                        (0x116ae <= code && code <= 0x116af) || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
                        0x116b6 == code || // Mc       TAKRI SIGN VIRAMA
                        (0x11720 <= code && code <= 0x11721) || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
                        0x11726 == code || // Mc       AHOM VOWEL SIGN E
                        (0x11a07 <= code && code <= 0x11a08) || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
                        0x11a39 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
                        (0x11a57 <= code && code <= 0x11a58) || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
                        0x11a97 == code || // Mc       SOYOMBO SIGN VISARGA
                        0x11c2f == code || // Mc       BHAIKSUKI VOWEL SIGN AA
                        0x11c3e == code || // Mc       BHAIKSUKI SIGN VISARGA
                        0x11ca9 == code || // Mc       MARCHEN SUBJOINED LETTER YA
                        0x11cb1 == code || // Mc       MARCHEN VOWEL SIGN I
                        0x11cb4 == code || // Mc       MARCHEN VOWEL SIGN O
                        (0x16f51 <= code && code <= 0x16f7e) || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
                        0x1d166 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
                        0x1d16d == code // Mc       MUSICAL SYMBOL COMBINING AUGMENTATION DOT
                      ) {
                        return SpacingMark;
                      }
                      if (
                        (0x1100 <= code && code <= 0x115f) || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
                        (0xa960 <= code && code <= 0xa97c) // Lo  [29] HANGUL CHOSEONG TIKEUT-MIEUM..HANGUL CHOSEONG SSANGYEORINHIEUH
                      ) {
                        return L;
                      }
                      if (
                        (0x1160 <= code && code <= 0x11a7) || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
                        (0xd7b0 <= code && code <= 0xd7c6) // Lo  [23] HANGUL JUNGSEONG O-YEO..HANGUL JUNGSEONG ARAEA-E
                      ) {
                        return V;
                      }
                      if (
                        (0x11a8 <= code && code <= 0x11ff) || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
                        (0xd7cb <= code && code <= 0xd7fb) // Lo  [49] HANGUL JONGSEONG NIEUN-RIEUL..HANGUL JONGSEONG PHIEUPH-THIEUTH
                      ) {
                        return T;
                      }
                      if (
                        0xac00 == code || // Lo       HANGUL SYLLABLE GA
                        0xac1c == code || // Lo       HANGUL SYLLABLE GAE
                        0xac38 == code || // Lo       HANGUL SYLLABLE GYA
                        0xac54 == code || // Lo       HANGUL SYLLABLE GYAE
                        0xac70 == code || // Lo       HANGUL SYLLABLE GEO
                        0xac8c == code || // Lo       HANGUL SYLLABLE GE
                        0xaca8 == code || // Lo       HANGUL SYLLABLE GYEO
                        0xacc4 == code || // Lo       HANGUL SYLLABLE GYE
                        0xace0 == code || // Lo       HANGUL SYLLABLE GO
                        0xacfc == code || // Lo       HANGUL SYLLABLE GWA
                        0xad18 == code || // Lo       HANGUL SYLLABLE GWAE
                        0xad34 == code || // Lo       HANGUL SYLLABLE GOE
                        0xad50 == code || // Lo       HANGUL SYLLABLE GYO
                        0xad6c == code || // Lo       HANGUL SYLLABLE GU
                        0xad88 == code || // Lo       HANGUL SYLLABLE GWEO
                        0xada4 == code || // Lo       HANGUL SYLLABLE GWE
                        0xadc0 == code || // Lo       HANGUL SYLLABLE GWI
                        0xaddc == code || // Lo       HANGUL SYLLABLE GYU
                        0xadf8 == code || // Lo       HANGUL SYLLABLE GEU
                        0xae14 == code || // Lo       HANGUL SYLLABLE GYI
                        0xae30 == code || // Lo       HANGUL SYLLABLE GI
                        0xae4c == code || // Lo       HANGUL SYLLABLE GGA
                        0xae68 == code || // Lo       HANGUL SYLLABLE GGAE
                        0xae84 == code || // Lo       HANGUL SYLLABLE GGYA
                        0xaea0 == code || // Lo       HANGUL SYLLABLE GGYAE
                        0xaebc == code || // Lo       HANGUL SYLLABLE GGEO
                        0xaed8 == code || // Lo       HANGUL SYLLABLE GGE
                        0xaef4 == code || // Lo       HANGUL SYLLABLE GGYEO
                        0xaf10 == code || // Lo       HANGUL SYLLABLE GGYE
                        0xaf2c == code || // Lo       HANGUL SYLLABLE GGO
                        0xaf48 == code || // Lo       HANGUL SYLLABLE GGWA
                        0xaf64 == code || // Lo       HANGUL SYLLABLE GGWAE
                        0xaf80 == code || // Lo       HANGUL SYLLABLE GGOE
                        0xaf9c == code || // Lo       HANGUL SYLLABLE GGYO
                        0xafb8 == code || // Lo       HANGUL SYLLABLE GGU
                        0xafd4 == code || // Lo       HANGUL SYLLABLE GGWEO
                        0xaff0 == code || // Lo       HANGUL SYLLABLE GGWE
                        0xb00c == code || // Lo       HANGUL SYLLABLE GGWI
                        0xb028 == code || // Lo       HANGUL SYLLABLE GGYU
                        0xb044 == code || // Lo       HANGUL SYLLABLE GGEU
                        0xb060 == code || // Lo       HANGUL SYLLABLE GGYI
                        0xb07c == code || // Lo       HANGUL SYLLABLE GGI
                        0xb098 == code || // Lo       HANGUL SYLLABLE NA
                        0xb0b4 == code || // Lo       HANGUL SYLLABLE NAE
                        0xb0d0 == code || // Lo       HANGUL SYLLABLE NYA
                        0xb0ec == code || // Lo       HANGUL SYLLABLE NYAE
                        0xb108 == code || // Lo       HANGUL SYLLABLE NEO
                        0xb124 == code || // Lo       HANGUL SYLLABLE NE
                        0xb140 == code || // Lo       HANGUL SYLLABLE NYEO
                        0xb15c == code || // Lo       HANGUL SYLLABLE NYE
                        0xb178 == code || // Lo       HANGUL SYLLABLE NO
                        0xb194 == code || // Lo       HANGUL SYLLABLE NWA
                        0xb1b0 == code || // Lo       HANGUL SYLLABLE NWAE
                        0xb1cc == code || // Lo       HANGUL SYLLABLE NOE
                        0xb1e8 == code || // Lo       HANGUL SYLLABLE NYO
                        0xb204 == code || // Lo       HANGUL SYLLABLE NU
                        0xb220 == code || // Lo       HANGUL SYLLABLE NWEO
                        0xb23c == code || // Lo       HANGUL SYLLABLE NWE
                        0xb258 == code || // Lo       HANGUL SYLLABLE NWI
                        0xb274 == code || // Lo       HANGUL SYLLABLE NYU
                        0xb290 == code || // Lo       HANGUL SYLLABLE NEU
                        0xb2ac == code || // Lo       HANGUL SYLLABLE NYI
                        0xb2c8 == code || // Lo       HANGUL SYLLABLE NI
                        0xb2e4 == code || // Lo       HANGUL SYLLABLE DA
                        0xb300 == code || // Lo       HANGUL SYLLABLE DAE
                        0xb31c == code || // Lo       HANGUL SYLLABLE DYA
                        0xb338 == code || // Lo       HANGUL SYLLABLE DYAE
                        0xb354 == code || // Lo       HANGUL SYLLABLE DEO
                        0xb370 == code || // Lo       HANGUL SYLLABLE DE
                        0xb38c == code || // Lo       HANGUL SYLLABLE DYEO
                        0xb3a8 == code || // Lo       HANGUL SYLLABLE DYE
                        0xb3c4 == code || // Lo       HANGUL SYLLABLE DO
                        0xb3e0 == code || // Lo       HANGUL SYLLABLE DWA
                        0xb3fc == code || // Lo       HANGUL SYLLABLE DWAE
                        0xb418 == code || // Lo       HANGUL SYLLABLE DOE
                        0xb434 == code || // Lo       HANGUL SYLLABLE DYO
                        0xb450 == code || // Lo       HANGUL SYLLABLE DU
                        0xb46c == code || // Lo       HANGUL SYLLABLE DWEO
                        0xb488 == code || // Lo       HANGUL SYLLABLE DWE
                        0xb4a4 == code || // Lo       HANGUL SYLLABLE DWI
                        0xb4c0 == code || // Lo       HANGUL SYLLABLE DYU
                        0xb4dc == code || // Lo       HANGUL SYLLABLE DEU
                        0xb4f8 == code || // Lo       HANGUL SYLLABLE DYI
                        0xb514 == code || // Lo       HANGUL SYLLABLE DI
                        0xb530 == code || // Lo       HANGUL SYLLABLE DDA
                        0xb54c == code || // Lo       HANGUL SYLLABLE DDAE
                        0xb568 == code || // Lo       HANGUL SYLLABLE DDYA
                        0xb584 == code || // Lo       HANGUL SYLLABLE DDYAE
                        0xb5a0 == code || // Lo       HANGUL SYLLABLE DDEO
                        0xb5bc == code || // Lo       HANGUL SYLLABLE DDE
                        0xb5d8 == code || // Lo       HANGUL SYLLABLE DDYEO
                        0xb5f4 == code || // Lo       HANGUL SYLLABLE DDYE
                        0xb610 == code || // Lo       HANGUL SYLLABLE DDO
                        0xb62c == code || // Lo       HANGUL SYLLABLE DDWA
                        0xb648 == code || // Lo       HANGUL SYLLABLE DDWAE
                        0xb664 == code || // Lo       HANGUL SYLLABLE DDOE
                        0xb680 == code || // Lo       HANGUL SYLLABLE DDYO
                        0xb69c == code || // Lo       HANGUL SYLLABLE DDU
                        0xb6b8 == code || // Lo       HANGUL SYLLABLE DDWEO
                        0xb6d4 == code || // Lo       HANGUL SYLLABLE DDWE
                        0xb6f0 == code || // Lo       HANGUL SYLLABLE DDWI
                        0xb70c == code || // Lo       HANGUL SYLLABLE DDYU
                        0xb728 == code || // Lo       HANGUL SYLLABLE DDEU
                        0xb744 == code || // Lo       HANGUL SYLLABLE DDYI
                        0xb760 == code || // Lo       HANGUL SYLLABLE DDI
                        0xb77c == code || // Lo       HANGUL SYLLABLE RA
                        0xb798 == code || // Lo       HANGUL SYLLABLE RAE
                        0xb7b4 == code || // Lo       HANGUL SYLLABLE RYA
                        0xb7d0 == code || // Lo       HANGUL SYLLABLE RYAE
                        0xb7ec == code || // Lo       HANGUL SYLLABLE REO
                        0xb808 == code || // Lo       HANGUL SYLLABLE RE
                        0xb824 == code || // Lo       HANGUL SYLLABLE RYEO
                        0xb840 == code || // Lo       HANGUL SYLLABLE RYE
                        0xb85c == code || // Lo       HANGUL SYLLABLE RO
                        0xb878 == code || // Lo       HANGUL SYLLABLE RWA
                        0xb894 == code || // Lo       HANGUL SYLLABLE RWAE
                        0xb8b0 == code || // Lo       HANGUL SYLLABLE ROE
                        0xb8cc == code || // Lo       HANGUL SYLLABLE RYO
                        0xb8e8 == code || // Lo       HANGUL SYLLABLE RU
                        0xb904 == code || // Lo       HANGUL SYLLABLE RWEO
                        0xb920 == code || // Lo       HANGUL SYLLABLE RWE
                        0xb93c == code || // Lo       HANGUL SYLLABLE RWI
                        0xb958 == code || // Lo       HANGUL SYLLABLE RYU
                        0xb974 == code || // Lo       HANGUL SYLLABLE REU
                        0xb990 == code || // Lo       HANGUL SYLLABLE RYI
                        0xb9ac == code || // Lo       HANGUL SYLLABLE RI
                        0xb9c8 == code || // Lo       HANGUL SYLLABLE MA
                        0xb9e4 == code || // Lo       HANGUL SYLLABLE MAE
                        0xba00 == code || // Lo       HANGUL SYLLABLE MYA
                        0xba1c == code || // Lo       HANGUL SYLLABLE MYAE
                        0xba38 == code || // Lo       HANGUL SYLLABLE MEO
                        0xba54 == code || // Lo       HANGUL SYLLABLE ME
                        0xba70 == code || // Lo       HANGUL SYLLABLE MYEO
                        0xba8c == code || // Lo       HANGUL SYLLABLE MYE
                        0xbaa8 == code || // Lo       HANGUL SYLLABLE MO
                        0xbac4 == code || // Lo       HANGUL SYLLABLE MWA
                        0xbae0 == code || // Lo       HANGUL SYLLABLE MWAE
                        0xbafc == code || // Lo       HANGUL SYLLABLE MOE
                        0xbb18 == code || // Lo       HANGUL SYLLABLE MYO
                        0xbb34 == code || // Lo       HANGUL SYLLABLE MU
                        0xbb50 == code || // Lo       HANGUL SYLLABLE MWEO
                        0xbb6c == code || // Lo       HANGUL SYLLABLE MWE
                        0xbb88 == code || // Lo       HANGUL SYLLABLE MWI
                        0xbba4 == code || // Lo       HANGUL SYLLABLE MYU
                        0xbbc0 == code || // Lo       HANGUL SYLLABLE MEU
                        0xbbdc == code || // Lo       HANGUL SYLLABLE MYI
                        0xbbf8 == code || // Lo       HANGUL SYLLABLE MI
                        0xbc14 == code || // Lo       HANGUL SYLLABLE BA
                        0xbc30 == code || // Lo       HANGUL SYLLABLE BAE
                        0xbc4c == code || // Lo       HANGUL SYLLABLE BYA
                        0xbc68 == code || // Lo       HANGUL SYLLABLE BYAE
                        0xbc84 == code || // Lo       HANGUL SYLLABLE BEO
                        0xbca0 == code || // Lo       HANGUL SYLLABLE BE
                        0xbcbc == code || // Lo       HANGUL SYLLABLE BYEO
                        0xbcd8 == code || // Lo       HANGUL SYLLABLE BYE
                        0xbcf4 == code || // Lo       HANGUL SYLLABLE BO
                        0xbd10 == code || // Lo       HANGUL SYLLABLE BWA
                        0xbd2c == code || // Lo       HANGUL SYLLABLE BWAE
                        0xbd48 == code || // Lo       HANGUL SYLLABLE BOE
                        0xbd64 == code || // Lo       HANGUL SYLLABLE BYO
                        0xbd80 == code || // Lo       HANGUL SYLLABLE BU
                        0xbd9c == code || // Lo       HANGUL SYLLABLE BWEO
                        0xbdb8 == code || // Lo       HANGUL SYLLABLE BWE
                        0xbdd4 == code || // Lo       HANGUL SYLLABLE BWI
                        0xbdf0 == code || // Lo       HANGUL SYLLABLE BYU
                        0xbe0c == code || // Lo       HANGUL SYLLABLE BEU
                        0xbe28 == code || // Lo       HANGUL SYLLABLE BYI
                        0xbe44 == code || // Lo       HANGUL SYLLABLE BI
                        0xbe60 == code || // Lo       HANGUL SYLLABLE BBA
                        0xbe7c == code || // Lo       HANGUL SYLLABLE BBAE
                        0xbe98 == code || // Lo       HANGUL SYLLABLE BBYA
                        0xbeb4 == code || // Lo       HANGUL SYLLABLE BBYAE
                        0xbed0 == code || // Lo       HANGUL SYLLABLE BBEO
                        0xbeec == code || // Lo       HANGUL SYLLABLE BBE
                        0xbf08 == code || // Lo       HANGUL SYLLABLE BBYEO
                        0xbf24 == code || // Lo       HANGUL SYLLABLE BBYE
                        0xbf40 == code || // Lo       HANGUL SYLLABLE BBO
                        0xbf5c == code || // Lo       HANGUL SYLLABLE BBWA
                        0xbf78 == code || // Lo       HANGUL SYLLABLE BBWAE
                        0xbf94 == code || // Lo       HANGUL SYLLABLE BBOE
                        0xbfb0 == code || // Lo       HANGUL SYLLABLE BBYO
                        0xbfcc == code || // Lo       HANGUL SYLLABLE BBU
                        0xbfe8 == code || // Lo       HANGUL SYLLABLE BBWEO
                        0xc004 == code || // Lo       HANGUL SYLLABLE BBWE
                        0xc020 == code || // Lo       HANGUL SYLLABLE BBWI
                        0xc03c == code || // Lo       HANGUL SYLLABLE BBYU
                        0xc058 == code || // Lo       HANGUL SYLLABLE BBEU
                        0xc074 == code || // Lo       HANGUL SYLLABLE BBYI
                        0xc090 == code || // Lo       HANGUL SYLLABLE BBI
                        0xc0ac == code || // Lo       HANGUL SYLLABLE SA
                        0xc0c8 == code || // Lo       HANGUL SYLLABLE SAE
                        0xc0e4 == code || // Lo       HANGUL SYLLABLE SYA
                        0xc100 == code || // Lo       HANGUL SYLLABLE SYAE
                        0xc11c == code || // Lo       HANGUL SYLLABLE SEO
                        0xc138 == code || // Lo       HANGUL SYLLABLE SE
                        0xc154 == code || // Lo       HANGUL SYLLABLE SYEO
                        0xc170 == code || // Lo       HANGUL SYLLABLE SYE
                        0xc18c == code || // Lo       HANGUL SYLLABLE SO
                        0xc1a8 == code || // Lo       HANGUL SYLLABLE SWA
                        0xc1c4 == code || // Lo       HANGUL SYLLABLE SWAE
                        0xc1e0 == code || // Lo       HANGUL SYLLABLE SOE
                        0xc1fc == code || // Lo       HANGUL SYLLABLE SYO
                        0xc218 == code || // Lo       HANGUL SYLLABLE SU
                        0xc234 == code || // Lo       HANGUL SYLLABLE SWEO
                        0xc250 == code || // Lo       HANGUL SYLLABLE SWE
                        0xc26c == code || // Lo       HANGUL SYLLABLE SWI
                        0xc288 == code || // Lo       HANGUL SYLLABLE SYU
                        0xc2a4 == code || // Lo       HANGUL SYLLABLE SEU
                        0xc2c0 == code || // Lo       HANGUL SYLLABLE SYI
                        0xc2dc == code || // Lo       HANGUL SYLLABLE SI
                        0xc2f8 == code || // Lo       HANGUL SYLLABLE SSA
                        0xc314 == code || // Lo       HANGUL SYLLABLE SSAE
                        0xc330 == code || // Lo       HANGUL SYLLABLE SSYA
                        0xc34c == code || // Lo       HANGUL SYLLABLE SSYAE
                        0xc368 == code || // Lo       HANGUL SYLLABLE SSEO
                        0xc384 == code || // Lo       HANGUL SYLLABLE SSE
                        0xc3a0 == code || // Lo       HANGUL SYLLABLE SSYEO
                        0xc3bc == code || // Lo       HANGUL SYLLABLE SSYE
                        0xc3d8 == code || // Lo       HANGUL SYLLABLE SSO
                        0xc3f4 == code || // Lo       HANGUL SYLLABLE SSWA
                        0xc410 == code || // Lo       HANGUL SYLLABLE SSWAE
                        0xc42c == code || // Lo       HANGUL SYLLABLE SSOE
                        0xc448 == code || // Lo       HANGUL SYLLABLE SSYO
                        0xc464 == code || // Lo       HANGUL SYLLABLE SSU
                        0xc480 == code || // Lo       HANGUL SYLLABLE SSWEO
                        0xc49c == code || // Lo       HANGUL SYLLABLE SSWE
                        0xc4b8 == code || // Lo       HANGUL SYLLABLE SSWI
                        0xc4d4 == code || // Lo       HANGUL SYLLABLE SSYU
                        0xc4f0 == code || // Lo       HANGUL SYLLABLE SSEU
                        0xc50c == code || // Lo       HANGUL SYLLABLE SSYI
                        0xc528 == code || // Lo       HANGUL SYLLABLE SSI
                        0xc544 == code || // Lo       HANGUL SYLLABLE A
                        0xc560 == code || // Lo       HANGUL SYLLABLE AE
                        0xc57c == code || // Lo       HANGUL SYLLABLE YA
                        0xc598 == code || // Lo       HANGUL SYLLABLE YAE
                        0xc5b4 == code || // Lo       HANGUL SYLLABLE EO
                        0xc5d0 == code || // Lo       HANGUL SYLLABLE E
                        0xc5ec == code || // Lo       HANGUL SYLLABLE YEO
                        0xc608 == code || // Lo       HANGUL SYLLABLE YE
                        0xc624 == code || // Lo       HANGUL SYLLABLE O
                        0xc640 == code || // Lo       HANGUL SYLLABLE WA
                        0xc65c == code || // Lo       HANGUL SYLLABLE WAE
                        0xc678 == code || // Lo       HANGUL SYLLABLE OE
                        0xc694 == code || // Lo       HANGUL SYLLABLE YO
                        0xc6b0 == code || // Lo       HANGUL SYLLABLE U
                        0xc6cc == code || // Lo       HANGUL SYLLABLE WEO
                        0xc6e8 == code || // Lo       HANGUL SYLLABLE WE
                        0xc704 == code || // Lo       HANGUL SYLLABLE WI
                        0xc720 == code || // Lo       HANGUL SYLLABLE YU
                        0xc73c == code || // Lo       HANGUL SYLLABLE EU
                        0xc758 == code || // Lo       HANGUL SYLLABLE YI
                        0xc774 == code || // Lo       HANGUL SYLLABLE I
                        0xc790 == code || // Lo       HANGUL SYLLABLE JA
                        0xc7ac == code || // Lo       HANGUL SYLLABLE JAE
                        0xc7c8 == code || // Lo       HANGUL SYLLABLE JYA
                        0xc7e4 == code || // Lo       HANGUL SYLLABLE JYAE
                        0xc800 == code || // Lo       HANGUL SYLLABLE JEO
                        0xc81c == code || // Lo       HANGUL SYLLABLE JE
                        0xc838 == code || // Lo       HANGUL SYLLABLE JYEO
                        0xc854 == code || // Lo       HANGUL SYLLABLE JYE
                        0xc870 == code || // Lo       HANGUL SYLLABLE JO
                        0xc88c == code || // Lo       HANGUL SYLLABLE JWA
                        0xc8a8 == code || // Lo       HANGUL SYLLABLE JWAE
                        0xc8c4 == code || // Lo       HANGUL SYLLABLE JOE
                        0xc8e0 == code || // Lo       HANGUL SYLLABLE JYO
                        0xc8fc == code || // Lo       HANGUL SYLLABLE JU
                        0xc918 == code || // Lo       HANGUL SYLLABLE JWEO
                        0xc934 == code || // Lo       HANGUL SYLLABLE JWE
                        0xc950 == code || // Lo       HANGUL SYLLABLE JWI
                        0xc96c == code || // Lo       HANGUL SYLLABLE JYU
                        0xc988 == code || // Lo       HANGUL SYLLABLE JEU
                        0xc9a4 == code || // Lo       HANGUL SYLLABLE JYI
                        0xc9c0 == code || // Lo       HANGUL SYLLABLE JI
                        0xc9dc == code || // Lo       HANGUL SYLLABLE JJA
                        0xc9f8 == code || // Lo       HANGUL SYLLABLE JJAE
                        0xca14 == code || // Lo       HANGUL SYLLABLE JJYA
                        0xca30 == code || // Lo       HANGUL SYLLABLE JJYAE
                        0xca4c == code || // Lo       HANGUL SYLLABLE JJEO
                        0xca68 == code || // Lo       HANGUL SYLLABLE JJE
                        0xca84 == code || // Lo       HANGUL SYLLABLE JJYEO
                        0xcaa0 == code || // Lo       HANGUL SYLLABLE JJYE
                        0xcabc == code || // Lo       HANGUL SYLLABLE JJO
                        0xcad8 == code || // Lo       HANGUL SYLLABLE JJWA
                        0xcaf4 == code || // Lo       HANGUL SYLLABLE JJWAE
                        0xcb10 == code || // Lo       HANGUL SYLLABLE JJOE
                        0xcb2c == code || // Lo       HANGUL SYLLABLE JJYO
                        0xcb48 == code || // Lo       HANGUL SYLLABLE JJU
                        0xcb64 == code || // Lo       HANGUL SYLLABLE JJWEO
                        0xcb80 == code || // Lo       HANGUL SYLLABLE JJWE
                        0xcb9c == code || // Lo       HANGUL SYLLABLE JJWI
                        0xcbb8 == code || // Lo       HANGUL SYLLABLE JJYU
                        0xcbd4 == code || // Lo       HANGUL SYLLABLE JJEU
                        0xcbf0 == code || // Lo       HANGUL SYLLABLE JJYI
                        0xcc0c == code || // Lo       HANGUL SYLLABLE JJI
                        0xcc28 == code || // Lo       HANGUL SYLLABLE CA
                        0xcc44 == code || // Lo       HANGUL SYLLABLE CAE
                        0xcc60 == code || // Lo       HANGUL SYLLABLE CYA
                        0xcc7c == code || // Lo       HANGUL SYLLABLE CYAE
                        0xcc98 == code || // Lo       HANGUL SYLLABLE CEO
                        0xccb4 == code || // Lo       HANGUL SYLLABLE CE
                        0xccd0 == code || // Lo       HANGUL SYLLABLE CYEO
                        0xccec == code || // Lo       HANGUL SYLLABLE CYE
                        0xcd08 == code || // Lo       HANGUL SYLLABLE CO
                        0xcd24 == code || // Lo       HANGUL SYLLABLE CWA
                        0xcd40 == code || // Lo       HANGUL SYLLABLE CWAE
                        0xcd5c == code || // Lo       HANGUL SYLLABLE COE
                        0xcd78 == code || // Lo       HANGUL SYLLABLE CYO
                        0xcd94 == code || // Lo       HANGUL SYLLABLE CU
                        0xcdb0 == code || // Lo       HANGUL SYLLABLE CWEO
                        0xcdcc == code || // Lo       HANGUL SYLLABLE CWE
                        0xcde8 == code || // Lo       HANGUL SYLLABLE CWI
                        0xce04 == code || // Lo       HANGUL SYLLABLE CYU
                        0xce20 == code || // Lo       HANGUL SYLLABLE CEU
                        0xce3c == code || // Lo       HANGUL SYLLABLE CYI
                        0xce58 == code || // Lo       HANGUL SYLLABLE CI
                        0xce74 == code || // Lo       HANGUL SYLLABLE KA
                        0xce90 == code || // Lo       HANGUL SYLLABLE KAE
                        0xceac == code || // Lo       HANGUL SYLLABLE KYA
                        0xcec8 == code || // Lo       HANGUL SYLLABLE KYAE
                        0xcee4 == code || // Lo       HANGUL SYLLABLE KEO
                        0xcf00 == code || // Lo       HANGUL SYLLABLE KE
                        0xcf1c == code || // Lo       HANGUL SYLLABLE KYEO
                        0xcf38 == code || // Lo       HANGUL SYLLABLE KYE
                        0xcf54 == code || // Lo       HANGUL SYLLABLE KO
                        0xcf70 == code || // Lo       HANGUL SYLLABLE KWA
                        0xcf8c == code || // Lo       HANGUL SYLLABLE KWAE
                        0xcfa8 == code || // Lo       HANGUL SYLLABLE KOE
                        0xcfc4 == code || // Lo       HANGUL SYLLABLE KYO
                        0xcfe0 == code || // Lo       HANGUL SYLLABLE KU
                        0xcffc == code || // Lo       HANGUL SYLLABLE KWEO
                        0xd018 == code || // Lo       HANGUL SYLLABLE KWE
                        0xd034 == code || // Lo       HANGUL SYLLABLE KWI
                        0xd050 == code || // Lo       HANGUL SYLLABLE KYU
                        0xd06c == code || // Lo       HANGUL SYLLABLE KEU
                        0xd088 == code || // Lo       HANGUL SYLLABLE KYI
                        0xd0a4 == code || // Lo       HANGUL SYLLABLE KI
                        0xd0c0 == code || // Lo       HANGUL SYLLABLE TA
                        0xd0dc == code || // Lo       HANGUL SYLLABLE TAE
                        0xd0f8 == code || // Lo       HANGUL SYLLABLE TYA
                        0xd114 == code || // Lo       HANGUL SYLLABLE TYAE
                        0xd130 == code || // Lo       HANGUL SYLLABLE TEO
                        0xd14c == code || // Lo       HANGUL SYLLABLE TE
                        0xd168 == code || // Lo       HANGUL SYLLABLE TYEO
                        0xd184 == code || // Lo       HANGUL SYLLABLE TYE
                        0xd1a0 == code || // Lo       HANGUL SYLLABLE TO
                        0xd1bc == code || // Lo       HANGUL SYLLABLE TWA
                        0xd1d8 == code || // Lo       HANGUL SYLLABLE TWAE
                        0xd1f4 == code || // Lo       HANGUL SYLLABLE TOE
                        0xd210 == code || // Lo       HANGUL SYLLABLE TYO
                        0xd22c == code || // Lo       HANGUL SYLLABLE TU
                        0xd248 == code || // Lo       HANGUL SYLLABLE TWEO
                        0xd264 == code || // Lo       HANGUL SYLLABLE TWE
                        0xd280 == code || // Lo       HANGUL SYLLABLE TWI
                        0xd29c == code || // Lo       HANGUL SYLLABLE TYU
                        0xd2b8 == code || // Lo       HANGUL SYLLABLE TEU
                        0xd2d4 == code || // Lo       HANGUL SYLLABLE TYI
                        0xd2f0 == code || // Lo       HANGUL SYLLABLE TI
                        0xd30c == code || // Lo       HANGUL SYLLABLE PA
                        0xd328 == code || // Lo       HANGUL SYLLABLE PAE
                        0xd344 == code || // Lo       HANGUL SYLLABLE PYA
                        0xd360 == code || // Lo       HANGUL SYLLABLE PYAE
                        0xd37c == code || // Lo       HANGUL SYLLABLE PEO
                        0xd398 == code || // Lo       HANGUL SYLLABLE PE
                        0xd3b4 == code || // Lo       HANGUL SYLLABLE PYEO
                        0xd3d0 == code || // Lo       HANGUL SYLLABLE PYE
                        0xd3ec == code || // Lo       HANGUL SYLLABLE PO
                        0xd408 == code || // Lo       HANGUL SYLLABLE PWA
                        0xd424 == code || // Lo       HANGUL SYLLABLE PWAE
                        0xd440 == code || // Lo       HANGUL SYLLABLE POE
                        0xd45c == code || // Lo       HANGUL SYLLABLE PYO
                        0xd478 == code || // Lo       HANGUL SYLLABLE PU
                        0xd494 == code || // Lo       HANGUL SYLLABLE PWEO
                        0xd4b0 == code || // Lo       HANGUL SYLLABLE PWE
                        0xd4cc == code || // Lo       HANGUL SYLLABLE PWI
                        0xd4e8 == code || // Lo       HANGUL SYLLABLE PYU
                        0xd504 == code || // Lo       HANGUL SYLLABLE PEU
                        0xd520 == code || // Lo       HANGUL SYLLABLE PYI
                        0xd53c == code || // Lo       HANGUL SYLLABLE PI
                        0xd558 == code || // Lo       HANGUL SYLLABLE HA
                        0xd574 == code || // Lo       HANGUL SYLLABLE HAE
                        0xd590 == code || // Lo       HANGUL SYLLABLE HYA
                        0xd5ac == code || // Lo       HANGUL SYLLABLE HYAE
                        0xd5c8 == code || // Lo       HANGUL SYLLABLE HEO
                        0xd5e4 == code || // Lo       HANGUL SYLLABLE HE
                        0xd600 == code || // Lo       HANGUL SYLLABLE HYEO
                        0xd61c == code || // Lo       HANGUL SYLLABLE HYE
                        0xd638 == code || // Lo       HANGUL SYLLABLE HO
                        0xd654 == code || // Lo       HANGUL SYLLABLE HWA
                        0xd670 == code || // Lo       HANGUL SYLLABLE HWAE
                        0xd68c == code || // Lo       HANGUL SYLLABLE HOE
                        0xd6a8 == code || // Lo       HANGUL SYLLABLE HYO
                        0xd6c4 == code || // Lo       HANGUL SYLLABLE HU
                        0xd6e0 == code || // Lo       HANGUL SYLLABLE HWEO
                        0xd6fc == code || // Lo       HANGUL SYLLABLE HWE
                        0xd718 == code || // Lo       HANGUL SYLLABLE HWI
                        0xd734 == code || // Lo       HANGUL SYLLABLE HYU
                        0xd750 == code || // Lo       HANGUL SYLLABLE HEU
                        0xd76c == code || // Lo       HANGUL SYLLABLE HYI
                        0xd788 == code // Lo       HANGUL SYLLABLE HI
                      ) {
                        return LV;
                      }
                      if (
                        (0xac01 <= code && code <= 0xac1b) || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
                        (0xac1d <= code && code <= 0xac37) || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
                        (0xac39 <= code && code <= 0xac53) || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
                        (0xac55 <= code && code <= 0xac6f) || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
                        (0xac71 <= code && code <= 0xac8b) || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
                        (0xac8d <= code && code <= 0xaca7) || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
                        (0xaca9 <= code && code <= 0xacc3) || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
                        (0xacc5 <= code && code <= 0xacdf) || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
                        (0xace1 <= code && code <= 0xacfb) || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
                        (0xacfd <= code && code <= 0xad17) || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
                        (0xad19 <= code && code <= 0xad33) || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
                        (0xad35 <= code && code <= 0xad4f) || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
                        (0xad51 <= code && code <= 0xad6b) || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
                        (0xad6d <= code && code <= 0xad87) || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
                        (0xad89 <= code && code <= 0xada3) || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
                        (0xada5 <= code && code <= 0xadbf) || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
                        (0xadc1 <= code && code <= 0xaddb) || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
                        (0xaddd <= code && code <= 0xadf7) || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
                        (0xadf9 <= code && code <= 0xae13) || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
                        (0xae15 <= code && code <= 0xae2f) || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
                        (0xae31 <= code && code <= 0xae4b) || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
                        (0xae4d <= code && code <= 0xae67) || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
                        (0xae69 <= code && code <= 0xae83) || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
                        (0xae85 <= code && code <= 0xae9f) || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
                        (0xaea1 <= code && code <= 0xaebb) || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
                        (0xaebd <= code && code <= 0xaed7) || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
                        (0xaed9 <= code && code <= 0xaef3) || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
                        (0xaef5 <= code && code <= 0xaf0f) || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
                        (0xaf11 <= code && code <= 0xaf2b) || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
                        (0xaf2d <= code && code <= 0xaf47) || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
                        (0xaf49 <= code && code <= 0xaf63) || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
                        (0xaf65 <= code && code <= 0xaf7f) || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
                        (0xaf81 <= code && code <= 0xaf9b) || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
                        (0xaf9d <= code && code <= 0xafb7) || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
                        (0xafb9 <= code && code <= 0xafd3) || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
                        (0xafd5 <= code && code <= 0xafef) || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
                        (0xaff1 <= code && code <= 0xb00b) || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
                        (0xb00d <= code && code <= 0xb027) || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
                        (0xb029 <= code && code <= 0xb043) || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
                        (0xb045 <= code && code <= 0xb05f) || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
                        (0xb061 <= code && code <= 0xb07b) || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
                        (0xb07d <= code && code <= 0xb097) || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
                        (0xb099 <= code && code <= 0xb0b3) || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
                        (0xb0b5 <= code && code <= 0xb0cf) || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
                        (0xb0d1 <= code && code <= 0xb0eb) || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
                        (0xb0ed <= code && code <= 0xb107) || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
                        (0xb109 <= code && code <= 0xb123) || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
                        (0xb125 <= code && code <= 0xb13f) || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
                        (0xb141 <= code && code <= 0xb15b) || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
                        (0xb15d <= code && code <= 0xb177) || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
                        (0xb179 <= code && code <= 0xb193) || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
                        (0xb195 <= code && code <= 0xb1af) || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
                        (0xb1b1 <= code && code <= 0xb1cb) || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
                        (0xb1cd <= code && code <= 0xb1e7) || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
                        (0xb1e9 <= code && code <= 0xb203) || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
                        (0xb205 <= code && code <= 0xb21f) || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
                        (0xb221 <= code && code <= 0xb23b) || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
                        (0xb23d <= code && code <= 0xb257) || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
                        (0xb259 <= code && code <= 0xb273) || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
                        (0xb275 <= code && code <= 0xb28f) || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
                        (0xb291 <= code && code <= 0xb2ab) || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
                        (0xb2ad <= code && code <= 0xb2c7) || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
                        (0xb2c9 <= code && code <= 0xb2e3) || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
                        (0xb2e5 <= code && code <= 0xb2ff) || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
                        (0xb301 <= code && code <= 0xb31b) || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
                        (0xb31d <= code && code <= 0xb337) || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
                        (0xb339 <= code && code <= 0xb353) || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
                        (0xb355 <= code && code <= 0xb36f) || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
                        (0xb371 <= code && code <= 0xb38b) || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
                        (0xb38d <= code && code <= 0xb3a7) || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
                        (0xb3a9 <= code && code <= 0xb3c3) || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
                        (0xb3c5 <= code && code <= 0xb3df) || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
                        (0xb3e1 <= code && code <= 0xb3fb) || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
                        (0xb3fd <= code && code <= 0xb417) || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
                        (0xb419 <= code && code <= 0xb433) || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
                        (0xb435 <= code && code <= 0xb44f) || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
                        (0xb451 <= code && code <= 0xb46b) || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
                        (0xb46d <= code && code <= 0xb487) || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
                        (0xb489 <= code && code <= 0xb4a3) || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
                        (0xb4a5 <= code && code <= 0xb4bf) || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
                        (0xb4c1 <= code && code <= 0xb4db) || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
                        (0xb4dd <= code && code <= 0xb4f7) || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
                        (0xb4f9 <= code && code <= 0xb513) || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
                        (0xb515 <= code && code <= 0xb52f) || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
                        (0xb531 <= code && code <= 0xb54b) || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
                        (0xb54d <= code && code <= 0xb567) || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
                        (0xb569 <= code && code <= 0xb583) || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
                        (0xb585 <= code && code <= 0xb59f) || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
                        (0xb5a1 <= code && code <= 0xb5bb) || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
                        (0xb5bd <= code && code <= 0xb5d7) || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
                        (0xb5d9 <= code && code <= 0xb5f3) || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
                        (0xb5f5 <= code && code <= 0xb60f) || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
                        (0xb611 <= code && code <= 0xb62b) || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
                        (0xb62d <= code && code <= 0xb647) || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
                        (0xb649 <= code && code <= 0xb663) || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
                        (0xb665 <= code && code <= 0xb67f) || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
                        (0xb681 <= code && code <= 0xb69b) || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
                        (0xb69d <= code && code <= 0xb6b7) || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
                        (0xb6b9 <= code && code <= 0xb6d3) || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
                        (0xb6d5 <= code && code <= 0xb6ef) || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
                        (0xb6f1 <= code && code <= 0xb70b) || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
                        (0xb70d <= code && code <= 0xb727) || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
                        (0xb729 <= code && code <= 0xb743) || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
                        (0xb745 <= code && code <= 0xb75f) || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
                        (0xb761 <= code && code <= 0xb77b) || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
                        (0xb77d <= code && code <= 0xb797) || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
                        (0xb799 <= code && code <= 0xb7b3) || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
                        (0xb7b5 <= code && code <= 0xb7cf) || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
                        (0xb7d1 <= code && code <= 0xb7eb) || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
                        (0xb7ed <= code && code <= 0xb807) || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
                        (0xb809 <= code && code <= 0xb823) || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
                        (0xb825 <= code && code <= 0xb83f) || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
                        (0xb841 <= code && code <= 0xb85b) || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
                        (0xb85d <= code && code <= 0xb877) || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
                        (0xb879 <= code && code <= 0xb893) || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
                        (0xb895 <= code && code <= 0xb8af) || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
                        (0xb8b1 <= code && code <= 0xb8cb) || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
                        (0xb8cd <= code && code <= 0xb8e7) || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
                        (0xb8e9 <= code && code <= 0xb903) || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
                        (0xb905 <= code && code <= 0xb91f) || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
                        (0xb921 <= code && code <= 0xb93b) || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
                        (0xb93d <= code && code <= 0xb957) || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
                        (0xb959 <= code && code <= 0xb973) || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
                        (0xb975 <= code && code <= 0xb98f) || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
                        (0xb991 <= code && code <= 0xb9ab) || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
                        (0xb9ad <= code && code <= 0xb9c7) || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
                        (0xb9c9 <= code && code <= 0xb9e3) || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
                        (0xb9e5 <= code && code <= 0xb9ff) || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
                        (0xba01 <= code && code <= 0xba1b) || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
                        (0xba1d <= code && code <= 0xba37) || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
                        (0xba39 <= code && code <= 0xba53) || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
                        (0xba55 <= code && code <= 0xba6f) || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
                        (0xba71 <= code && code <= 0xba8b) || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
                        (0xba8d <= code && code <= 0xbaa7) || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
                        (0xbaa9 <= code && code <= 0xbac3) || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
                        (0xbac5 <= code && code <= 0xbadf) || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
                        (0xbae1 <= code && code <= 0xbafb) || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
                        (0xbafd <= code && code <= 0xbb17) || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
                        (0xbb19 <= code && code <= 0xbb33) || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
                        (0xbb35 <= code && code <= 0xbb4f) || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
                        (0xbb51 <= code && code <= 0xbb6b) || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
                        (0xbb6d <= code && code <= 0xbb87) || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
                        (0xbb89 <= code && code <= 0xbba3) || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
                        (0xbba5 <= code && code <= 0xbbbf) || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
                        (0xbbc1 <= code && code <= 0xbbdb) || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
                        (0xbbdd <= code && code <= 0xbbf7) || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
                        (0xbbf9 <= code && code <= 0xbc13) || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
                        (0xbc15 <= code && code <= 0xbc2f) || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
                        (0xbc31 <= code && code <= 0xbc4b) || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
                        (0xbc4d <= code && code <= 0xbc67) || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
                        (0xbc69 <= code && code <= 0xbc83) || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
                        (0xbc85 <= code && code <= 0xbc9f) || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
                        (0xbca1 <= code && code <= 0xbcbb) || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
                        (0xbcbd <= code && code <= 0xbcd7) || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
                        (0xbcd9 <= code && code <= 0xbcf3) || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
                        (0xbcf5 <= code && code <= 0xbd0f) || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
                        (0xbd11 <= code && code <= 0xbd2b) || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
                        (0xbd2d <= code && code <= 0xbd47) || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
                        (0xbd49 <= code && code <= 0xbd63) || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
                        (0xbd65 <= code && code <= 0xbd7f) || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
                        (0xbd81 <= code && code <= 0xbd9b) || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
                        (0xbd9d <= code && code <= 0xbdb7) || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
                        (0xbdb9 <= code && code <= 0xbdd3) || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
                        (0xbdd5 <= code && code <= 0xbdef) || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
                        (0xbdf1 <= code && code <= 0xbe0b) || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
                        (0xbe0d <= code && code <= 0xbe27) || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
                        (0xbe29 <= code && code <= 0xbe43) || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
                        (0xbe45 <= code && code <= 0xbe5f) || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
                        (0xbe61 <= code && code <= 0xbe7b) || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
                        (0xbe7d <= code && code <= 0xbe97) || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
                        (0xbe99 <= code && code <= 0xbeb3) || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
                        (0xbeb5 <= code && code <= 0xbecf) || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
                        (0xbed1 <= code && code <= 0xbeeb) || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
                        (0xbeed <= code && code <= 0xbf07) || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
                        (0xbf09 <= code && code <= 0xbf23) || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
                        (0xbf25 <= code && code <= 0xbf3f) || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
                        (0xbf41 <= code && code <= 0xbf5b) || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
                        (0xbf5d <= code && code <= 0xbf77) || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
                        (0xbf79 <= code && code <= 0xbf93) || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
                        (0xbf95 <= code && code <= 0xbfaf) || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
                        (0xbfb1 <= code && code <= 0xbfcb) || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
                        (0xbfcd <= code && code <= 0xbfe7) || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
                        (0xbfe9 <= code && code <= 0xc003) || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
                        (0xc005 <= code && code <= 0xc01f) || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
                        (0xc021 <= code && code <= 0xc03b) || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
                        (0xc03d <= code && code <= 0xc057) || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
                        (0xc059 <= code && code <= 0xc073) || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
                        (0xc075 <= code && code <= 0xc08f) || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
                        (0xc091 <= code && code <= 0xc0ab) || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
                        (0xc0ad <= code && code <= 0xc0c7) || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
                        (0xc0c9 <= code && code <= 0xc0e3) || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
                        (0xc0e5 <= code && code <= 0xc0ff) || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
                        (0xc101 <= code && code <= 0xc11b) || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
                        (0xc11d <= code && code <= 0xc137) || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
                        (0xc139 <= code && code <= 0xc153) || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
                        (0xc155 <= code && code <= 0xc16f) || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
                        (0xc171 <= code && code <= 0xc18b) || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
                        (0xc18d <= code && code <= 0xc1a7) || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
                        (0xc1a9 <= code && code <= 0xc1c3) || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
                        (0xc1c5 <= code && code <= 0xc1df) || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
                        (0xc1e1 <= code && code <= 0xc1fb) || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
                        (0xc1fd <= code && code <= 0xc217) || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
                        (0xc219 <= code && code <= 0xc233) || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
                        (0xc235 <= code && code <= 0xc24f) || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
                        (0xc251 <= code && code <= 0xc26b) || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
                        (0xc26d <= code && code <= 0xc287) || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
                        (0xc289 <= code && code <= 0xc2a3) || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
                        (0xc2a5 <= code && code <= 0xc2bf) || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
                        (0xc2c1 <= code && code <= 0xc2db) || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
                        (0xc2dd <= code && code <= 0xc2f7) || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
                        (0xc2f9 <= code && code <= 0xc313) || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
                        (0xc315 <= code && code <= 0xc32f) || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
                        (0xc331 <= code && code <= 0xc34b) || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
                        (0xc34d <= code && code <= 0xc367) || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
                        (0xc369 <= code && code <= 0xc383) || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
                        (0xc385 <= code && code <= 0xc39f) || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
                        (0xc3a1 <= code && code <= 0xc3bb) || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
                        (0xc3bd <= code && code <= 0xc3d7) || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
                        (0xc3d9 <= code && code <= 0xc3f3) || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
                        (0xc3f5 <= code && code <= 0xc40f) || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
                        (0xc411 <= code && code <= 0xc42b) || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
                        (0xc42d <= code && code <= 0xc447) || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
                        (0xc449 <= code && code <= 0xc463) || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
                        (0xc465 <= code && code <= 0xc47f) || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
                        (0xc481 <= code && code <= 0xc49b) || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
                        (0xc49d <= code && code <= 0xc4b7) || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
                        (0xc4b9 <= code && code <= 0xc4d3) || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
                        (0xc4d5 <= code && code <= 0xc4ef) || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
                        (0xc4f1 <= code && code <= 0xc50b) || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
                        (0xc50d <= code && code <= 0xc527) || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
                        (0xc529 <= code && code <= 0xc543) || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
                        (0xc545 <= code && code <= 0xc55f) || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
                        (0xc561 <= code && code <= 0xc57b) || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
                        (0xc57d <= code && code <= 0xc597) || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
                        (0xc599 <= code && code <= 0xc5b3) || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
                        (0xc5b5 <= code && code <= 0xc5cf) || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
                        (0xc5d1 <= code && code <= 0xc5eb) || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
                        (0xc5ed <= code && code <= 0xc607) || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
                        (0xc609 <= code && code <= 0xc623) || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
                        (0xc625 <= code && code <= 0xc63f) || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
                        (0xc641 <= code && code <= 0xc65b) || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
                        (0xc65d <= code && code <= 0xc677) || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
                        (0xc679 <= code && code <= 0xc693) || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
                        (0xc695 <= code && code <= 0xc6af) || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
                        (0xc6b1 <= code && code <= 0xc6cb) || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
                        (0xc6cd <= code && code <= 0xc6e7) || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
                        (0xc6e9 <= code && code <= 0xc703) || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
                        (0xc705 <= code && code <= 0xc71f) || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
                        (0xc721 <= code && code <= 0xc73b) || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
                        (0xc73d <= code && code <= 0xc757) || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
                        (0xc759 <= code && code <= 0xc773) || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
                        (0xc775 <= code && code <= 0xc78f) || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
                        (0xc791 <= code && code <= 0xc7ab) || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
                        (0xc7ad <= code && code <= 0xc7c7) || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
                        (0xc7c9 <= code && code <= 0xc7e3) || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
                        (0xc7e5 <= code && code <= 0xc7ff) || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
                        (0xc801 <= code && code <= 0xc81b) || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
                        (0xc81d <= code && code <= 0xc837) || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
                        (0xc839 <= code && code <= 0xc853) || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
                        (0xc855 <= code && code <= 0xc86f) || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
                        (0xc871 <= code && code <= 0xc88b) || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
                        (0xc88d <= code && code <= 0xc8a7) || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
                        (0xc8a9 <= code && code <= 0xc8c3) || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
                        (0xc8c5 <= code && code <= 0xc8df) || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
                        (0xc8e1 <= code && code <= 0xc8fb) || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
                        (0xc8fd <= code && code <= 0xc917) || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
                        (0xc919 <= code && code <= 0xc933) || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
                        (0xc935 <= code && code <= 0xc94f) || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
                        (0xc951 <= code && code <= 0xc96b) || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
                        (0xc96d <= code && code <= 0xc987) || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
                        (0xc989 <= code && code <= 0xc9a3) || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
                        (0xc9a5 <= code && code <= 0xc9bf) || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
                        (0xc9c1 <= code && code <= 0xc9db) || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
                        (0xc9dd <= code && code <= 0xc9f7) || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
                        (0xc9f9 <= code && code <= 0xca13) || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
                        (0xca15 <= code && code <= 0xca2f) || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
                        (0xca31 <= code && code <= 0xca4b) || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
                        (0xca4d <= code && code <= 0xca67) || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
                        (0xca69 <= code && code <= 0xca83) || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
                        (0xca85 <= code && code <= 0xca9f) || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
                        (0xcaa1 <= code && code <= 0xcabb) || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
                        (0xcabd <= code && code <= 0xcad7) || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
                        (0xcad9 <= code && code <= 0xcaf3) || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
                        (0xcaf5 <= code && code <= 0xcb0f) || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
                        (0xcb11 <= code && code <= 0xcb2b) || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
                        (0xcb2d <= code && code <= 0xcb47) || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
                        (0xcb49 <= code && code <= 0xcb63) || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
                        (0xcb65 <= code && code <= 0xcb7f) || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
                        (0xcb81 <= code && code <= 0xcb9b) || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
                        (0xcb9d <= code && code <= 0xcbb7) || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
                        (0xcbb9 <= code && code <= 0xcbd3) || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
                        (0xcbd5 <= code && code <= 0xcbef) || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
                        (0xcbf1 <= code && code <= 0xcc0b) || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
                        (0xcc0d <= code && code <= 0xcc27) || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
                        (0xcc29 <= code && code <= 0xcc43) || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
                        (0xcc45 <= code && code <= 0xcc5f) || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
                        (0xcc61 <= code && code <= 0xcc7b) || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
                        (0xcc7d <= code && code <= 0xcc97) || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
                        (0xcc99 <= code && code <= 0xccb3) || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
                        (0xccb5 <= code && code <= 0xcccf) || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
                        (0xccd1 <= code && code <= 0xcceb) || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
                        (0xcced <= code && code <= 0xcd07) || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
                        (0xcd09 <= code && code <= 0xcd23) || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
                        (0xcd25 <= code && code <= 0xcd3f) || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
                        (0xcd41 <= code && code <= 0xcd5b) || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
                        (0xcd5d <= code && code <= 0xcd77) || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
                        (0xcd79 <= code && code <= 0xcd93) || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
                        (0xcd95 <= code && code <= 0xcdaf) || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
                        (0xcdb1 <= code && code <= 0xcdcb) || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
                        (0xcdcd <= code && code <= 0xcde7) || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
                        (0xcde9 <= code && code <= 0xce03) || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
                        (0xce05 <= code && code <= 0xce1f) || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
                        (0xce21 <= code && code <= 0xce3b) || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
                        (0xce3d <= code && code <= 0xce57) || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
                        (0xce59 <= code && code <= 0xce73) || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
                        (0xce75 <= code && code <= 0xce8f) || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
                        (0xce91 <= code && code <= 0xceab) || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
                        (0xcead <= code && code <= 0xcec7) || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
                        (0xcec9 <= code && code <= 0xcee3) || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
                        (0xcee5 <= code && code <= 0xceff) || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
                        (0xcf01 <= code && code <= 0xcf1b) || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
                        (0xcf1d <= code && code <= 0xcf37) || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
                        (0xcf39 <= code && code <= 0xcf53) || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
                        (0xcf55 <= code && code <= 0xcf6f) || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
                        (0xcf71 <= code && code <= 0xcf8b) || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
                        (0xcf8d <= code && code <= 0xcfa7) || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
                        (0xcfa9 <= code && code <= 0xcfc3) || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
                        (0xcfc5 <= code && code <= 0xcfdf) || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
                        (0xcfe1 <= code && code <= 0xcffb) || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
                        (0xcffd <= code && code <= 0xd017) || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
                        (0xd019 <= code && code <= 0xd033) || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
                        (0xd035 <= code && code <= 0xd04f) || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
                        (0xd051 <= code && code <= 0xd06b) || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
                        (0xd06d <= code && code <= 0xd087) || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
                        (0xd089 <= code && code <= 0xd0a3) || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
                        (0xd0a5 <= code && code <= 0xd0bf) || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
                        (0xd0c1 <= code && code <= 0xd0db) || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
                        (0xd0dd <= code && code <= 0xd0f7) || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
                        (0xd0f9 <= code && code <= 0xd113) || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
                        (0xd115 <= code && code <= 0xd12f) || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
                        (0xd131 <= code && code <= 0xd14b) || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
                        (0xd14d <= code && code <= 0xd167) || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
                        (0xd169 <= code && code <= 0xd183) || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
                        (0xd185 <= code && code <= 0xd19f) || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
                        (0xd1a1 <= code && code <= 0xd1bb) || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
                        (0xd1bd <= code && code <= 0xd1d7) || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
                        (0xd1d9 <= code && code <= 0xd1f3) || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
                        (0xd1f5 <= code && code <= 0xd20f) || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
                        (0xd211 <= code && code <= 0xd22b) || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
                        (0xd22d <= code && code <= 0xd247) || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
                        (0xd249 <= code && code <= 0xd263) || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
                        (0xd265 <= code && code <= 0xd27f) || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
                        (0xd281 <= code && code <= 0xd29b) || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
                        (0xd29d <= code && code <= 0xd2b7) || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
                        (0xd2b9 <= code && code <= 0xd2d3) || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
                        (0xd2d5 <= code && code <= 0xd2ef) || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
                        (0xd2f1 <= code && code <= 0xd30b) || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
                        (0xd30d <= code && code <= 0xd327) || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
                        (0xd329 <= code && code <= 0xd343) || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
                        (0xd345 <= code && code <= 0xd35f) || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
                        (0xd361 <= code && code <= 0xd37b) || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
                        (0xd37d <= code && code <= 0xd397) || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
                        (0xd399 <= code && code <= 0xd3b3) || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
                        (0xd3b5 <= code && code <= 0xd3cf) || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
                        (0xd3d1 <= code && code <= 0xd3eb) || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
                        (0xd3ed <= code && code <= 0xd407) || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
                        (0xd409 <= code && code <= 0xd423) || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
                        (0xd425 <= code && code <= 0xd43f) || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
                        (0xd441 <= code && code <= 0xd45b) || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
                        (0xd45d <= code && code <= 0xd477) || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
                        (0xd479 <= code && code <= 0xd493) || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
                        (0xd495 <= code && code <= 0xd4af) || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
                        (0xd4b1 <= code && code <= 0xd4cb) || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
                        (0xd4cd <= code && code <= 0xd4e7) || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
                        (0xd4e9 <= code && code <= 0xd503) || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
                        (0xd505 <= code && code <= 0xd51f) || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
                        (0xd521 <= code && code <= 0xd53b) || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
                        (0xd53d <= code && code <= 0xd557) || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
                        (0xd559 <= code && code <= 0xd573) || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
                        (0xd575 <= code && code <= 0xd58f) || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
                        (0xd591 <= code && code <= 0xd5ab) || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
                        (0xd5ad <= code && code <= 0xd5c7) || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
                        (0xd5c9 <= code && code <= 0xd5e3) || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
                        (0xd5e5 <= code && code <= 0xd5ff) || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
                        (0xd601 <= code && code <= 0xd61b) || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
                        (0xd61d <= code && code <= 0xd637) || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
                        (0xd639 <= code && code <= 0xd653) || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
                        (0xd655 <= code && code <= 0xd66f) || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
                        (0xd671 <= code && code <= 0xd68b) || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
                        (0xd68d <= code && code <= 0xd6a7) || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
                        (0xd6a9 <= code && code <= 0xd6c3) || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
                        (0xd6c5 <= code && code <= 0xd6df) || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
                        (0xd6e1 <= code && code <= 0xd6fb) || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
                        (0xd6fd <= code && code <= 0xd717) || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
                        (0xd719 <= code && code <= 0xd733) || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
                        (0xd735 <= code && code <= 0xd74f) || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
                        (0xd751 <= code && code <= 0xd76b) || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
                        (0xd76d <= code && code <= 0xd787) || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
                        (0xd789 <= code && code <= 0xd7a3) // Lo  [27] HANGUL SYLLABLE HIG..HANGUL SYLLABLE HIH
                      ) {
                        return LVT;
                      }
                      if (
                        0x261d == code || // So       WHITE UP POINTING INDEX
                        0x26f9 == code || // So       PERSON WITH BALL
                        (0x270a <= code && code <= 0x270d) || // So   [4] RAISED FIST..WRITING HAND
                        0x1f385 == code || // So       FATHER CHRISTMAS
                        (0x1f3c2 <= code && code <= 0x1f3c4) || // So   [3] SNOWBOARDER..SURFER
                        0x1f3c7 == code || // So       HORSE RACING
                        (0x1f3ca <= code && code <= 0x1f3cc) || // So   [3] SWIMMER..GOLFER
                        (0x1f442 <= code && code <= 0x1f443) || // So   [2] EAR..NOSE
                        (0x1f446 <= code && code <= 0x1f450) || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
                        0x1f46e == code || // So       POLICE OFFICER
                        (0x1f470 <= code && code <= 0x1f478) || // So   [9] BRIDE WITH VEIL..PRINCESS
                        0x1f47c == code || // So       BABY ANGEL
                        (0x1f481 <= code && code <= 0x1f483) || // So   [3] INFORMATION DESK PERSON..DANCER
                        (0x1f485 <= code && code <= 0x1f487) || // So   [3] NAIL POLISH..HAIRCUT
                        0x1f4aa == code || // So       FLEXED BICEPS
                        (0x1f574 <= code && code <= 0x1f575) || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
                        0x1f57a == code || // So       MAN DANCING
                        0x1f590 == code || // So       RAISED HAND WITH FINGERS SPLAYED
                        (0x1f595 <= code && code <= 0x1f596) || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
                        (0x1f645 <= code && code <= 0x1f647) || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
                        (0x1f64b <= code && code <= 0x1f64f) || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
                        0x1f6a3 == code || // So       ROWBOAT
                        (0x1f6b4 <= code && code <= 0x1f6b6) || // So   [3] BICYCLIST..PEDESTRIAN
                        0x1f6c0 == code || // So       BATH
                        0x1f6cc == code || // So       SLEEPING ACCOMMODATION
                        (0x1f918 <= code && code <= 0x1f91c) || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
                        (0x1f91e <= code && code <= 0x1f91f) || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
                        0x1f926 == code || // So       FACE PALM
                        (0x1f930 <= code && code <= 0x1f939) || // So  [10] PREGNANT WOMAN..JUGGLING
                        (0x1f93d <= code && code <= 0x1f93e) || // So   [2] WATER POLO..HANDBALL
                        (0x1f9d1 <= code && code <= 0x1f9dd) // So  [13] ADULT..ELF
                      ) {
                        return E_Base;
                      }
                      if (0x1f3fb <= code && code <= 0x1f3ff) {
                        // Sk   [5] EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6
                        return E_Modifier;
                      }
                      if (
                        0x200d == code // Cf       ZERO WIDTH JOINER
                      ) {
                        return ZWJ;
                      }
                      if (
                        0x2640 == code || // So       FEMALE SIGN
                        0x2642 == code || // So       MALE SIGN
                        (0x2695 <= code && code <= 0x2696) || // So   [2] STAFF OF AESCULAPIUS..SCALES
                        0x2708 == code || // So       AIRPLANE
                        0x2764 == code || // So       HEAVY BLACK HEART
                        0x1f308 == code || // So       RAINBOW
                        0x1f33e == code || // So       EAR OF RICE
                        0x1f373 == code || // So       COOKING
                        0x1f393 == code || // So       GRADUATION CAP
                        0x1f3a4 == code || // So       MICROPHONE
                        0x1f3a8 == code || // So       ARTIST PALETTE
                        0x1f3eb == code || // So       SCHOOL
                        0x1f3ed == code || // So       FACTORY
                        0x1f48b == code || // So       KISS MARK
                        (0x1f4bb <= code && code <= 0x1f4bc) || // So   [2] PERSONAL COMPUTER..BRIEFCASE
                        0x1f527 == code || // So       WRENCH
                        0x1f52c == code || // So       MICROSCOPE
                        0x1f5e8 == code || // So       LEFT SPEECH BUBBLE
                        0x1f680 == code || // So       ROCKET
                        0x1f692 == code // So       FIRE ENGINE
                      ) {
                        return Glue_After_Zwj;
                      }
                      if (0x1f466 <= code && code <= 0x1f469) {
                        // So   [4] BOY..WOMAN
                        return E_Base_GAZ;
                      } //all unlisted characters have a grapheme break property of "Other"
                      return Other;
                    }
                    return this;
                  }
                  if ("object" != "undefined" && module.exports) {
                    module.exports = GraphemeSplitter;
                  }
                });
                var splitter = new graphemeSplitter();
                var substring = function substring(str, start, end) {
                  var iterator = splitter.iterateGraphemes(str.substring(start));
                  var value = "";
                  for (var pos = 0; pos < end - start; pos++) {
                    var next = iterator.next();
                    value += next.value;
                    if (next.done) {
                      break;
                    }
                  }
                  return value;
                };
                var location = function location(
                  startLine,
                  startColumn,
                  startOffset,
                  endLine,
                  endColumn,
                  endOffset,
                  source
                ) {
                  return {
                    start: {
                      line: startLine,
                      column: startColumn,
                      offset: startOffset
                    },
                    end: { line: endLine, column: endColumn, offset: endOffset },
                    source: source || null
                  };
                };
                var build = createCommonjsModule(function (module, exports) {
                  (function (global, factory) {
                    module.exports = factory();
                  })(commonjsGlobal, function () {
                    "use strict";
                    /*!
                     * repeat-string <https://github.com/jonschlinkert/repeat-string>
                     *
                     * Copyright (c) 2014-2015, Jon Schlinkert.
                     * Licensed under the MIT License.
                     */ "use strict";
                    /**
                     * Results cache
                     */ var res = "";
                    var cache;
                    /**
                     * Expose `repeat`
                     */ var repeatString = repeat;
                    /**
                     * Repeat the given `string` the specified `number`
                     * of times.
                     *
                     * **Example:**
                     *
                     * ```js
                     * var repeat = require('repeat-string');
                     * repeat('A', 5);
                     * //=> AAAAA
                     * ```
                     *
                     * @param {String} `string` The string to repeat
                     * @param {Number} `number` The number of times to repeat the string
                     * @return {String} Repeated string
                     * @api public
                     */ function repeat(str, num) {
                      if (typeof str !== "string") {
                        throw new TypeError("expected a string");
                      } // cover common, quick use cases
                      if (num === 1) return str;
                      if (num === 2) return str + str;
                      var max = str.length * num;
                      if (cache !== str || typeof cache === "undefined") {
                        cache = str;
                        res = "";
                      } else if (res.length >= max) {
                        return res.substr(0, max);
                      }
                      while (max > res.length && num > 1) {
                        if (num & 1) {
                          res += str;
                        }
                        num >>= 1;
                        str += str;
                      }
                      res += str;
                      res = res.substr(0, max);
                      return res;
                    }
                    ("use strict");
                    var padStart = function padStart(
                      string,
                      maxLength,
                      fillString
                    ) {
                      if (string == null || maxLength == null) {
                        return string;
                      }
                      var result = String(string);
                      var targetLen =
                        typeof maxLength === "number"
                          ? maxLength
                          : parseInt(maxLength, 10);
                      if (isNaN(targetLen) || !isFinite(targetLen)) {
                        return result;
                      }
                      var length = result.length;
                      if (length >= targetLen) {
                        return result;
                      }
                      var fill = fillString == null ? "" : String(fillString);
                      if (fill === "") {
                        fill = " ";
                      }
                      var fillLen = targetLen - length;
                      while (fill.length < fillLen) {
                        fill += fill;
                      }
                      var truncated =
                        fill.length > fillLen ? fill.substr(0, fillLen) : fill;
                      return truncated + result;
                    };
                    var _extends =
                      Object.assign ||
                      function (target) {
                        for (var i = 1; i < arguments.length; i++) {
                          var source = arguments[i];
                          for (var key in source) {
                            if (
                              Object.prototype.hasOwnProperty.call(source, key)
                            ) {
                              target[key] = source[key];
                            }
                          }
                        }
                        return target;
                      };
                    function printLine(line, position, maxNumLength, settings) {
                      var num = String(position);
                      var formattedNum = padStart(num, maxNumLength, " ");
                      var tabReplacement = repeatString(" ", settings.tabSize);
                      return (
                        formattedNum + " | " + line.replace(/\t/g, tabReplacement)
                      );
                    }
                    function printLines(
                      lines,
                      start,
                      end,
                      maxNumLength,
                      settings
                    ) {
                      return lines
                        .slice(start, end)
                        .map(function (line, i) {
                          return printLine(
                            line,
                            start + i + 1,
                            maxNumLength,
                            settings
                          );
                        })
                        .join("\n");
                    }
                    var defaultSettings = { extraLines: 2, tabSize: 4 };
                    var index = function index(
                      input,
                      linePos,
                      columnPos,
                      settings
                    ) {
                      settings = _extends({}, defaultSettings, settings);
                      var lines = input.split(/\r\n?|\n|\f/);
                      var startLinePos =
                        Math.max(1, linePos - settings.extraLines) - 1;
                      var endLinePos = Math.min(
                        linePos + settings.extraLines,
                        lines.length
                      );
                      var maxNumLength = String(endLinePos).length;
                      var prevLines = printLines(
                        lines,
                        startLinePos,
                        linePos,
                        maxNumLength,
                        settings
                      );
                      var targetLineBeforeCursor = printLine(
                        lines[linePos - 1].substring(0, columnPos - 1),
                        linePos,
                        maxNumLength,
                        settings
                      );
                      var cursorLine =
                        repeatString(" ", targetLineBeforeCursor.length) + "^";
                      var nextLines = printLines(
                        lines,
                        linePos,
                        endLinePos,
                        maxNumLength,
                        settings
                      );
                      return [prevLines, cursorLine, nextLines]
                        .filter(Boolean)
                        .join("\n");
                    };
                    return index;
                  });
                });
                var errorStack = new Error().stack;
                var createError = function createError(props) {
                  // use Object.create(), because some VMs prevent setting line/column otherwise
                  // (iOS Safari 10 even throws an exception)
                  var error = Object.create(SyntaxError.prototype);
                  Object.assign(error, props, { name: "SyntaxError" });
                  Object.defineProperty(error, "stack", {
                    get: function get() {
                      return errorStack
                        ? errorStack.replace(/^(.+\n){1,3}/, String(error) + "\n")
                        : "";
                    }
                  });
                  return error;
                };
                var error = function error(message, input, source, line, column) {
                  throw createError({
                    message: line
                      ? message + "\n" + build(input, line, column)
                      : message,
                    rawMessage: message,
                    source: source,
                    line: line,
                    column: column
                  });
                };
                var parseErrorTypes = {
                  unexpectedEnd: function unexpectedEnd() {
                    return "Unexpected end of input";
                  },
                  unexpectedToken: function unexpectedToken(token) {
                    for (
                      var _len = arguments.length,
                        position = Array(_len > 1 ? _len - 1 : 0),
                        _key = 1;
                      _key < _len;
                      _key++
                    ) {
                      position[_key - 1] = arguments[_key];
                    }
                    return (
                      "Unexpected token <" +
                      token +
                      "> at " +
                      position.filter(Boolean).join(":")
                    );
                  }
                };
                var tokenizeErrorTypes = {
                  unexpectedSymbol: function unexpectedSymbol(symbol) {
                    for (
                      var _len = arguments.length,
                        position = Array(_len > 1 ? _len - 1 : 0),
                        _key = 1;
                      _key < _len;
                      _key++
                    ) {
                      position[_key - 1] = arguments[_key];
                    }
                    return (
                      "Unexpected symbol <" +
                      symbol +
                      "> at " +
                      position.filter(Boolean).join(":")
                    );
                  }
                };
                var tokenTypes = {
                  LEFT_BRACE: 0, // {
                  RIGHT_BRACE: 1, // }
                  LEFT_BRACKET: 2, // [
                  RIGHT_BRACKET: 3, // ]
                  COLON: 4, // :
                  COMMA: 5, // ,
                  STRING: 6, //
                  NUMBER: 7, //
                  TRUE: 8, // true
                  FALSE: 9, // false
                  NULL: 10 // null
                };
                var punctuatorTokensMap = {
                  // Lexeme: Token
                  "{": tokenTypes.LEFT_BRACE,
                  "}": tokenTypes.RIGHT_BRACE,
                  "[": tokenTypes.LEFT_BRACKET,
                  "]": tokenTypes.RIGHT_BRACKET,
                  ":": tokenTypes.COLON,
                  ",": tokenTypes.COMMA
                };
                var keywordTokensMap = {
                  // Lexeme: Token
                  true: tokenTypes.TRUE,
                  false: tokenTypes.FALSE,
                  null: tokenTypes.NULL
                };
                var stringStates = {
                  _START_: 0,
                  START_QUOTE_OR_CHAR: 1,
                  ESCAPE: 2
                };
                var escapes$1 = {
                  '"': 0, // Quotation mask
                  "\\": 1, // Reverse solidus
                  "/": 2, // Solidus
                  b: 3, // Backspace
                  f: 4, // Form feed
                  n: 5, // New line
                  r: 6, // Carriage return
                  t: 7, // Horizontal tab
                  u: 8 // 4 hexadecimal digits
                };
                var numberStates = {
                  _START_: 0,
                  MINUS: 1,
                  ZERO: 2,
                  DIGIT: 3,
                  POINT: 4,
                  DIGIT_FRACTION: 5,
                  EXP: 6,
                  EXP_DIGIT_OR_SIGN: 7
                }; // HELPERS
                function isDigit1to9(_char5) {
                  return _char5 >= "1" && _char5 <= "9";
                }
                function isDigit(_char6) {
                  return _char6 >= "0" && _char6 <= "9";
                }
                function isHex(_char7) {
                  return (
                    isDigit(_char7) ||
                    (_char7 >= "a" && _char7 <= "f") ||
                    (_char7 >= "A" && _char7 <= "F")
                  );
                }
                function isExp(_char8) {
                  return _char8 === "e" || _char8 === "E";
                } // PARSERS
                function parseWhitespace(input, index, line, column) {
                  var _char9 = input.charAt(index);
                  if (_char9 === "\r") {
                    // CR (Unix)
                    index++;
                    line++;
                    column = 1;
                    if (input.charAt(index) === "\n") {
                      // CRLF (Windows)
                      index++;
                    }
                  } else if (_char9 === "\n") {
                    // LF (MacOS)
                    index++;
                    line++;
                    column = 1;
                  } else if (_char9 === "\t" || _char9 === " ") {
                    index++;
                    column++;
                  } else {
                    return null;
                  }
                  return { index: index, line: line, column: column };
                }
                function parseChar(input, index, line, column) {
                  var _char10 = input.charAt(index);
                  if (_char10 in punctuatorTokensMap) {
                    return {
                      type: punctuatorTokensMap[_char10],
                      line: line,
                      column: column + 1,
                      index: index + 1,
                      value: null
                    };
                  }
                  return null;
                }
                function parseKeyword(input, index, line, column) {
                  for (var name in keywordTokensMap) {
                    if (
                      keywordTokensMap.hasOwnProperty(name) &&
                      input.substr(index, name.length) === name
                    ) {
                      return {
                        type: keywordTokensMap[name],
                        line: line,
                        column: column + name.length,
                        index: index + name.length,
                        value: name
                      };
                    }
                  }
                  return null;
                }
                function parseString$1(input, index, line, column) {
                  var startIndex = index;
                  var state = stringStates._START_;
                  while (index < input.length) {
                    var _char11 = input.charAt(index);
                    switch (state) {
                      case stringStates._START_: {
                        if (_char11 === '"') {
                          index++;
                          state = stringStates.START_QUOTE_OR_CHAR;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case stringStates.START_QUOTE_OR_CHAR: {
                        if (_char11 === "\\") {
                          index++;
                          state = stringStates.ESCAPE;
                        } else if (_char11 === '"') {
                          index++;
                          return {
                            type: tokenTypes.STRING,
                            line: line,
                            column: column + index - startIndex,
                            index: index,
                            value: input.slice(startIndex, index)
                          };
                        } else {
                          index++;
                        }
                        break;
                      }
                      case stringStates.ESCAPE: {
                        if (_char11 in escapes$1) {
                          index++;
                          if (_char11 === "u") {
                            for (var i = 0; i < 4; i++) {
                              var curChar = input.charAt(index);
                              if (curChar && isHex(curChar)) {
                                index++;
                              } else {
                                return null;
                              }
                            }
                          }
                          state = stringStates.START_QUOTE_OR_CHAR;
                        } else {
                          return null;
                        }
                        break;
                      }
                    }
                  }
                }
                function parseNumber(input, index, line, column) {
                  var startIndex = index;
                  var passedValueIndex = index;
                  var state = numberStates._START_;
                  iterator: while (index < input.length) {
                    var _char12 = input.charAt(index);
                    switch (state) {
                      case numberStates._START_: {
                        if (_char12 === "-") {
                          state = numberStates.MINUS;
                        } else if (_char12 === "0") {
                          passedValueIndex = index + 1;
                          state = numberStates.ZERO;
                        } else if (isDigit1to9(_char12)) {
                          passedValueIndex = index + 1;
                          state = numberStates.DIGIT;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case numberStates.MINUS: {
                        if (_char12 === "0") {
                          passedValueIndex = index + 1;
                          state = numberStates.ZERO;
                        } else if (isDigit1to9(_char12)) {
                          passedValueIndex = index + 1;
                          state = numberStates.DIGIT;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case numberStates.ZERO: {
                        if (_char12 === ".") {
                          state = numberStates.POINT;
                        } else if (isExp(_char12)) {
                          state = numberStates.EXP;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                      case numberStates.DIGIT: {
                        if (isDigit(_char12)) {
                          passedValueIndex = index + 1;
                        } else if (_char12 === ".") {
                          state = numberStates.POINT;
                        } else if (isExp(_char12)) {
                          state = numberStates.EXP;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                      case numberStates.POINT: {
                        if (isDigit(_char12)) {
                          passedValueIndex = index + 1;
                          state = numberStates.DIGIT_FRACTION;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                      case numberStates.DIGIT_FRACTION: {
                        if (isDigit(_char12)) {
                          passedValueIndex = index + 1;
                        } else if (isExp(_char12)) {
                          state = numberStates.EXP;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                      case numberStates.EXP: {
                        if (_char12 === "+" || _char12 === "-") {
                          state = numberStates.EXP_DIGIT_OR_SIGN;
                        } else if (isDigit(_char12)) {
                          passedValueIndex = index + 1;
                          state = numberStates.EXP_DIGIT_OR_SIGN;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                      case numberStates.EXP_DIGIT_OR_SIGN: {
                        if (isDigit(_char12)) {
                          passedValueIndex = index + 1;
                        } else {
                          break iterator;
                        }
                        break;
                      }
                    }
                    index++;
                  }
                  if (passedValueIndex > 0) {
                    return {
                      type: tokenTypes.NUMBER,
                      line: line,
                      column: column + passedValueIndex - startIndex,
                      index: passedValueIndex,
                      value: input.slice(startIndex, passedValueIndex)
                    };
                  }
                  return null;
                }
                var tokenize = function tokenize(input, settings) {
                  var line = 1;
                  var column = 1;
                  var index = 0;
                  var tokens = [];
                  while (index < input.length) {
                    var args = [input, index, line, column];
                    var whitespace = parseWhitespace.apply(undefined, args);
                    if (whitespace) {
                      index = whitespace.index;
                      line = whitespace.line;
                      column = whitespace.column;
                      continue;
                    }
                    var matched =
                      parseChar.apply(undefined, args) ||
                      parseKeyword.apply(undefined, args) ||
                      parseString$1.apply(undefined, args) ||
                      parseNumber.apply(undefined, args);
                    if (matched) {
                      var token = {
                        type: matched.type,
                        value: matched.value,
                        loc: location(
                          line,
                          column,
                          index,
                          matched.line,
                          matched.column,
                          matched.index,
                          settings.source
                        )
                      };
                      tokens.push(token);
                      index = matched.index;
                      line = matched.line;
                      column = matched.column;
                    } else {
                      error(
                        tokenizeErrorTypes.unexpectedSymbol(
                          substring(input, index, index + 1),
                          settings.source,
                          line,
                          column
                        ),
                        input,
                        settings.source,
                        line,
                        column
                      );
                    }
                  }
                  return tokens;
                };
                var objectStates = {
                  _START_: 0,
                  OPEN_OBJECT: 1,
                  PROPERTY: 2,
                  COMMA: 3
                };
                var propertyStates = { _START_: 0, KEY: 1, COLON: 2 };
                var arrayStates = {
                  _START_: 0,
                  OPEN_ARRAY: 1,
                  VALUE: 2,
                  COMMA: 3
                };
                var defaultSettings = { loc: true, source: null };
                function errorEof(input, tokenList, settings) {
                  var loc =
                    tokenList.length > 0
                      ? tokenList[tokenList.length - 1].loc.end
                      : { line: 1, column: 1 };
                  error(
                    parseErrorTypes.unexpectedEnd(),
                    input,
                    settings.source,
                    loc.line,
                    loc.column
                  );
                }
                /** @param hexCode {string} hexCode without '\u' prefix */ function parseHexEscape(
                  hexCode
                ) {
                  var charCode = 0;
                  for (var i = 0; i < 4; i++) {
                    charCode = charCode * 16 + parseInt(hexCode[i], 16);
                  }
                  return String.fromCharCode(charCode);
                }
                var escapes = {
                  b: "\b", // Backspace
                  f: "\f", // Form feed
                  n: "\n", // New line
                  r: "\r", // Carriage return
                  t: "\t" // Horizontal tab
                };
                var passEscapes = ['"', "\\", "/"];
                function parseString(/** string */ string) {
                  var result = "";
                  for (var i = 0; i < string.length; i++) {
                    var _char13 = string.charAt(i);
                    if (_char13 === "\\") {
                      i++;
                      var nextChar = string.charAt(i);
                      if (nextChar === "u") {
                        result += parseHexEscape(string.substr(i + 1, 4));
                        i += 4;
                      } else if (passEscapes.indexOf(nextChar) !== -1) {
                        result += nextChar;
                      } else if (nextChar in escapes) {
                        result += escapes[nextChar];
                      } else {
                        break;
                      }
                    } else {
                      result += _char13;
                    }
                  }
                  return result;
                }
                function parseObject(input, tokenList, index, settings) {
                  // object: LEFT_BRACE (property (COMMA property)*)? RIGHT_BRACE
                  var startToken = void 0;
                  var object = { type: "Object", children: [] };
                  var state = objectStates._START_;
                  while (index < tokenList.length) {
                    var token = tokenList[index];
                    switch (state) {
                      case objectStates._START_: {
                        if (token.type === tokenTypes.LEFT_BRACE) {
                          startToken = token;
                          state = objectStates.OPEN_OBJECT;
                          index++;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case objectStates.OPEN_OBJECT: {
                        if (token.type === tokenTypes.RIGHT_BRACE) {
                          if (settings.loc) {
                            object.loc = location(
                              startToken.loc.start.line,
                              startToken.loc.start.column,
                              startToken.loc.start.offset,
                              token.loc.end.line,
                              token.loc.end.column,
                              token.loc.end.offset,
                              settings.source
                            );
                          }
                          return { value: object, index: index + 1 };
                        } else {
                          var property = parseProperty(
                            input,
                            tokenList,
                            index,
                            settings
                          );
                          object.children.push(property.value);
                          state = objectStates.PROPERTY;
                          index = property.index;
                        }
                        break;
                      }
                      case objectStates.PROPERTY: {
                        if (token.type === tokenTypes.RIGHT_BRACE) {
                          if (settings.loc) {
                            object.loc = location(
                              startToken.loc.start.line,
                              startToken.loc.start.column,
                              startToken.loc.start.offset,
                              token.loc.end.line,
                              token.loc.end.column,
                              token.loc.end.offset,
                              settings.source
                            );
                          }
                          return { value: object, index: index + 1 };
                        } else if (token.type === tokenTypes.COMMA) {
                          state = objectStates.COMMA;
                          index++;
                        } else {
                          error(
                            parseErrorTypes.unexpectedToken(
                              substring(
                                input,
                                token.loc.start.offset,
                                token.loc.end.offset
                              ),
                              settings.source,
                              token.loc.start.line,
                              token.loc.start.column
                            ),
                            input,
                            settings.source,
                            token.loc.start.line,
                            token.loc.start.column
                          );
                        }
                        break;
                      }
                      case objectStates.COMMA: {
                        var _property = parseProperty(
                          input,
                          tokenList,
                          index,
                          settings
                        );
                        if (_property) {
                          index = _property.index;
                          object.children.push(_property.value);
                          state = objectStates.PROPERTY;
                        } else {
                          error(
                            parseErrorTypes.unexpectedToken(
                              substring(
                                input,
                                token.loc.start.offset,
                                token.loc.end.offset
                              ),
                              settings.source,
                              token.loc.start.line,
                              token.loc.start.column
                            ),
                            input,
                            settings.source,
                            token.loc.start.line,
                            token.loc.start.column
                          );
                        }
                        break;
                      }
                    }
                  }
                  errorEof(input, tokenList, settings);
                }
                function parseProperty(input, tokenList, index, settings) {
                  // property: STRING COLON value
                  var startToken = void 0;
                  var property = { type: "Property", key: null, value: null };
                  var state = propertyStates._START_;
                  while (index < tokenList.length) {
                    var token = tokenList[index];
                    switch (state) {
                      case propertyStates._START_: {
                        if (token.type === tokenTypes.STRING) {
                          var key = {
                            type: "Identifier",
                            value: parseString(
                              input.slice(
                                token.loc.start.offset + 1,
                                token.loc.end.offset - 1
                              )
                            ),
                            raw: token.value
                          };
                          if (settings.loc) {
                            key.loc = token.loc;
                          }
                          startToken = token;
                          property.key = key;
                          state = propertyStates.KEY;
                          index++;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case propertyStates.KEY: {
                        if (token.type === tokenTypes.COLON) {
                          state = propertyStates.COLON;
                          index++;
                        } else {
                          error(
                            parseErrorTypes.unexpectedToken(
                              substring(
                                input,
                                token.loc.start.offset,
                                token.loc.end.offset
                              ),
                              settings.source,
                              token.loc.start.line,
                              token.loc.start.column
                            ),
                            input,
                            settings.source,
                            token.loc.start.line,
                            token.loc.start.column
                          );
                        }
                        break;
                      }
                      case propertyStates.COLON: {
                        var value = parseValue(input, tokenList, index, settings);
                        property.value = value.value;
                        if (settings.loc) {
                          property.loc = location(
                            startToken.loc.start.line,
                            startToken.loc.start.column,
                            startToken.loc.start.offset,
                            value.value.loc.end.line,
                            value.value.loc.end.column,
                            value.value.loc.end.offset,
                            settings.source
                          );
                        }
                        return { value: property, index: value.index };
                      }
                    }
                  }
                }
                function parseArray(input, tokenList, index, settings) {
                  // array: LEFT_BRACKET (value (COMMA value)*)? RIGHT_BRACKET
                  var startToken = void 0;
                  var array = { type: "Array", children: [] };
                  var state = arrayStates._START_;
                  var token = void 0;
                  while (index < tokenList.length) {
                    token = tokenList[index];
                    switch (state) {
                      case arrayStates._START_: {
                        if (token.type === tokenTypes.LEFT_BRACKET) {
                          startToken = token;
                          state = arrayStates.OPEN_ARRAY;
                          index++;
                        } else {
                          return null;
                        }
                        break;
                      }
                      case arrayStates.OPEN_ARRAY: {
                        if (token.type === tokenTypes.RIGHT_BRACKET) {
                          if (settings.loc) {
                            array.loc = location(
                              startToken.loc.start.line,
                              startToken.loc.start.column,
                              startToken.loc.start.offset,
                              token.loc.end.line,
                              token.loc.end.column,
                              token.loc.end.offset,
                              settings.source
                            );
                          }
                          return { value: array, index: index + 1 };
                        } else {
                          var value = parseValue(
                            input,
                            tokenList,
                            index,
                            settings
                          );
                          index = value.index;
                          array.children.push(value.value);
                          state = arrayStates.VALUE;
                        }
                        break;
                      }
                      case arrayStates.VALUE: {
                        if (token.type === tokenTypes.RIGHT_BRACKET) {
                          if (settings.loc) {
                            array.loc = location(
                              startToken.loc.start.line,
                              startToken.loc.start.column,
                              startToken.loc.start.offset,
                              token.loc.end.line,
                              token.loc.end.column,
                              token.loc.end.offset,
                              settings.source
                            );
                          }
                          return { value: array, index: index + 1 };
                        } else if (token.type === tokenTypes.COMMA) {
                          state = arrayStates.COMMA;
                          index++;
                        } else {
                          error(
                            parseErrorTypes.unexpectedToken(
                              substring(
                                input,
                                token.loc.start.offset,
                                token.loc.end.offset
                              ),
                              settings.source,
                              token.loc.start.line,
                              token.loc.start.column
                            ),
                            input,
                            settings.source,
                            token.loc.start.line,
                            token.loc.start.column
                          );
                        }
                        break;
                      }
                      case arrayStates.COMMA: {
                        var _value = parseValue(
                          input,
                          tokenList,
                          index,
                          settings
                        );
                        index = _value.index;
                        array.children.push(_value.value);
                        state = arrayStates.VALUE;
                        break;
                      }
                    }
                  }
                  errorEof(input, tokenList, settings);
                }
                function parseLiteral(input, tokenList, index, settings) {
                  // literal: STRING | NUMBER | TRUE | FALSE | NULL
                  var token = tokenList[index];
                  var value = null;
                  switch (token.type) {
                    case tokenTypes.STRING: {
                      value = parseString(
                        input.slice(
                          token.loc.start.offset + 1,
                          token.loc.end.offset - 1
                        )
                      );
                      break;
                    }
                    case tokenTypes.NUMBER: {
                      value = Number(token.value);
                      break;
                    }
                    case tokenTypes.TRUE: {
                      value = true;
                      break;
                    }
                    case tokenTypes.FALSE: {
                      value = false;
                      break;
                    }
                    case tokenTypes.NULL: {
                      value = null;
                      break;
                    }
                    default: {
                      return null;
                    }
                  }
                  var literal = {
                    type: "Literal",
                    value: value,
                    raw: token.value
                  };
                  if (settings.loc) {
                    literal.loc = token.loc;
                  }
                  return { value: literal, index: index + 1 };
                }
                function parseValue(input, tokenList, index, settings) {
                  // value: literal | object | array
                  var token = tokenList[index];
                  var value =
                    parseLiteral.apply(undefined, arguments) ||
                    parseObject.apply(undefined, arguments) ||
                    parseArray.apply(undefined, arguments);
                  if (value) {
                    return value;
                  } else {
                    error(
                      parseErrorTypes.unexpectedToken(
                        substring(
                          input,
                          token.loc.start.offset,
                          token.loc.end.offset
                        ),
                        settings.source,
                        token.loc.start.line,
                        token.loc.start.column
                      ),
                      input,
                      settings.source,
                      token.loc.start.line,
                      token.loc.start.column
                    );
                  }
                }
                var parse$1 = function parse$1(input, settings) {
                  settings = Object.assign({}, defaultSettings, settings);
                  var tokenList = tokenize(input, settings);
                  if (tokenList.length === 0) {
                    errorEof(input, tokenList, settings);
                  }
                  var value = parseValue(input, tokenList, 0, settings);
                  if (value.index === tokenList.length) {
                    return value.value;
                  }
                  var token = tokenList[value.index];
                  error(
                    parseErrorTypes.unexpectedToken(
                      substring(
                        input,
                        token.loc.start.offset,
                        token.loc.end.offset
                      ),
                      settings.source,
                      token.loc.start.line,
                      token.loc.start.column
                    ),
                    input,
                    settings.source,
                    token.loc.start.line,
                    token.loc.start.column
                  );
                };
                return parse$1;
              });
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      187: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              /**
               * lodash (Custom Build) <https://lodash.com/>
               * Build: `lodash modularize exports="npm" -o ./`
               * Copyright jQuery Foundation and other contributors <https://jquery.org/>
               * Released under MIT license <https://lodash.com/license>
               * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
               * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
               */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
              /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED =
                "__lodash_hash_undefined__";
              /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
              /** `Object#toString` result references. */ var argsTag =
                  "[object Arguments]",
                arrayTag = "[object Array]",
                boolTag = "[object Boolean]",
                dateTag = "[object Date]",
                errorTag = "[object Error]",
                funcTag = "[object Function]",
                genTag = "[object GeneratorFunction]",
                mapTag = "[object Map]",
                numberTag = "[object Number]",
                objectTag = "[object Object]",
                promiseTag = "[object Promise]",
                regexpTag = "[object RegExp]",
                setTag = "[object Set]",
                stringTag = "[object String]",
                symbolTag = "[object Symbol]",
                weakMapTag = "[object WeakMap]";
              var arrayBufferTag = "[object ArrayBuffer]",
                dataViewTag = "[object DataView]",
                float32Tag = "[object Float32Array]",
                float64Tag = "[object Float64Array]",
                int8Tag = "[object Int8Array]",
                int16Tag = "[object Int16Array]",
                int32Tag = "[object Int32Array]",
                uint8Tag = "[object Uint8Array]",
                uint8ClampedTag = "[object Uint8ClampedArray]",
                uint16Tag = "[object Uint16Array]",
                uint32Tag = "[object Uint32Array]";
              /**
               * Used to match `RegExp`
               * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
               */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
              /** Used to match `RegExp` flags from their coerced string values. */ var reFlags =
                /\w*$/;
              /** Used to detect host constructors (Safari). */ var reIsHostCtor =
                /^\[object .+?Constructor\]$/;
              /** Used to detect unsigned integer values. */ var reIsUint =
                /^(?:0|[1-9]\d*)$/;
              /** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags =
                {};
              cloneableTags[argsTag] =
                cloneableTags[arrayTag] =
                cloneableTags[arrayBufferTag] =
                cloneableTags[dataViewTag] =
                cloneableTags[boolTag] =
                cloneableTags[dateTag] =
                cloneableTags[float32Tag] =
                cloneableTags[float64Tag] =
                cloneableTags[int8Tag] =
                cloneableTags[int16Tag] =
                cloneableTags[int32Tag] =
                cloneableTags[mapTag] =
                cloneableTags[numberTag] =
                cloneableTags[objectTag] =
                cloneableTags[regexpTag] =
                cloneableTags[setTag] =
                cloneableTags[stringTag] =
                cloneableTags[symbolTag] =
                cloneableTags[uint8Tag] =
                cloneableTags[uint8ClampedTag] =
                cloneableTags[uint16Tag] =
                cloneableTags[uint32Tag] =
                  true;
              cloneableTags[errorTag] =
                cloneableTags[funcTag] =
                cloneableTags[weakMapTag] =
                  false;
              /** Detect free variable `global` from Node.js. */ var freeGlobal =
                _typeof2(global) == "object" &&
                global &&
                global.Object === Object &&
                global;
              /** Detect free variable `self`. */ var freeSelf =
                (typeof self === "undefined" ? "undefined" : _typeof2(self)) ==
                  "object" &&
                self &&
                self.Object === Object &&
                self;
              /** Used as a reference to the global object. */ var root =
                freeGlobal || freeSelf || Function("return this")();
              /** Detect free variable `exports`. */ var freeExports =
                _typeof2(exports) == "object" &&
                exports &&
                !exports.nodeType &&
                exports;
              /** Detect free variable `module`. */ var freeModule =
                freeExports &&
                _typeof2(module) == "object" &&
                module &&
                !module.nodeType &&
                module;
              /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports =
                freeModule && freeModule.exports === freeExports;
              /**
               * Adds the key-value `pair` to `map`.
               *
               * @private
               * @param {Object} map The map to modify.
               * @param {Array} pair The key-value pair to add.
               * @returns {Object} Returns `map`.
               */ function addMapEntry(map, pair) {
                // Don't return `map.set` because it's not chainable in IE 11.
                map.set(pair[0], pair[1]);
                return map;
              }
              /**
               * Adds `value` to `set`.
               *
               * @private
               * @param {Object} set The set to modify.
               * @param {*} value The value to add.
               * @returns {Object} Returns `set`.
               */ function addSetEntry(set, value) {
                // Don't return `set.add` because it's not chainable in IE 11.
                set.add(value);
                return set;
              }
              /**
               * A specialized version of `_.forEach` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns `array`.
               */ function arrayEach(array, iteratee) {
                var index = -1,
                  length = array ? array.length : 0;
                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }
              /**
               * Appends the elements of `values` to `array`.
               *
               * @private
               * @param {Array} array The array to modify.
               * @param {Array} values The values to append.
               * @returns {Array} Returns `array`.
               */ function arrayPush(array, values) {
                var index = -1,
                  length = values.length,
                  offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              /**
               * A specialized version of `_.reduce` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {*} [accumulator] The initial value.
               * @param {boolean} [initAccum] Specify using the first element of `array` as
               *  the initial value.
               * @returns {*} Returns the accumulated value.
               */ function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1,
                  length = array ? array.length : 0;
                if (initAccum && length) {
                  accumulator = array[++index];
                }
                while (++index < length) {
                  accumulator = iteratee(accumulator, array[index], index, array);
                }
                return accumulator;
              }
              /**
               * The base implementation of `_.times` without support for iteratee shorthands
               * or max array length checks.
               *
               * @private
               * @param {number} n The number of times to invoke `iteratee`.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns the array of results.
               */ function baseTimes(n, iteratee) {
                var index = -1,
                  result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              /**
               * Gets the value at `key` of `object`.
               *
               * @private
               * @param {Object} [object] The object to query.
               * @param {string} key The key of the property to get.
               * @returns {*} Returns the property value.
               */ function getValue(object, key) {
                return object == null ? undefined : object[key];
              }
              /**
               * Checks if `value` is a host object in IE < 9.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
               */ function isHostObject(value) {
                // Many host objects are `Object` objects that can coerce to strings
                // despite having improperly defined `toString` methods.
                var result = false;
                if (value != null && typeof value.toString != "function") {
                  try {
                    result = !!(value + "");
                  } catch (e) {}
                }
                return result;
              }
              /**
               * Converts `map` to its key-value pairs.
               *
               * @private
               * @param {Object} map The map to convert.
               * @returns {Array} Returns the key-value pairs.
               */ function mapToArray(map) {
                var index = -1,
                  result = Array(map.size);
                map.forEach(function (value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              /**
               * Creates a unary function that invokes `func` with its argument transformed.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {Function} transform The argument transform.
               * @returns {Function} Returns the new function.
               */ function overArg(func, transform) {
                return function (arg) {
                  return func(transform(arg));
                };
              }
              /**
               * Converts `set` to an array of its values.
               *
               * @private
               * @param {Object} set The set to convert.
               * @returns {Array} Returns the values.
               */ function setToArray(set) {
                var index = -1,
                  result = Array(set.size);
                set.forEach(function (value) {
                  result[++index] = value;
                });
                return result;
              }
              /** Used for built-in method references. */ var arrayProto =
                  Array.prototype,
                funcProto = Function.prototype,
                objectProto = Object.prototype;
              /** Used to detect overreaching core-js shims. */ var coreJsData =
                root["__core-js_shared__"];
              /** Used to detect methods masquerading as native. */ var maskSrcKey =
                (function () {
                  var uid = /[^.]+$/.exec(
                    (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                      ""
                  );
                  return uid ? "Symbol(src)_1." + uid : "";
                })();
              /** Used to resolve the decompiled source of functions. */ var funcToString =
                funcProto.toString;
              /** Used to check objects for own properties. */ var hasOwnProperty =
                objectProto.hasOwnProperty;
              /**
               * Used to resolve the
               * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
               * of values.
               */ var objectToString = objectProto.toString;
              /** Used to detect if a method is native. */ var reIsNative =
                RegExp(
                  "^" +
                    funcToString
                      .call(hasOwnProperty)
                      .replace(reRegExpChar, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                );
              /** Built-in value references. */ var Buffer = moduleExports
                  ? root.Buffer
                  : undefined,
                _Symbol = root.Symbol,
                Uint8Array = root.Uint8Array,
                getPrototype = overArg(Object.getPrototypeOf, Object),
                objectCreate = Object.create,
                propertyIsEnumerable = objectProto.propertyIsEnumerable,
                splice = arrayProto.splice;
              /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols =
                  Object.getOwnPropertySymbols,
                nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                nativeKeys = overArg(Object.keys, Object);
              /* Built-in method references that are verified to be native. */ var DataView =
                  getNative(root, "DataView"),
                Map = getNative(root, "Map"),
                Promise = getNative(root, "Promise"),
                Set = getNative(root, "Set"),
                WeakMap = getNative(root, "WeakMap"),
                nativeCreate = getNative(Object, "create");
              /** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString =
                  toSource(DataView),
                mapCtorString = toSource(Map),
                promiseCtorString = toSource(Promise),
                setCtorString = toSource(Set),
                weakMapCtorString = toSource(WeakMap);
              /** Used to convert symbols to primitives and strings. */ var symbolProto =
                  _Symbol ? _Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
              /**
               * Creates a hash object.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */ function Hash(entries) {
                var index = -1,
                  length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
               * Removes all key-value entries from the hash.
               *
               * @private
               * @name clear
               * @memberOf Hash
               */ function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
              }
              /**
               * Removes `key` and its value from the hash.
               *
               * @private
               * @name delete
               * @memberOf Hash
               * @param {Object} hash The hash to modify.
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */ function hashDelete(key) {
                return this.has(key) && delete this.__data__[key];
              }
              /**
               * Gets the hash value for `key`.
               *
               * @private
               * @name get
               * @memberOf Hash
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */ function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
              }
              /**
               * Checks if a hash value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf Hash
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */ function hashHas(key) {
                var data = this.__data__;
                return nativeCreate
                  ? data[key] !== undefined
                  : hasOwnProperty.call(data, key);
              }
              /**
               * Sets the hash `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf Hash
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the hash instance.
               */ function hashSet(key, value) {
                var data = this.__data__;
                data[key] =
                  nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
              } // Add methods to `Hash`.
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              /**
               * Creates an list cache object.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */ function ListCache(entries) {
                var index = -1,
                  length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
               * Removes all key-value entries from the list cache.
               *
               * @private
               * @name clear
               * @memberOf ListCache
               */ function listCacheClear() {
                this.__data__ = [];
              }
              /**
               * Removes `key` and its value from the list cache.
               *
               * @private
               * @name delete
               * @memberOf ListCache
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */ function listCacheDelete(key) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                return true;
              }
              /**
               * Gets the list cache value for `key`.
               *
               * @private
               * @name get
               * @memberOf ListCache
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */ function listCacheGet(key) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                return index < 0 ? undefined : data[index][1];
              }
              /**
               * Checks if a list cache value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf ListCache
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */ function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              /**
               * Sets the list cache `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf ListCache
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the list cache instance.
               */ function listCacheSet(key, value) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                if (index < 0) {
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              } // Add methods to `ListCache`.
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              /**
               * Creates a map cache object to store key-value pairs.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */ function MapCache(entries) {
                var index = -1,
                  length = entries ? entries.length : 0;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
               * Removes all key-value entries from the map.
               *
               * @private
               * @name clear
               * @memberOf MapCache
               */ function mapCacheClear() {
                this.__data__ = {
                  hash: new Hash(),
                  map: new (Map || ListCache)(),
                  string: new Hash()
                };
              }
              /**
               * Removes `key` and its value from the map.
               *
               * @private
               * @name delete
               * @memberOf MapCache
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */ function mapCacheDelete(key) {
                return getMapData(this, key)["delete"](key);
              }
              /**
               * Gets the map value for `key`.
               *
               * @private
               * @name get
               * @memberOf MapCache
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */ function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              /**
               * Checks if a map value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf MapCache
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */ function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              /**
               * Sets the map `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf MapCache
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the map cache instance.
               */ function mapCacheSet(key, value) {
                getMapData(this, key).set(key, value);
                return this;
              } // Add methods to `MapCache`.
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              /**
               * Creates a stack cache object to store key-value pairs.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */ function Stack(entries) {
                this.__data__ = new ListCache(entries);
              }
              /**
               * Removes all key-value entries from the stack.
               *
               * @private
               * @name clear
               * @memberOf Stack
               */ function stackClear() {
                this.__data__ = new ListCache();
              }
              /**
               * Removes `key` and its value from the stack.
               *
               * @private
               * @name delete
               * @memberOf Stack
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */ function stackDelete(key) {
                return this.__data__["delete"](key);
              }
              /**
               * Gets the stack value for `key`.
               *
               * @private
               * @name get
               * @memberOf Stack
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */ function stackGet(key) {
                return this.__data__.get(key);
              }
              /**
               * Checks if a stack value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf Stack
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */ function stackHas(key) {
                return this.__data__.has(key);
              }
              /**
               * Sets the stack `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf Stack
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the stack cache instance.
               */ function stackSet(key, value) {
                var cache = this.__data__;
                if (cache instanceof ListCache) {
                  var pairs = cache.__data__;
                  if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    return this;
                  }
                  cache = this.__data__ = new MapCache(pairs);
                }
                cache.set(key, value);
                return this;
              } // Add methods to `Stack`.
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              /**
               * Creates an array of the enumerable property names of the array-like `value`.
               *
               * @private
               * @param {*} value The value to query.
               * @param {boolean} inherited Specify returning inherited property names.
               * @returns {Array} Returns the array of property names.
               */ function arrayLikeKeys(value, inherited) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                // Safari 9 makes `arguments.length` enumerable in strict mode.
                var result =
                  isArray(value) || isArguments(value)
                    ? baseTimes(value.length, String)
                    : [];
                var length = result.length,
                  skipIndexes = !!length;
                for (var key in value) {
                  if (
                    (inherited || hasOwnProperty.call(value, key)) &&
                    !(skipIndexes && (key == "length" || isIndex(key, length)))
                  ) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
               * Assigns `value` to `key` of `object` if the existing value is not equivalent
               * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {string} key The key of the property to assign.
               * @param {*} value The value to assign.
               */ function assignValue(object, key, value) {
                var objValue = object[key];
                if (
                  !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                  (value === undefined && !(key in object))
                ) {
                  object[key] = value;
                }
              }
              /**
               * Gets the index at which the `key` is found in `array` of key-value pairs.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} key The key to search for.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */ function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              /**
               * The base implementation of `_.assign` without support for multiple sources
               * or `customizer` functions.
               *
               * @private
               * @param {Object} object The destination object.
               * @param {Object} source The source object.
               * @returns {Object} Returns `object`.
               */ function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              /**
               * The base implementation of `_.clone` and `_.cloneDeep` which tracks
               * traversed objects.
               *
               * @private
               * @param {*} value The value to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @param {boolean} [isFull] Specify a clone including symbols.
               * @param {Function} [customizer] The function to customize cloning.
               * @param {string} [key] The key of `value`.
               * @param {Object} [object] The parent object of `value`.
               * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
               * @returns {*} Returns the cloned value.
               */ function baseClone(
                value,
                isDeep,
                isFull,
                customizer,
                key,
                object,
                stack
              ) {
                var result;
                if (customizer) {
                  result = object
                    ? customizer(value, key, object, stack)
                    : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result);
                  }
                } else {
                  var tag = getTag(value),
                    isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                    if (isHostObject(value)) {
                      return object ? value : {};
                    }
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                      return copySymbols(value, baseAssign(result, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                  }
                } // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result);
                if (!isArr) {
                  var props = isFull ? getAllKeys(value) : keys(value);
                }
                arrayEach(props || value, function (subValue, key) {
                  if (props) {
                    key = subValue;
                    subValue = value[key];
                  } // Recursively populate clone (susceptible to call stack limits).
                  assignValue(
                    result,
                    key,
                    baseClone(
                      subValue,
                      isDeep,
                      isFull,
                      customizer,
                      key,
                      value,
                      stack
                    )
                  );
                });
                return result;
              }
              /**
               * The base implementation of `_.create` without support for assigning
               * properties to the created object.
               *
               * @private
               * @param {Object} prototype The object to inherit from.
               * @returns {Object} Returns the new object.
               */ function baseCreate(proto) {
                return isObject(proto) ? objectCreate(proto) : {};
              }
              /**
               * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
               * `keysFunc` and `symbolsFunc` to get the enumerable property names and
               * symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Function} keysFunc The function to get the keys of `object`.
               * @param {Function} symbolsFunc The function to get the symbols of `object`.
               * @returns {Array} Returns the array of property names and symbols.
               */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object)
                  ? result
                  : arrayPush(result, symbolsFunc(object));
              }
              /**
               * The base implementation of `getTag`.
               *
               * @private
               * @param {*} value The value to query.
               * @returns {string} Returns the `toStringTag`.
               */ function baseGetTag(value) {
                return objectToString.call(value);
              }
              /**
               * The base implementation of `_.isNative` without bad shim checks.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a native function,
               *  else `false`.
               */ function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern =
                  isFunction(value) || isHostObject(value)
                    ? reIsNative
                    : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              /**
               * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               */ function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
               * Creates a clone of  `buffer`.
               *
               * @private
               * @param {Buffer} buffer The buffer to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Buffer} Returns the cloned buffer.
               */ function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var result = new buffer.constructor(buffer.length);
                buffer.copy(result);
                return result;
              }
              /**
               * Creates a clone of `arrayBuffer`.
               *
               * @private
               * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
               * @returns {ArrayBuffer} Returns the cloned array buffer.
               */ function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
              }
              /**
               * Creates a clone of `dataView`.
               *
               * @private
               * @param {Object} dataView The data view to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned data view.
               */ function cloneDataView(dataView, isDeep) {
                var buffer = isDeep
                  ? cloneArrayBuffer(dataView.buffer)
                  : dataView.buffer;
                return new dataView.constructor(
                  buffer,
                  dataView.byteOffset,
                  dataView.byteLength
                );
              }
              /**
               * Creates a clone of `map`.
               *
               * @private
               * @param {Object} map The map to clone.
               * @param {Function} cloneFunc The function to clone values.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned map.
               */ function cloneMap(map, isDeep, cloneFunc) {
                var array = isDeep
                  ? cloneFunc(mapToArray(map), true)
                  : mapToArray(map);
                return arrayReduce(array, addMapEntry, new map.constructor());
              }
              /**
               * Creates a clone of `regexp`.
               *
               * @private
               * @param {Object} regexp The regexp to clone.
               * @returns {Object} Returns the cloned regexp.
               */ function cloneRegExp(regexp) {
                var result = new regexp.constructor(
                  regexp.source,
                  reFlags.exec(regexp)
                );
                result.lastIndex = regexp.lastIndex;
                return result;
              }
              /**
               * Creates a clone of `set`.
               *
               * @private
               * @param {Object} set The set to clone.
               * @param {Function} cloneFunc The function to clone values.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned set.
               */ function cloneSet(set, isDeep, cloneFunc) {
                var array = isDeep
                  ? cloneFunc(setToArray(set), true)
                  : setToArray(set);
                return arrayReduce(array, addSetEntry, new set.constructor());
              }
              /**
               * Creates a clone of the `symbol` object.
               *
               * @private
               * @param {Object} symbol The symbol object to clone.
               * @returns {Object} Returns the cloned symbol object.
               */ function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }
              /**
               * Creates a clone of `typedArray`.
               *
               * @private
               * @param {Object} typedArray The typed array to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned typed array.
               */ function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep
                  ? cloneArrayBuffer(typedArray.buffer)
                  : typedArray.buffer;
                return new typedArray.constructor(
                  buffer,
                  typedArray.byteOffset,
                  typedArray.length
                );
              }
              /**
               * Copies the values of `source` to `array`.
               *
               * @private
               * @param {Array} source The array to copy values from.
               * @param {Array} [array=[]] The array to copy values to.
               * @returns {Array} Returns `array`.
               */ function copyArray(source, array) {
                var index = -1,
                  length = source.length;
                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }
              /**
               * Copies properties of `source` to `object`.
               *
               * @private
               * @param {Object} source The object to copy properties from.
               * @param {Array} props The property identifiers to copy.
               * @param {Object} [object={}] The object to copy properties to.
               * @param {Function} [customizer] The function to customize copied values.
               * @returns {Object} Returns `object`.
               */ function copyObject(source, props, object, customizer) {
                object || (object = {});
                var index = -1,
                  length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer
                    ? customizer(object[key], source[key], key, object, source)
                    : undefined;
                  assignValue(
                    object,
                    key,
                    newValue === undefined ? source[key] : newValue
                  );
                }
                return object;
              }
              /**
               * Copies own symbol properties of `source` to `object`.
               *
               * @private
               * @param {Object} source The object to copy symbols from.
               * @param {Object} [object={}] The object to copy symbols to.
               * @returns {Object} Returns `object`.
               */ function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              /**
               * Creates an array of own enumerable property names and symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names and symbols.
               */ function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              /**
               * Gets the data for `map`.
               *
               * @private
               * @param {Object} map The map to query.
               * @param {string} key The reference key.
               * @returns {*} Returns the map data.
               */ function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key)
                  ? data[typeof key == "string" ? "string" : "hash"]
                  : data.map;
              }
              /**
               * Gets the native function at `key` of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {string} key The key of the method to get.
               * @returns {*} Returns the function if it's native, else `undefined`.
               */ function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
              }
              /**
               * Creates an array of the own enumerable symbol properties of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of symbols.
               */ var getSymbols = nativeGetSymbols
                ? overArg(nativeGetSymbols, Object)
                : stubArray;
              /**
               * Gets the `toStringTag` of `value`.
               *
               * @private
               * @param {*} value The value to query.
               * @returns {string} Returns the `toStringTag`.
               */ var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
              // for data views in Edge < 14, and promises in Node.js.
              if (
                (DataView &&
                  getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                (Map && getTag(new Map()) != mapTag) ||
                (Promise && getTag(Promise.resolve()) != promiseTag) ||
                (Set && getTag(new Set()) != setTag) ||
                (WeakMap && getTag(new WeakMap()) != weakMapTag)
              ) {
                getTag = function getTag(value) {
                  var result = objectToString.call(value),
                    Ctor = result == objectTag ? value.constructor : undefined,
                    ctorString = Ctor ? toSource(Ctor) : undefined;
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              /**
               * Initializes an array clone.
               *
               * @private
               * @param {Array} array The array to clone.
               * @returns {Array} Returns the initialized clone.
               */ function initCloneArray(array) {
                var length = array.length,
                  result = array.constructor(length); // Add properties assigned by `RegExp#exec`.
                if (
                  length &&
                  typeof array[0] == "string" &&
                  hasOwnProperty.call(array, "index")
                ) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }
              /**
               * Initializes an object clone.
               *
               * @private
               * @param {Object} object The object to clone.
               * @returns {Object} Returns the initialized clone.
               */ function initCloneObject(object) {
                return typeof object.constructor == "function" &&
                  !isPrototype(object)
                  ? baseCreate(getPrototype(object))
                  : {};
              }
              /**
               * Initializes an object clone based on its `toStringTag`.
               *
               * **Note:** This function only supports cloning values with tags of
               * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
               *
               * @private
               * @param {Object} object The object to clone.
               * @param {string} tag The `toStringTag` of the object to clone.
               * @param {Function} cloneFunc The function to clone values.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the initialized clone.
               */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);
                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);
                  case dataViewTag:
                    return cloneDataView(object, isDeep);
                  case float32Tag:
                  case float64Tag:
                  case int8Tag:
                  case int16Tag:
                  case int32Tag:
                  case uint8Tag:
                  case uint8ClampedTag:
                  case uint16Tag:
                  case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                  case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);
                  case numberTag:
                  case stringTag:
                    return new Ctor(object);
                  case regexpTag:
                    return cloneRegExp(object);
                  case setTag:
                    return cloneSet(object, isDeep, cloneFunc);
                  case symbolTag:
                    return cloneSymbol(object);
                }
              }
              /**
               * Checks if `value` is a valid array-like index.
               *
               * @private
               * @param {*} value The value to check.
               * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
               * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
               */ function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return (
                  !!length &&
                  (typeof value == "number" || reIsUint.test(value)) &&
                  value > -1 &&
                  value % 1 == 0 &&
                  value < length
                );
              }
              /**
               * Checks if `value` is suitable for use as unique object key.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
               */ function isKeyable(value) {
                var type = _typeof2(value);
                return type == "string" ||
                  type == "number" ||
                  type == "symbol" ||
                  type == "boolean"
                  ? value !== "__proto__"
                  : value === null;
              }
              /**
               * Checks if `func` has its source masked.
               *
               * @private
               * @param {Function} func The function to check.
               * @returns {boolean} Returns `true` if `func` is masked, else `false`.
               */ function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              /**
               * Checks if `value` is likely a prototype object.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
               */ function isPrototype(value) {
                var Ctor = value && value.constructor,
                  proto =
                    (typeof Ctor == "function" && Ctor.prototype) || objectProto;
                return value === proto;
              }
              /**
               * Converts `func` to its source code.
               *
               * @private
               * @param {Function} func The function to process.
               * @returns {string} Returns the source code.
               */ function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {}
                  try {
                    return func + "";
                  } catch (e) {}
                }
                return "";
              }
              /**
               * This method is like `_.clone` except that it recursively clones `value`.
               *
               * @static
               * @memberOf _
               * @since 1.0.0
               * @category Lang
               * @param {*} value The value to recursively clone.
               * @returns {*} Returns the deep cloned value.
               * @see _.clone
               * @example
               *
               * var objects = [{ 'a': 1 }, { 'b': 2 }];
               *
               * var deep = _.cloneDeep(objects);
               * console.log(deep[0] === objects[0]);
               * // => false
               */ function cloneDeep(value) {
                return baseClone(value, true, true);
              }
              /**
               * Performs a
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * comparison between two values to determine if they are equivalent.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
               * @example
               *
               * var object = { 'a': 1 };
               * var other = { 'a': 1 };
               *
               * _.eq(object, object);
               * // => true
               *
               * _.eq(object, other);
               * // => false
               *
               * _.eq('a', 'a');
               * // => true
               *
               * _.eq('a', Object('a'));
               * // => false
               *
               * _.eq(NaN, NaN);
               * // => true
               */ function eq(value, other) {
                return value === other || (value !== value && other !== other);
              }
              /**
               * Checks if `value` is likely an `arguments` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an `arguments` object,
               *  else `false`.
               * @example
               *
               * _.isArguments(function() { return arguments; }());
               * // => true
               *
               * _.isArguments([1, 2, 3]);
               * // => false
               */ function isArguments(value) {
                // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                return (
                  isArrayLikeObject(value) &&
                  hasOwnProperty.call(value, "callee") &&
                  (!propertyIsEnumerable.call(value, "callee") ||
                    objectToString.call(value) == argsTag)
                );
              }
              /**
               * Checks if `value` is classified as an `Array` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array, else `false`.
               * @example
               *
               * _.isArray([1, 2, 3]);
               * // => true
               *
               * _.isArray(document.body.children);
               * // => false
               *
               * _.isArray('abc');
               * // => false
               *
               * _.isArray(_.noop);
               * // => false
               */ var isArray = Array.isArray;
              /**
               * Checks if `value` is array-like. A value is considered array-like if it's
               * not a function and has a `value.length` that's an integer greater than or
               * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
               * @example
               *
               * _.isArrayLike([1, 2, 3]);
               * // => true
               *
               * _.isArrayLike(document.body.children);
               * // => true
               *
               * _.isArrayLike('abc');
               * // => true
               *
               * _.isArrayLike(_.noop);
               * // => false
               */ function isArrayLike(value) {
                return (
                  value != null && isLength(value.length) && !isFunction(value)
                );
              }
              /**
               * This method is like `_.isArrayLike` except that it also checks if `value`
               * is an object.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array-like object,
               *  else `false`.
               * @example
               *
               * _.isArrayLikeObject([1, 2, 3]);
               * // => true
               *
               * _.isArrayLikeObject(document.body.children);
               * // => true
               *
               * _.isArrayLikeObject('abc');
               * // => false
               *
               * _.isArrayLikeObject(_.noop);
               * // => false
               */ function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              /**
               * Checks if `value` is a buffer.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
               * @example
               *
               * _.isBuffer(new Buffer(2));
               * // => true
               *
               * _.isBuffer(new Uint8Array(2));
               * // => false
               */ var isBuffer = nativeIsBuffer || stubFalse;
              /**
               * Checks if `value` is classified as a `Function` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a function, else `false`.
               * @example
               *
               * _.isFunction(_);
               * // => true
               *
               * _.isFunction(/abc/);
               * // => false
               */ function isFunction(value) {
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 8-9 which returns 'object' for typed array and other constructors.
                var tag = isObject(value) ? objectToString.call(value) : "";
                return tag == funcTag || tag == genTag;
              }
              /**
               * Checks if `value` is a valid array-like length.
               *
               * **Note:** This method is loosely based on
               * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
               * @example
               *
               * _.isLength(3);
               * // => true
               *
               * _.isLength(Number.MIN_VALUE);
               * // => false
               *
               * _.isLength(Infinity);
               * // => false
               *
               * _.isLength('3');
               * // => false
               */ function isLength(value) {
                return (
                  typeof value == "number" &&
                  value > -1 &&
                  value % 1 == 0 &&
                  value <= MAX_SAFE_INTEGER
                );
              }
              /**
               * Checks if `value` is the
               * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
               * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an object, else `false`.
               * @example
               *
               * _.isObject({});
               * // => true
               *
               * _.isObject([1, 2, 3]);
               * // => true
               *
               * _.isObject(_.noop);
               * // => true
               *
               * _.isObject(null);
               * // => false
               */ function isObject(value) {
                var type = _typeof2(value);
                return !!value && (type == "object" || type == "function");
              }
              /**
               * Checks if `value` is object-like. A value is object-like if it's not `null`
               * and has a `typeof` result of "object".
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
               * @example
               *
               * _.isObjectLike({});
               * // => true
               *
               * _.isObjectLike([1, 2, 3]);
               * // => true
               *
               * _.isObjectLike(_.noop);
               * // => false
               *
               * _.isObjectLike(null);
               * // => false
               */ function isObjectLike(value) {
                return !!value && _typeof2(value) == "object";
              }
              /**
               * Creates an array of the own enumerable property names of `object`.
               *
               * **Note:** Non-object values are coerced to objects. See the
               * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
               * for more details.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.keys(new Foo);
               * // => ['a', 'b'] (iteration order is not guaranteed)
               *
               * _.keys('hi');
               * // => ['0', '1']
               */ function keys(object) {
                return isArrayLike(object)
                  ? arrayLikeKeys(object)
                  : baseKeys(object);
              }
              /**
               * This method returns a new empty array.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {Array} Returns the new empty array.
               * @example
               *
               * var arrays = _.times(2, _.stubArray);
               *
               * console.log(arrays);
               * // => [[], []]
               *
               * console.log(arrays[0] === arrays[1]);
               * // => false
               */ function stubArray() {
                return [];
              }
              /**
               * This method returns `false`.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {boolean} Returns `false`.
               * @example
               *
               * _.times(2, _.stubFalse);
               * // => [false, false]
               */ function stubFalse() {
                return false;
              }
              module.exports = cloneDeep;
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      188: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var _typeof =
            typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol"
              ? function (obj) {
                  return _typeof2(obj);
                }
              : function (obj) {
                  return obj &&
                    typeof Symbol === "function" &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : _typeof2(obj);
                };
          exports.apply = apply;
          /**
           * Test if a value is a plain object.
           * @param {*} val - A value.
           * @return {boolean} true if `val` is a plain object.
           */ var isObject = function isObject(val) {
            return (
              val != null &&
              (typeof val === "undefined" ? "undefined" : _typeof(val)) ===
                "object" &&
              Array.isArray(val) === false
            );
          };
          /**
           * Apply a JSON merge patch. The origin is *not* modified, but unchanged
           * properties will be recycled.
           *
           * @param {*} origin - The value to patch.
           * @param {*} patch - An [RFC 7396](https://tools.ietf.org/html/rfc7396) patch.
           * @return {*} The patched value.
           */ function apply(origin, patch) {
            if (!isObject(patch)) {
              // If the patch is not an object, it replaces the origin.
              return patch;
            }
            var result = !isObject(origin) // Non objects are being replaced.
              ? {} // Make sure we never modify the origin.
              : Object.assign({}, origin);
            Object.keys(patch).forEach(function (key) {
              var patchVal = patch[key];
              if (patchVal === null) {
                delete result[key];
              } else {
                result[key] = apply(result[key], patchVal);
              }
            });
            return result;
          }
          exports["default"] = apply;
        },
        {}
      ],
      189: [
        function (require, module, exports) {
          /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function (
            global,
            factory
          ) {
            _typeof2(exports) === "object" && typeof module !== "undefined"
              ? factory(exports)
              : typeof define === "function" && define.amd
              ? define(["exports"], factory)
              : factory((global.URI = global.URI || {}));
          })(this, function (exports) {
            "use strict";
            function merge() {
              for (
                var _len = arguments.length, sets = Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                sets[_key] = arguments[_key];
              }
              if (sets.length > 1) {
                sets[0] = sets[0].slice(0, -1);
                var xl = sets.length - 1;
                for (var x = 1; x < xl; ++x) {
                  sets[x] = sets[x].slice(1, -1);
                }
                sets[xl] = sets[xl].slice(1);
                return sets.join("");
              } else {
                return sets[0];
              }
            }
            function subexp(str) {
              return "(?:" + str + ")";
            }
            function typeOf(o) {
              return o === undefined
                ? "undefined"
                : o === null
                ? "null"
                : Object.prototype.toString
                    .call(o)
                    .split(" ")
                    .pop()
                    .split("]")
                    .shift()
                    .toLowerCase();
            }
            function toUpperCase(str) {
              return str.toUpperCase();
            }
            function toArray(obj) {
              return obj !== undefined && obj !== null
                ? obj instanceof Array
                  ? obj
                  : typeof obj.length !== "number" ||
                    obj.split ||
                    obj.setInterval ||
                    obj.call
                  ? [obj]
                  : Array.prototype.slice.call(obj)
                : [];
            }
            function assign(target, source) {
              var obj = target;
              if (source) {
                for (var key in source) {
                  obj[key] = source[key];
                }
              }
              return obj;
            }
            function buildExps(isIRI) {
              var ALPHA$$ = "[A-Za-z]",
                CR$ = "[\\x0D]",
                DIGIT$$ = "[0-9]",
                DQUOTE$$ = "[\\x22]",
                HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), //case-insensitive
                LF$$ = "[\\x0A]",
                SP$$ = "[\\x20]",
                PCT_ENCODED$ = subexp(
                  subexp(
                    "%[EFef]" +
                      HEXDIG$$ +
                      "%" +
                      HEXDIG$$ +
                      HEXDIG$$ +
                      "%" +
                      HEXDIG$$ +
                      HEXDIG$$
                  ) +
                    "|" +
                    subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
                    "|" +
                    subexp("%" + HEXDIG$$ + HEXDIG$$)
                ), //expanded
                GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
                SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
                RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
                UCSCHAR$$ = isIRI
                  ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
                  : "[]", //subset, excludes bidi control characters
                IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", //subset
                UNRESERVED$$ = merge(
                  ALPHA$$,
                  DIGIT$$,
                  "[\\-\\.\\_\\~]",
                  UCSCHAR$$
                ),
                SCHEME$ = subexp(
                  ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"
                ),
                USERINFO$ = subexp(
                  subexp(
                    PCT_ENCODED$ +
                      "|" +
                      merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")
                  ) + "*"
                ),
                DEC_OCTET$ = subexp(
                  subexp("25[0-5]") +
                    "|" +
                    subexp("2[0-4]" + DIGIT$$) +
                    "|" +
                    subexp("1" + DIGIT$$ + DIGIT$$) +
                    "|" +
                    subexp("[1-9]" + DIGIT$$) +
                    "|" +
                    DIGIT$$
                ),
                DEC_OCTET_RELAXED$ = subexp(
                  subexp("25[0-5]") +
                    "|" +
                    subexp("2[0-4]" + DIGIT$$) +
                    "|" +
                    subexp("1" + DIGIT$$ + DIGIT$$) +
                    "|" +
                    subexp("0?[1-9]" + DIGIT$$) +
                    "|0?0?" +
                    DIGIT$$
                ), //relaxed parsing rules
                IPV4ADDRESS$ = subexp(
                  DEC_OCTET_RELAXED$ +
                    "\\." +
                    DEC_OCTET_RELAXED$ +
                    "\\." +
                    DEC_OCTET_RELAXED$ +
                    "\\." +
                    DEC_OCTET_RELAXED$
                ),
                H16$ = subexp(HEXDIG$$ + "{1,4}"),
                LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
                IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), //                           6( h16 ":" ) ls32
                IPV6ADDRESS2$ = subexp(
                  "\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$
                ), //                      "::" 5( h16 ":" ) ls32
                IPV6ADDRESS3$ = subexp(
                  subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$
                ), //[               h16 ] "::" 4( h16 ":" ) ls32
                IPV6ADDRESS4$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) +
                    "?\\:\\:" +
                    subexp(H16$ + "\\:") +
                    "{3}" +
                    LS32$
                ), //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                IPV6ADDRESS5$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) +
                    "?\\:\\:" +
                    subexp(H16$ + "\\:") +
                    "{2}" +
                    LS32$
                ), //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                IPV6ADDRESS6$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) +
                    "?\\:\\:" +
                    H16$ +
                    "\\:" +
                    LS32$
                ), //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                IPV6ADDRESS7$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) +
                    "?\\:\\:" +
                    LS32$
                ), //[ *4( h16 ":" ) h16 ] "::"              ls32
                IPV6ADDRESS8$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$
                ), //[ *5( h16 ":" ) h16 ] "::"              h16
                IPV6ADDRESS9$ = subexp(
                  subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"
                ), //[ *6( h16 ":" ) h16 ] "::"
                IPV6ADDRESS$ = subexp(
                  [
                    IPV6ADDRESS1$,
                    IPV6ADDRESS2$,
                    IPV6ADDRESS3$,
                    IPV6ADDRESS4$,
                    IPV6ADDRESS5$,
                    IPV6ADDRESS6$,
                    IPV6ADDRESS7$,
                    IPV6ADDRESS8$,
                    IPV6ADDRESS9$
                  ].join("|")
                ),
                ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), //RFC 6874
                IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), //RFC 6874
                IPV6ADDRZ_RELAXED$ = subexp(
                  IPV6ADDRESS$ +
                    subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") +
                    ZONEID$
                ), //RFC 6874, with relaxed parsing rules
                IPVFUTURE$ = subexp(
                  "[vV]" +
                    HEXDIG$$ +
                    "+\\." +
                    merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") +
                    "+"
                ),
                IP_LITERAL$ = subexp(
                  "\\[" +
                    subexp(
                      IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$
                    ) +
                    "\\]"
                ), //RFC 6874
                REG_NAME$ = subexp(
                  subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) +
                    "*"
                ),
                HOST$ = subexp(
                  IP_LITERAL$ +
                    "|" +
                    IPV4ADDRESS$ +
                    "(?!" +
                    REG_NAME$ +
                    ")" +
                    "|" +
                    REG_NAME$
                ),
                PORT$ = subexp(DIGIT$$ + "*"),
                AUTHORITY$ = subexp(
                  subexp(USERINFO$ + "@") +
                    "?" +
                    HOST$ +
                    subexp("\\:" + PORT$) +
                    "?"
                ),
                PCHAR$ = subexp(
                  PCT_ENCODED$ +
                    "|" +
                    merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")
                ),
                SEGMENT$ = subexp(PCHAR$ + "*"),
                SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
                SEGMENT_NZ_NC$ = subexp(
                  subexp(
                    PCT_ENCODED$ +
                      "|" +
                      merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")
                  ) + "+"
                ),
                PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
                PATH_ABSOLUTE$ = subexp(
                  "\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"
                ), //simplified
                PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified
                PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified
                PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
                PATH$ = subexp(
                  PATH_ABEMPTY$ +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_NOSCHEME$ +
                    "|" +
                    PATH_ROOTLESS$ +
                    "|" +
                    PATH_EMPTY$
                ),
                QUERY$ = subexp(
                  subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"
                ),
                FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
                HIER_PART$ = subexp(
                  subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_ROOTLESS$ +
                    "|" +
                    PATH_EMPTY$
                ),
                URI$ = subexp(
                  SCHEME$ +
                    "\\:" +
                    HIER_PART$ +
                    subexp("\\?" + QUERY$) +
                    "?" +
                    subexp("\\#" + FRAGMENT$) +
                    "?"
                ),
                RELATIVE_PART$ = subexp(
                  subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) +
                    "|" +
                    PATH_ABSOLUTE$ +
                    "|" +
                    PATH_NOSCHEME$ +
                    "|" +
                    PATH_EMPTY$
                ),
                RELATIVE$ = subexp(
                  RELATIVE_PART$ +
                    subexp("\\?" + QUERY$) +
                    "?" +
                    subexp("\\#" + FRAGMENT$) +
                    "?"
                ),
                URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
                ABSOLUTE_URI$ = subexp(
                  SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"
                ),
                GENERIC_REF$ =
                  "^(" +
                  SCHEME$ +
                  ")\\:" +
                  subexp(
                    subexp(
                      "\\/\\/(" +
                        subexp("(" + USERINFO$ + ")@") +
                        "?(" +
                        HOST$ +
                        ")" +
                        subexp("\\:(" + PORT$ + ")") +
                        "?)"
                    ) +
                      "?(" +
                      PATH_ABEMPTY$ +
                      "|" +
                      PATH_ABSOLUTE$ +
                      "|" +
                      PATH_ROOTLESS$ +
                      "|" +
                      PATH_EMPTY$ +
                      ")"
                  ) +
                  subexp("\\?(" + QUERY$ + ")") +
                  "?" +
                  subexp("\\#(" + FRAGMENT$ + ")") +
                  "?$",
                RELATIVE_REF$ =
                  "^(){0}" +
                  subexp(
                    subexp(
                      "\\/\\/(" +
                        subexp("(" + USERINFO$ + ")@") +
                        "?(" +
                        HOST$ +
                        ")" +
                        subexp("\\:(" + PORT$ + ")") +
                        "?)"
                    ) +
                      "?(" +
                      PATH_ABEMPTY$ +
                      "|" +
                      PATH_ABSOLUTE$ +
                      "|" +
                      PATH_NOSCHEME$ +
                      "|" +
                      PATH_EMPTY$ +
                      ")"
                  ) +
                  subexp("\\?(" + QUERY$ + ")") +
                  "?" +
                  subexp("\\#(" + FRAGMENT$ + ")") +
                  "?$",
                ABSOLUTE_REF$ =
                  "^(" +
                  SCHEME$ +
                  ")\\:" +
                  subexp(
                    subexp(
                      "\\/\\/(" +
                        subexp("(" + USERINFO$ + ")@") +
                        "?(" +
                        HOST$ +
                        ")" +
                        subexp("\\:(" + PORT$ + ")") +
                        "?)"
                    ) +
                      "?(" +
                      PATH_ABEMPTY$ +
                      "|" +
                      PATH_ABSOLUTE$ +
                      "|" +
                      PATH_ROOTLESS$ +
                      "|" +
                      PATH_EMPTY$ +
                      ")"
                  ) +
                  subexp("\\?(" + QUERY$ + ")") +
                  "?$",
                SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
                AUTHORITY_REF$ =
                  "^" +
                  subexp("(" + USERINFO$ + ")@") +
                  "?(" +
                  HOST$ +
                  ")" +
                  subexp("\\:(" + PORT$ + ")") +
                  "?$";
              return {
                NOT_SCHEME: new RegExp(
                  merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"),
                  "g"
                ),
                NOT_USERINFO: new RegExp(
                  merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$),
                  "g"
                ),
                NOT_HOST: new RegExp(
                  merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$),
                  "g"
                ),
                NOT_PATH: new RegExp(
                  merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$),
                  "g"
                ),
                NOT_PATH_NOSCHEME: new RegExp(
                  merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$),
                  "g"
                ),
                NOT_QUERY: new RegExp(
                  merge(
                    "[^\\%]",
                    UNRESERVED$$,
                    SUB_DELIMS$$,
                    "[\\:\\@\\/\\?]",
                    IPRIVATE$$
                  ),
                  "g"
                ),
                NOT_FRAGMENT: new RegExp(
                  merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"),
                  "g"
                ),
                ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                UNRESERVED: new RegExp(UNRESERVED$$, "g"),
                OTHER_CHARS: new RegExp(
                  merge("[^\\%]", UNRESERVED$$, RESERVED$$),
                  "g"
                ),
                PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
                IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                IPV6ADDRESS: new RegExp(
                  "^\\[?(" +
                    IPV6ADDRESS$ +
                    ")" +
                    subexp(
                      subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") +
                        "(" +
                        ZONEID$ +
                        ")"
                    ) +
                    "?\\]?$"
                ) //RFC 6874, with relaxed parsing rules
              };
            }
            var URI_PROTOCOL = buildExps(false);
            var IRI_PROTOCOL = buildExps(true);
            var slicedToArray = (function () {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                  for (
                    var _i = arr[Symbol.iterator](), _s;
                    !(_n = (_s = _i.next()).done);
                    _n = true
                  ) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function (arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance"
                  );
                }
              };
            })();
            var toConsumableArray = function toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            };
            /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
            /** Bootstring parameters */ var base = 36;
            var tMin = 1;
            var tMax = 26;
            var skew = 38;
            var damp = 700;
            var initialBias = 72;
            var initialN = 128; // 0x80
            var delimiter = "-"; // '\x2D'
            /** Regular expressions */ var regexPunycode = /^xn--/;
            var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
            var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
            /** Error messages */ var errors = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            };
            /** Convenience shortcuts */ var baseMinusTMin = base - tMin;
            var floor = Math.floor;
            var stringFromCharCode = String.fromCharCode;
            /*--------------------------------------------------------------------------*/ /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */ function error$1(type) {
              throw new RangeError(errors[type]);
            }
            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */ function map(array, fn) {
              var result = [];
              var length = array.length;
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }
            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */ function mapDomain(string, fn) {
              var parts = string.split("@");
              var result = "";
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + "@";
                string = parts[1];
              } // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, "\x2E");
              var labels = string.split(".");
              var encoded = map(labels, fn).join(".");
              return result + encoded;
            }
            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */ function ucs2decode(string) {
              var output = [];
              var counter = 0;
              var length = string.length;
              while (counter < length) {
                var value = string.charCodeAt(counter++);
                if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                  // It's a high surrogate, and there is a next character.
                  var extra = string.charCodeAt(counter++);
                  if ((extra & 0xfc00) == 0xdc00) {
                    // Low surrogate.
                    output.push(
                      ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                    );
                  } else {
                    // It's an unmatched surrogate; only append this code unit, in case the
                    // next code unit is the high surrogate of a surrogate pair.
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */ var ucs2encode = function ucs2encode(array) {
              return String.fromCodePoint.apply(String, toConsumableArray(array));
            };
            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */ var basicToDigit = function basicToDigit(codePoint) {
              if (codePoint - 0x30 < 0x0a) {
                return codePoint - 0x16;
              }
              if (codePoint - 0x41 < 0x1a) {
                return codePoint - 0x41;
              }
              if (codePoint - 0x61 < 0x1a) {
                return codePoint - 0x61;
              }
              return base;
            };
            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */ var digitToBasic = function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            };
            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */ var adapt = function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (
                ;
                /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                k += base
              ) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
            };
            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */ var decode = function decode(input) {
              // Don't use UCS-2.
              var output = [];
              var inputLength = input.length;
              var i = 0;
              var n = initialN;
              var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.
              var basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (var j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error$1("not-basic");
                }
                output.push(input.charCodeAt(j));
              } // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.
              for (
                var index = basic > 0 ? basic + 1 : 0;
                index < inputLength;
  
              ) /* no final expression */ {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                var oldi = i;
                for (var w = 1, k = base; ; /* no condition */ k += base) {
                  if (index >= inputLength) {
                    error$1("invalid-input");
                  }
                  var digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error$1("overflow");
                  }
                  i += digit * w;
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (digit < t) {
                    break;
                  }
                  var baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error$1("overflow");
                  }
                  w *= baseMinusT;
                }
                var out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error$1("overflow");
                }
                n += floor(i / out);
                i %= out; // Insert `n` at position `i` of the output.
                output.splice(i++, 0, n);
              }
              return String.fromCodePoint.apply(String, output);
            };
            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */ var encode = function encode(input) {
              var output = []; // Convert the input in UCS-2 to an array of Unicode code points.
              input = ucs2decode(input); // Cache the length.
              var inputLength = input.length; // Initialize the state.
              var n = initialN;
              var delta = 0;
              var bias = initialBias; // Handle the basic code points.
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;
              try {
                for (
                  var _iterator = input[Symbol.iterator](), _step;
                  !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                  _iteratorNormalCompletion = true
                ) {
                  var _currentValue2 = _step.value;
                  if (_currentValue2 < 0x80) {
                    output.push(stringFromCharCode(_currentValue2));
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
              var basicLength = output.length;
              var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.
              // Finish the basic string with a delimiter unless it's empty.
              if (basicLength) {
                output.push(delimiter);
              } // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                var m = maxInt;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;
                try {
                  for (
                    var _iterator2 = input[Symbol.iterator](), _step2;
                    !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())
                      .done);
                    _iteratorNormalCompletion2 = true
                  ) {
                    var currentValue = _step2.value;
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                  // but guard against overflow.
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                      _iterator2["return"]();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
                var handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error$1("overflow");
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;
                try {
                  for (
                    var _iterator3 = input[Symbol.iterator](), _step3;
                    !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())
                      .done);
                    _iteratorNormalCompletion3 = true
                  ) {
                    var _currentValue = _step3.value;
                    if (_currentValue < n && ++delta > maxInt) {
                      error$1("overflow");
                    }
                    if (_currentValue == n) {
                      // Represent delta as a generalized variable-length integer.
                      var q = delta;
                      for (var k = base; ; /* no condition */ k += base) {
                        var t =
                          k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        var qMinusT = q - t;
                        var baseMinusT = base - t;
                        output.push(
                          stringFromCharCode(
                            digitToBasic(t + (qMinusT % baseMinusT), 0)
                          )
                        );
                        q = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(
                        delta,
                        handledCPCountPlusOne,
                        handledCPCount == basicLength
                      );
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
                      _iterator3["return"]();
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3;
                    }
                  }
                }
                ++delta;
                ++n;
              }
              return output.join("");
            };
            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */ var toUnicode = function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string)
                  ? decode(string.slice(4).toLowerCase())
                  : string;
              });
            };
            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */ var toASCII = function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string)
                  ? "xn--" + encode(string)
                  : string;
              });
            };
            /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode =
              {
                /**
                 * A string representing the current Punycode.js version number.
                 * @memberOf punycode
                 * @type String
                 */ version: "2.1.0",
                /**
                 * An object of methods to convert from JavaScript's internal character
                 * representation (UCS-2) to Unicode code points, and back.
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode
                 * @type Object
                 */ ucs2: { decode: ucs2decode, encode: ucs2encode },
                decode: decode,
                encode: encode,
                toASCII: toASCII,
                toUnicode: toUnicode
              };
            /**
             * URI.js
             *
             * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
             * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
             * @see http://github.com/garycourt/uri-js
             */ /**
             * Copyright 2011 Gary Court. All rights reserved.
             *
             * Redistribution and use in source and binary forms, with or without modification, are
             * permitted provided that the following conditions are met:
             *
             *    1. Redistributions of source code must retain the above copyright notice, this list of
             *       conditions and the following disclaimer.
             *
             *    2. Redistributions in binary form must reproduce the above copyright notice, this list
             *       of conditions and the following disclaimer in the documentation and/or other materials
             *       provided with the distribution.
             *
             * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
             * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
             * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
             * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
             * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
             * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
             * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
             * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             *
             * The views and conclusions contained in the software and documentation are those of the
             * authors and should not be interpreted as representing official policies, either expressed
             * or implied, of Gary Court.
             */ var SCHEMES = {};
            function pctEncChar(chr) {
              var c = chr.charCodeAt(0);
              var e = void 0;
              if (c < 16) e = "%0" + c.toString(16).toUpperCase();
              else if (c < 128) e = "%" + c.toString(16).toUpperCase();
              else if (c < 2048)
                e =
                  "%" +
                  ((c >> 6) | 192).toString(16).toUpperCase() +
                  "%" +
                  ((c & 63) | 128).toString(16).toUpperCase();
              else
                e =
                  "%" +
                  ((c >> 12) | 224).toString(16).toUpperCase() +
                  "%" +
                  (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
                  "%" +
                  ((c & 63) | 128).toString(16).toUpperCase();
              return e;
            }
            function pctDecChars(str) {
              var newStr = "";
              var i = 0;
              var il = str.length;
              while (i < il) {
                var c = parseInt(str.substr(i + 1, 2), 16);
                if (c < 128) {
                  newStr += String.fromCharCode(c);
                  i += 3;
                } else if (c >= 194 && c < 224) {
                  if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                  } else {
                    newStr += str.substr(i, 6);
                  }
                  i += 6;
                } else if (c >= 224) {
                  if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode(
                      ((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63)
                    );
                  } else {
                    newStr += str.substr(i, 9);
                  }
                  i += 9;
                } else {
                  newStr += str.substr(i, 3);
                  i += 3;
                }
              }
              return newStr;
            }
            function _normalizeComponentEncoding(components, protocol) {
              function decodeUnreserved(str) {
                var decStr = pctDecChars(str);
                return !decStr.match(protocol.UNRESERVED) ? str : decStr;
              }
              if (components.scheme)
                components.scheme = String(components.scheme)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .toLowerCase()
                  .replace(protocol.NOT_SCHEME, "");
              if (components.userinfo !== undefined)
                components.userinfo = String(components.userinfo)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .replace(protocol.NOT_USERINFO, pctEncChar)
                  .replace(protocol.PCT_ENCODED, toUpperCase);
              if (components.host !== undefined)
                components.host = String(components.host)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .toLowerCase()
                  .replace(protocol.NOT_HOST, pctEncChar)
                  .replace(protocol.PCT_ENCODED, toUpperCase);
              if (components.path !== undefined)
                components.path = String(components.path)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .replace(
                    components.scheme
                      ? protocol.NOT_PATH
                      : protocol.NOT_PATH_NOSCHEME,
                    pctEncChar
                  )
                  .replace(protocol.PCT_ENCODED, toUpperCase);
              if (components.query !== undefined)
                components.query = String(components.query)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .replace(protocol.NOT_QUERY, pctEncChar)
                  .replace(protocol.PCT_ENCODED, toUpperCase);
              if (components.fragment !== undefined)
                components.fragment = String(components.fragment)
                  .replace(protocol.PCT_ENCODED, decodeUnreserved)
                  .replace(protocol.NOT_FRAGMENT, pctEncChar)
                  .replace(protocol.PCT_ENCODED, toUpperCase);
              return components;
            }
            function _stripLeadingZeros(str) {
              return str.replace(/^0*(.*)/, "$1") || "0";
            }
            function _normalizeIPv4(host, protocol) {
              var matches = host.match(protocol.IPV4ADDRESS) || [];
              var _matches = slicedToArray(matches, 2),
                address = _matches[1];
              if (address) {
                return address.split(".").map(_stripLeadingZeros).join(".");
              } else {
                return host;
              }
            }
            function _normalizeIPv6(host, protocol) {
              var matches = host.match(protocol.IPV6ADDRESS) || [];
              var _matches2 = slicedToArray(matches, 3),
                address = _matches2[1],
                zone = _matches2[2];
              if (address) {
                var _address$toLowerCase$ = address
                    .toLowerCase()
                    .split("::")
                    .reverse(),
                  _address$toLowerCase$2 = slicedToArray(
                    _address$toLowerCase$,
                    2
                  ),
                  last = _address$toLowerCase$2[0],
                  first = _address$toLowerCase$2[1];
                var firstFields = first
                  ? first.split(":").map(_stripLeadingZeros)
                  : [];
                var lastFields = last.split(":").map(_stripLeadingZeros);
                var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(
                  lastFields[lastFields.length - 1]
                );
                var fieldCount = isLastFieldIPv4Address ? 7 : 8;
                var lastFieldsStart = lastFields.length - fieldCount;
                var fields = Array(fieldCount);
                for (var x = 0; x < fieldCount; ++x) {
                  fields[x] =
                    firstFields[x] || lastFields[lastFieldsStart + x] || "";
                }
                if (isLastFieldIPv4Address) {
                  fields[fieldCount - 1] = _normalizeIPv4(
                    fields[fieldCount - 1],
                    protocol
                  );
                }
                var allZeroFields = fields.reduce(function (acc, field, index) {
                  if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (
                      lastLongest &&
                      lastLongest.index + lastLongest.length === index
                    ) {
                      lastLongest.length++;
                    } else {
                      acc.push({ index: index, length: 1 });
                    }
                  }
                  return acc;
                }, []);
                var longestZeroFields = allZeroFields.sort(function (a, b) {
                  return b.length - a.length;
                })[0];
                var newHost = void 0;
                if (longestZeroFields && longestZeroFields.length > 1) {
                  var newFirst = fields.slice(0, longestZeroFields.index);
                  var newLast = fields.slice(
                    longestZeroFields.index + longestZeroFields.length
                  );
                  newHost = newFirst.join(":") + "::" + newLast.join(":");
                } else {
                  newHost = fields.join(":");
                }
                if (zone) {
                  newHost += "%" + zone;
                }
                return newHost;
              } else {
                return host;
              }
            }
            var URI_PARSE =
              /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
            var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
            function parse(uriString) {
              var options =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : {};
              var components = {};
              var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
              if (options.reference === "suffix")
                uriString =
                  (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
              var matches = uriString.match(URI_PARSE);
              if (matches) {
                if (NO_MATCH_IS_UNDEFINED) {
                  //store each component
                  components.scheme = matches[1];
                  components.userinfo = matches[3];
                  components.host = matches[4];
                  components.port = parseInt(matches[5], 10);
                  components.path = matches[6] || "";
                  components.query = matches[7];
                  components.fragment = matches[8]; //fix port number
                  if (isNaN(components.port)) {
                    components.port = matches[5];
                  }
                } else {
                  //IE FIX for improper RegExp matching
                  //store each component
                  components.scheme = matches[1] || undefined;
                  components.userinfo =
                    uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                  components.host =
                    uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                  components.port = parseInt(matches[5], 10);
                  components.path = matches[6] || "";
                  components.query =
                    uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                  components.fragment =
                    uriString.indexOf("#") !== -1 ? matches[8] : undefined; //fix port number
                  if (isNaN(components.port)) {
                    components.port = uriString.match(
                      /\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/
                    )
                      ? matches[4]
                      : undefined;
                  }
                }
                if (components.host) {
                  //normalize IP hosts
                  components.host = _normalizeIPv6(
                    _normalizeIPv4(components.host, protocol),
                    protocol
                  );
                } //determine reference type
                if (
                  components.scheme === undefined &&
                  components.userinfo === undefined &&
                  components.host === undefined &&
                  components.port === undefined &&
                  !components.path &&
                  components.query === undefined
                ) {
                  components.reference = "same-document";
                } else if (components.scheme === undefined) {
                  components.reference = "relative";
                } else if (components.fragment === undefined) {
                  components.reference = "absolute";
                } else {
                  components.reference = "uri";
                } //check for reference errors
                if (
                  options.reference &&
                  options.reference !== "suffix" &&
                  options.reference !== components.reference
                ) {
                  components.error =
                    components.error ||
                    "URI is not a " + options.reference + " reference.";
                } //find scheme handler
                var schemeHandler =
                  SCHEMES[
                    (options.scheme || components.scheme || "").toLowerCase()
                  ]; //check if scheme can't handle IRIs
                if (
                  !options.unicodeSupport &&
                  (!schemeHandler || !schemeHandler.unicodeSupport)
                ) {
                  //if host component is a domain name
                  if (
                    components.host &&
                    (options.domainHost ||
                      (schemeHandler && schemeHandler.domainHost))
                  ) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                      components.host = punycode.toASCII(
                        components.host
                          .replace(protocol.PCT_ENCODED, pctDecChars)
                          .toLowerCase()
                      );
                    } catch (e) {
                      components.error =
                        components.error ||
                        "Host's domain name can not be converted to ASCII via punycode: " +
                          e;
                    }
                  } //convert IRI -> URI
                  _normalizeComponentEncoding(components, URI_PROTOCOL);
                } else {
                  //normalize encodings
                  _normalizeComponentEncoding(components, protocol);
                } //perform scheme specific parsing
                if (schemeHandler && schemeHandler.parse) {
                  schemeHandler.parse(components, options);
                }
              } else {
                components.error = components.error || "URI can not be parsed.";
              }
              return components;
            }
            function _recomposeAuthority(components, options) {
              var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
              var uriTokens = [];
              if (components.userinfo !== undefined) {
                uriTokens.push(components.userinfo);
                uriTokens.push("@");
              }
              if (components.host !== undefined) {
                //normalize IP hosts, add brackets and escape zone separator for IPv6
                uriTokens.push(
                  _normalizeIPv6(
                    _normalizeIPv4(String(components.host), protocol),
                    protocol
                  ).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                    return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                  })
                );
              }
              if (
                typeof components.port === "number" ||
                typeof components.port === "string"
              ) {
                uriTokens.push(":");
                uriTokens.push(String(components.port));
              }
              return uriTokens.length ? uriTokens.join("") : undefined;
            }
            var RDS1 = /^\.\.?\//;
            var RDS2 = /^\/\.(\/|$)/;
            var RDS3 = /^\/\.\.(\/|$)/;
            var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
            function removeDotSegments(input) {
              var output = [];
              while (input.length) {
                if (input.match(RDS1)) {
                  input = input.replace(RDS1, "");
                } else if (input.match(RDS2)) {
                  input = input.replace(RDS2, "/");
                } else if (input.match(RDS3)) {
                  input = input.replace(RDS3, "/");
                  output.pop();
                } else if (input === "." || input === "..") {
                  input = "";
                } else {
                  var im = input.match(RDS5);
                  if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                  } else {
                    throw new Error("Unexpected dot segment condition");
                  }
                }
              }
              return output.join("");
            }
            function serialize(components) {
              var options =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : {};
              var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
              var uriTokens = []; //find scheme handler
              var schemeHandler =
                SCHEMES[
                  (options.scheme || components.scheme || "").toLowerCase()
                ]; //perform scheme specific serialization
              if (schemeHandler && schemeHandler.serialize)
                schemeHandler.serialize(components, options);
              if (components.host) {
                //if host component is an IPv6 address
                if (protocol.IPV6ADDRESS.test(components.host)) {
                } //TODO: normalize IPv6 address as per RFC 5952
                //if host component is a domain name
                else if (
                  options.domainHost ||
                  (schemeHandler && schemeHandler.domainHost)
                ) {
                  //convert IDN via punycode
                  try {
                    components.host = !options.iri
                      ? punycode.toASCII(
                          components.host
                            .replace(protocol.PCT_ENCODED, pctDecChars)
                            .toLowerCase()
                        )
                      : punycode.toUnicode(components.host);
                  } catch (e) {
                    components.error =
                      components.error ||
                      "Host's domain name can not be converted to " +
                        (!options.iri ? "ASCII" : "Unicode") +
                        " via punycode: " +
                        e;
                  }
                }
              } //normalize encoding
              _normalizeComponentEncoding(components, protocol);
              if (options.reference !== "suffix" && components.scheme) {
                uriTokens.push(components.scheme);
                uriTokens.push(":");
              }
              var authority = _recomposeAuthority(components, options);
              if (authority !== undefined) {
                if (options.reference !== "suffix") {
                  uriTokens.push("//");
                }
                uriTokens.push(authority);
                if (components.path && components.path.charAt(0) !== "/") {
                  uriTokens.push("/");
                }
              }
              if (components.path !== undefined) {
                var s = components.path;
                if (
                  !options.absolutePath &&
                  (!schemeHandler || !schemeHandler.absolutePath)
                ) {
                  s = removeDotSegments(s);
                }
                if (authority === undefined) {
                  s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
                }
                uriTokens.push(s);
              }
              if (components.query !== undefined) {
                uriTokens.push("?");
                uriTokens.push(components.query);
              }
              if (components.fragment !== undefined) {
                uriTokens.push("#");
                uriTokens.push(components.fragment);
              }
              return uriTokens.join(""); //merge tokens into a string
            }
            function resolveComponents(base, relative) {
              var options =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {};
              var skipNormalization = arguments[3];
              var target = {};
              if (!skipNormalization) {
                base = parse(serialize(base, options), options); //normalize base components
                relative = parse(serialize(relative, options), options); //normalize relative components
              }
              options = options || {};
              if (!options.tolerant && relative.scheme) {
                target.scheme = relative.scheme; //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
              } else {
                if (
                  relative.userinfo !== undefined ||
                  relative.host !== undefined ||
                  relative.port !== undefined
                ) {
                  //target.authority = relative.authority;
                  target.userinfo = relative.userinfo;
                  target.host = relative.host;
                  target.port = relative.port;
                  target.path = removeDotSegments(relative.path || "");
                  target.query = relative.query;
                } else {
                  if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) {
                      target.query = relative.query;
                    } else {
                      target.query = base.query;
                    }
                  } else {
                    if (relative.path.charAt(0) === "/") {
                      target.path = removeDotSegments(relative.path);
                    } else {
                      if (
                        (base.userinfo !== undefined ||
                          base.host !== undefined ||
                          base.port !== undefined) &&
                        !base.path
                      ) {
                        target.path = "/" + relative.path;
                      } else if (!base.path) {
                        target.path = relative.path;
                      } else {
                        target.path =
                          base.path.slice(0, base.path.lastIndexOf("/") + 1) +
                          relative.path;
                      }
                      target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                  } //target.authority = base.authority;
                  target.userinfo = base.userinfo;
                  target.host = base.host;
                  target.port = base.port;
                }
                target.scheme = base.scheme;
              }
              target.fragment = relative.fragment;
              return target;
            }
            function resolve(baseURI, relativeURI, options) {
              var schemelessOptions = assign({ scheme: "null" }, options);
              return serialize(
                resolveComponents(
                  parse(baseURI, schemelessOptions),
                  parse(relativeURI, schemelessOptions),
                  schemelessOptions,
                  true
                ),
                schemelessOptions
              );
            }
            function normalize(uri, options) {
              if (typeof uri === "string") {
                uri = serialize(parse(uri, options), options);
              } else if (typeOf(uri) === "object") {
                uri = parse(serialize(uri, options), options);
              }
              return uri;
            }
            function equal(uriA, uriB, options) {
              if (typeof uriA === "string") {
                uriA = serialize(parse(uriA, options), options);
              } else if (typeOf(uriA) === "object") {
                uriA = serialize(uriA, options);
              }
              if (typeof uriB === "string") {
                uriB = serialize(parse(uriB, options), options);
              } else if (typeOf(uriB) === "object") {
                uriB = serialize(uriB, options);
              }
              return uriA === uriB;
            }
            function escapeComponent(str, options) {
              return (
                str &&
                str
                  .toString()
                  .replace(
                    !options || !options.iri
                      ? URI_PROTOCOL.ESCAPE
                      : IRI_PROTOCOL.ESCAPE,
                    pctEncChar
                  )
              );
            }
            function unescapeComponent(str, options) {
              return (
                str &&
                str
                  .toString()
                  .replace(
                    !options || !options.iri
                      ? URI_PROTOCOL.PCT_ENCODED
                      : IRI_PROTOCOL.PCT_ENCODED,
                    pctDecChars
                  )
              );
            }
            var handler = {
              scheme: "http",
              domainHost: true,
              parse: function parse(components, options) {
                //report missing host
                if (!components.host) {
                  components.error =
                    components.error || "HTTP URIs must have a host.";
                }
                return components;
              },
              serialize: function serialize(components, options) {
                var secure = String(components.scheme).toLowerCase() === "https"; //normalize the default port
                if (
                  components.port === (secure ? 443 : 80) ||
                  components.port === ""
                ) {
                  components.port = undefined;
                } //normalize the empty path
                if (!components.path) {
                  components.path = "/";
                } //NOTE: We do not parse query strings for HTTP URIs
                //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
                //and not the HTTP spec.
                return components;
              }
            };
            var handler$1 = {
              scheme: "https",
              domainHost: handler.domainHost,
              parse: handler.parse,
              serialize: handler.serialize
            };
            function isSecure(wsComponents) {
              return typeof wsComponents.secure === "boolean"
                ? wsComponents.secure
                : String(wsComponents.scheme).toLowerCase() === "wss";
            } //RFC 6455
            var handler$2 = {
              scheme: "ws",
              domainHost: true,
              parse: function parse(components, options) {
                var wsComponents = components; //indicate if the secure flag is set
                wsComponents.secure = isSecure(wsComponents); //construct resouce name
                wsComponents.resourceName =
                  (wsComponents.path || "/") +
                  (wsComponents.query ? "?" + wsComponents.query : "");
                wsComponents.path = undefined;
                wsComponents.query = undefined;
                return wsComponents;
              },
              serialize: function serialize(wsComponents, options) {
                //normalize the default port
                if (
                  wsComponents.port === (isSecure(wsComponents) ? 443 : 80) ||
                  wsComponents.port === ""
                ) {
                  wsComponents.port = undefined;
                } //ensure scheme matches secure flag
                if (typeof wsComponents.secure === "boolean") {
                  wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
                  wsComponents.secure = undefined;
                } //reconstruct path from resource name
                if (wsComponents.resourceName) {
                  var _wsComponents$resourc =
                      wsComponents.resourceName.split("?"),
                    _wsComponents$resourc2 = slicedToArray(
                      _wsComponents$resourc,
                      2
                    ),
                    path = _wsComponents$resourc2[0],
                    query = _wsComponents$resourc2[1];
                  wsComponents.path = path && path !== "/" ? path : undefined;
                  wsComponents.query = query;
                  wsComponents.resourceName = undefined;
                } //forbid fragment component
                wsComponents.fragment = undefined;
                return wsComponents;
              }
            };
            var handler$3 = {
              scheme: "wss",
              domainHost: handler$2.domainHost,
              parse: handler$2.parse,
              serialize: handler$2.serialize
            };
            var O = {};
            var isIRI = true; //RFC 3986
            var UNRESERVED$$ =
              "[A-Za-z0-9\\-\\.\\_\\~" +
              (isIRI
                ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF"
                : "") +
              "]";
            var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
            var PCT_ENCODED$ = subexp(
              subexp(
                "%[EFef]" +
                  HEXDIG$$ +
                  "%" +
                  HEXDIG$$ +
                  HEXDIG$$ +
                  "%" +
                  HEXDIG$$ +
                  HEXDIG$$
              ) +
                "|" +
                subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) +
                "|" +
                subexp("%" + HEXDIG$$ + HEXDIG$$)
            ); //expanded
            //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
            //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
            //const WSP$$ = "[\\x20\\x09]";
            //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
            //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
            //const VCHAR$$ = "[\\x21-\\x7E]";
            //const WSP$$ = "[\\x20\\x09]";
            //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
            //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
            //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
            //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
            var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
            var QTEXT$$ =
              "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
            var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
            var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
            var UNRESERVED = new RegExp(UNRESERVED$$, "g");
            var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
            var NOT_LOCAL_PART = new RegExp(
              merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$),
              "g"
            );
            var NOT_HFNAME = new RegExp(
              merge("[^]", UNRESERVED$$, SOME_DELIMS$$),
              "g"
            );
            var NOT_HFVALUE = NOT_HFNAME;
            function decodeUnreserved(str) {
              var decStr = pctDecChars(str);
              return !decStr.match(UNRESERVED) ? str : decStr;
            }
            var handler$4 = {
              scheme: "mailto",
              parse: function parse$$1(components, options) {
                var mailtoComponents = components;
                var to = (mailtoComponents.to = mailtoComponents.path
                  ? mailtoComponents.path.split(",")
                  : []);
                mailtoComponents.path = undefined;
                if (mailtoComponents.query) {
                  var unknownHeaders = false;
                  var headers = {};
                  var hfields = mailtoComponents.query.split("&");
                  for (var x = 0, xl = hfields.length; x < xl; ++x) {
                    var hfield = hfields[x].split("=");
                    switch (hfield[0]) {
                      case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                          to.push(toAddrs[_x]);
                        }
                        break;
                      case "subject":
                        mailtoComponents.subject = unescapeComponent(
                          hfield[1],
                          options
                        );
                        break;
                      case "body":
                        mailtoComponents.body = unescapeComponent(
                          hfield[1],
                          options
                        );
                        break;
                      default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] =
                          unescapeComponent(hfield[1], options);
                        break;
                    }
                  }
                  if (unknownHeaders) mailtoComponents.headers = headers;
                }
                mailtoComponents.query = undefined;
                for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                  var addr = to[_x2].split("@");
                  addr[0] = unescapeComponent(addr[0]);
                  if (!options.unicodeSupport) {
                    //convert Unicode IDN -> ASCII IDN
                    try {
                      addr[1] = punycode.toASCII(
                        unescapeComponent(addr[1], options).toLowerCase()
                      );
                    } catch (e) {
                      mailtoComponents.error =
                        mailtoComponents.error ||
                        "Email address's domain name can not be converted to ASCII via punycode: " +
                          e;
                    }
                  } else {
                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                  }
                  to[_x2] = addr.join("@");
                }
                return mailtoComponents;
              },
              serialize: function serialize$$1(mailtoComponents, options) {
                var components = mailtoComponents;
                var to = toArray(mailtoComponents.to);
                if (to) {
                  for (var x = 0, xl = to.length; x < xl; ++x) {
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr
                      .slice(0, atIdx)
                      .replace(PCT_ENCODED, decodeUnreserved)
                      .replace(PCT_ENCODED, toUpperCase)
                      .replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode
                    try {
                      domain = !options.iri
                        ? punycode.toASCII(
                            unescapeComponent(domain, options).toLowerCase()
                          )
                        : punycode.toUnicode(domain);
                    } catch (e) {
                      components.error =
                        components.error ||
                        "Email address's domain name can not be converted to " +
                          (!options.iri ? "ASCII" : "Unicode") +
                          " via punycode: " +
                          e;
                    }
                    to[x] = localPart + "@" + domain;
                  }
                  components.path = to.join(",");
                }
                var headers = (mailtoComponents.headers =
                  mailtoComponents.headers || {});
                if (mailtoComponents.subject)
                  headers["subject"] = mailtoComponents.subject;
                if (mailtoComponents.body)
                  headers["body"] = mailtoComponents.body;
                var fields = [];
                for (var name in headers) {
                  if (headers[name] !== O[name]) {
                    fields.push(
                      name
                        .replace(PCT_ENCODED, decodeUnreserved)
                        .replace(PCT_ENCODED, toUpperCase)
                        .replace(NOT_HFNAME, pctEncChar) +
                        "=" +
                        headers[name]
                          .replace(PCT_ENCODED, decodeUnreserved)
                          .replace(PCT_ENCODED, toUpperCase)
                          .replace(NOT_HFVALUE, pctEncChar)
                    );
                  }
                }
                if (fields.length) {
                  components.query = fields.join("&");
                }
                return components;
              }
            };
            var URN_PARSE = /^([^\:]+)\:(.*)/; //RFC 2141
            var handler$5 = {
              scheme: "urn",
              parse: function parse$$1(components, options) {
                var matches = components.path && components.path.match(URN_PARSE);
                var urnComponents = components;
                if (matches) {
                  var scheme = options.scheme || urnComponents.scheme || "urn";
                  var nid = matches[1].toLowerCase();
                  var nss = matches[2];
                  var urnScheme = scheme + ":" + (options.nid || nid);
                  var schemeHandler = SCHEMES[urnScheme];
                  urnComponents.nid = nid;
                  urnComponents.nss = nss;
                  urnComponents.path = undefined;
                  if (schemeHandler) {
                    urnComponents = schemeHandler.parse(urnComponents, options);
                  }
                } else {
                  urnComponents.error =
                    urnComponents.error || "URN can not be parsed.";
                }
                return urnComponents;
              },
              serialize: function serialize$$1(urnComponents, options) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = urnComponents.nid;
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                if (schemeHandler) {
                  urnComponents = schemeHandler.serialize(urnComponents, options);
                }
                var uriComponents = urnComponents;
                var nss = urnComponents.nss;
                uriComponents.path = (nid || options.nid) + ":" + nss;
                return uriComponents;
              }
            };
            var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/; //RFC 4122
            var handler$6 = {
              scheme: "urn:uuid",
              parse: function parse(urnComponents, options) {
                var uuidComponents = urnComponents;
                uuidComponents.uuid = uuidComponents.nss;
                uuidComponents.nss = undefined;
                if (
                  !options.tolerant &&
                  (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))
                ) {
                  uuidComponents.error =
                    uuidComponents.error || "UUID is not valid.";
                }
                return uuidComponents;
              },
              serialize: function serialize(uuidComponents, options) {
                var urnComponents = uuidComponents; //normalize UUID
                urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
                return urnComponents;
              }
            };
            SCHEMES[handler.scheme] = handler;
            SCHEMES[handler$1.scheme] = handler$1;
            SCHEMES[handler$2.scheme] = handler$2;
            SCHEMES[handler$3.scheme] = handler$3;
            SCHEMES[handler$4.scheme] = handler$4;
            SCHEMES[handler$5.scheme] = handler$5;
            SCHEMES[handler$6.scheme] = handler$6;
            exports.SCHEMES = SCHEMES;
            exports.pctEncChar = pctEncChar;
            exports.pctDecChars = pctDecChars;
            exports.parse = parse;
            exports.removeDotSegments = removeDotSegments;
            exports.serialize = serialize;
            exports.resolveComponents = resolveComponents;
            exports.resolve = resolve;
            exports.normalize = normalize;
            exports.equal = equal;
            exports.escapeComponent = escapeComponent;
            exports.unescapeComponent = unescapeComponent;
            Object.defineProperty(exports, "__esModule", { value: true });
          });
        },
        {}
      ],
      190: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          function isNothing(subject) {
            return typeof subject === "undefined" || null === subject;
          }
          exports.isNothing = isNothing;
          function isObject(subject) {
            return _typeof2(subject) === "object" && null !== subject;
          }
          exports.isObject = isObject;
          function toArray(sequence) {
            if (Array.isArray(sequence)) {
              return sequence;
            } else if (isNothing(sequence)) {
              return [];
            }
            return [sequence];
          }
          exports.toArray = toArray;
          function extend(target, source) {
            var index, length, key, sourceKeys;
            if (source) {
              sourceKeys = Object.keys(source);
              for (
                index = 0, length = sourceKeys.length;
                index < length;
                index += 1
              ) {
                key = sourceKeys[index];
                target[key] = source[key];
              }
            }
            return target;
          }
          exports.extend = extend;
          function repeat(string, count) {
            var result = "",
              cycle;
            for (cycle = 0; cycle < count; cycle += 1) {
              result += string;
            }
            return result;
          }
          exports.repeat = repeat;
          function isNegativeZero(number) {
            return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
          }
          exports.isNegativeZero = isNegativeZero;
        },
        {}
      ],
      191: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var common = require("./common");
          var YAMLException = require("./exception");
          var DEFAULT_FULL_SCHEMA = require("./schema/default_full");
          var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");
          var _toString = Object.prototype.toString;
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CHAR_TAB = 0x09;
          var CHAR_LINE_FEED = 0x0a;
          var CHAR_CARRIAGE_RETURN = 0x0d;
          var CHAR_SPACE = 0x20;
          var CHAR_EXCLAMATION = 0x21;
          var CHAR_DOUBLE_QUOTE = 0x22;
          var CHAR_SHARP = 0x23;
          var CHAR_PERCENT = 0x25;
          var CHAR_AMPERSAND = 0x26;
          var CHAR_SINGLE_QUOTE = 0x27;
          var CHAR_ASTERISK = 0x2a;
          var CHAR_COMMA = 0x2c;
          var CHAR_MINUS = 0x2d;
          var CHAR_COLON = 0x3a;
          var CHAR_GREATER_THAN = 0x3e;
          var CHAR_QUESTION = 0x3f;
          var CHAR_COMMERCIAL_AT = 0x40;
          var CHAR_LEFT_SQUARE_BRACKET = 0x5b;
          var CHAR_RIGHT_SQUARE_BRACKET = 0x5d;
          var CHAR_GRAVE_ACCENT = 0x60;
          var CHAR_LEFT_CURLY_BRACKET = 0x7b;
          var CHAR_VERTICAL_LINE = 0x7c;
          var CHAR_RIGHT_CURLY_BRACKET = 0x7d;
          var ESCAPE_SEQUENCES = {};
          ESCAPE_SEQUENCES[0x00] = "\\0";
          ESCAPE_SEQUENCES[0x07] = "\\a";
          ESCAPE_SEQUENCES[0x08] = "\\b";
          ESCAPE_SEQUENCES[0x09] = "\\t";
          ESCAPE_SEQUENCES[0x0a] = "\\n";
          ESCAPE_SEQUENCES[0x0b] = "\\v";
          ESCAPE_SEQUENCES[0x0c] = "\\f";
          ESCAPE_SEQUENCES[0x0d] = "\\r";
          ESCAPE_SEQUENCES[0x1b] = "\\e";
          ESCAPE_SEQUENCES[0x22] = '\\"';
          ESCAPE_SEQUENCES[0x5c] = "\\\\";
          ESCAPE_SEQUENCES[0x85] = "\\N";
          ESCAPE_SEQUENCES[0xa0] = "\\_";
          ESCAPE_SEQUENCES[0x2028] = "\\L";
          ESCAPE_SEQUENCES[0x2029] = "\\P";
          var DEPRECATED_BOOLEANS_SYNTAX = [
            "y",
            "Y",
            "yes",
            "Yes",
            "YES",
            "on",
            "On",
            "ON",
            "n",
            "N",
            "no",
            "No",
            "NO",
            "off",
            "Off",
            "OFF"
          ];
          function compileStyleMap(schema, map) {
            var result, keys, index, length, tag, style, type;
            if (null === map) {
              return {};
            }
            result = {};
            keys = Object.keys(map);
            for (index = 0, length = keys.length; index < length; index += 1) {
              tag = keys[index];
              style = String(map[tag]);
              if ("!!" === tag.slice(0, 2)) {
                tag = "tag:yaml.org,2002:" + tag.slice(2);
              }
              type = schema.compiledTypeMap[tag];
              if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                style = type.styleAliases[style];
              }
              result[tag] = style;
            }
            return result;
          }
          function encodeHex(character) {
            var string, handle, length;
            string = character.toString(16).toUpperCase();
            if (character <= 0xff) {
              handle = "x";
              length = 2;
            } else if (character <= 0xffff) {
              handle = "u";
              length = 4;
            } else if (character <= 0xffffffff) {
              handle = "U";
              length = 8;
            } else {
              throw new YAMLException(
                "code point within a string may not be greater than 0xFFFFFFFF"
              );
            }
            return (
              "\\" + handle + common.repeat("0", length - string.length) + string
            );
          }
          function State(options) {
            this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
            this.indent = Math.max(1, options["indent"] || 2);
            this.skipInvalid = options["skipInvalid"] || false;
            this.flowLevel = common.isNothing(options["flowLevel"])
              ? -1
              : options["flowLevel"];
            this.styleMap = compileStyleMap(
              this.schema,
              options["styles"] || null
            );
            this.implicitTypes = this.schema.compiledImplicit;
            this.explicitTypes = this.schema.compiledExplicit;
            this.tag = null;
            this.result = "";
            this.duplicates = [];
            this.usedDuplicates = null;
          }
          function indentString(string, spaces) {
            var ind = common.repeat(" ", spaces),
              position = 0,
              next = -1,
              result = "",
              line,
              length = string.length;
            while (position < length) {
              next = string.indexOf("\n", position);
              if (next === -1) {
                line = string.slice(position);
                position = length;
              } else {
                line = string.slice(position, next + 1);
                position = next + 1;
              }
              if (line.length && line !== "\n") {
                result += ind;
              }
              result += line;
            }
            return result;
          }
          function generateNextLine(state, level) {
            return "\n" + common.repeat(" ", state.indent * level);
          }
          function testImplicitResolving(state, str) {
            var index, length, type;
            for (
              index = 0, length = state.implicitTypes.length;
              index < length;
              index += 1
            ) {
              type = state.implicitTypes[index];
              if (type.resolve(str)) {
                return true;
              }
            }
            return false;
          }
          function StringBuilder(source) {
            this.source = source;
            this.result = "";
            this.checkpoint = 0;
          }
          StringBuilder.prototype.takeUpTo = function (position) {
            var er;
            if (position < this.checkpoint) {
              er = new Error("position should be > checkpoint");
              er.position = position;
              er.checkpoint = this.checkpoint;
              throw er;
            }
            this.result += this.source.slice(this.checkpoint, position);
            this.checkpoint = position;
            return this;
          };
          StringBuilder.prototype.escapeChar = function () {
            var character, esc;
            character = this.source.charCodeAt(this.checkpoint);
            esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
            this.result += esc;
            this.checkpoint += 1;
            return this;
          };
          StringBuilder.prototype.finish = function () {
            if (this.source.length > this.checkpoint) {
              this.takeUpTo(this.source.length);
            }
          };
          function writeScalar(state, object, level) {
            var simple,
              first,
              spaceWrap,
              folded,
              literal,
              single,
              _double,
              sawLineFeed,
              linePosition,
              longestLine,
              indent,
              max,
              character,
              position,
              escapeSeq,
              hexEsc,
              previous,
              lineLength,
              modifier,
              trailingLineBreaks,
              result;
            if (0 === object.length) {
              state.dump = "''";
              return;
            }
            if (object.indexOf("!include") == 0) {
              state.dump = "" + object;
              return;
            }
            if (object.indexOf("!$$$novalue") == 0) {
              state.dump = "";
              return;
            }
            if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
              state.dump = "'" + object + "'";
              return;
            }
            simple = true;
            first = object.length ? object.charCodeAt(0) : 0;
            spaceWrap =
              CHAR_SPACE === first ||
              CHAR_SPACE === object.charCodeAt(object.length - 1);
            if (
              CHAR_MINUS === first ||
              CHAR_QUESTION === first ||
              CHAR_COMMERCIAL_AT === first ||
              CHAR_GRAVE_ACCENT === first
            ) {
              simple = false;
            }
            if (spaceWrap) {
              simple = false;
              folded = false;
              literal = false;
            } else {
              folded = true;
              literal = true;
            }
            single = true;
            _double = new StringBuilder(object);
            sawLineFeed = false;
            linePosition = 0;
            longestLine = 0;
            indent = state.indent * level;
            max = 80;
            if (indent < 40) {
              max -= indent;
            } else {
              max = 40;
            }
            for (position = 0; position < object.length; position++) {
              character = object.charCodeAt(position);
              if (simple) {
                if (!simpleChar(character)) {
                  simple = false;
                } else {
                  continue;
                }
              }
              if (single && character === CHAR_SINGLE_QUOTE) {
                single = false;
              }
              escapeSeq = ESCAPE_SEQUENCES[character];
              hexEsc = needsHexEscape(character);
              if (!escapeSeq && !hexEsc) {
                continue;
              }
              if (
                character !== CHAR_LINE_FEED &&
                character !== CHAR_DOUBLE_QUOTE &&
                character !== CHAR_SINGLE_QUOTE
              ) {
                folded = false;
                literal = false;
              } else if (character === CHAR_LINE_FEED) {
                sawLineFeed = true;
                single = false;
                if (position > 0) {
                  previous = object.charCodeAt(position - 1);
                  if (previous === CHAR_SPACE) {
                    literal = false;
                    folded = false;
                  }
                }
                if (folded) {
                  lineLength = position - linePosition;
                  linePosition = position;
                  if (lineLength > longestLine) {
                    longestLine = lineLength;
                  }
                }
              }
              if (character !== CHAR_DOUBLE_QUOTE) {
                single = false;
              }
              _double.takeUpTo(position);
              _double.escapeChar();
            }
            if (simple && testImplicitResolving(state, object)) {
              simple = false;
            }
            modifier = "";
            if (folded || literal) {
              trailingLineBreaks = 0;
              if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
                trailingLineBreaks += 1;
                if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
                  trailingLineBreaks += 1;
                }
              }
              if (trailingLineBreaks === 0) {
                modifier = "-";
              } else if (trailingLineBreaks === 2) {
                modifier = "+";
              }
            }
            if (literal && longestLine < max) {
              folded = false;
            }
            if (!sawLineFeed) {
              literal = false;
            }
            if (simple) {
              state.dump = object;
            } else if (single) {
              state.dump = "'" + object + "'";
            } else if (folded) {
              result = fold(object, max);
              state.dump = ">" + modifier + "\n" + indentString(result, indent);
            } else if (literal) {
              if (!modifier) {
                object = object.replace(/\n$/, "");
              }
              state.dump = "|" + modifier + "\n" + indentString(object, indent);
            } else if (_double) {
              _double.finish();
              state.dump = '"' + _double.result + '"';
            } else {
              throw new Error("Failed to dump scalar value");
            }
            return;
          }
          function fold(object, max) {
            var result = "",
              position = 0,
              length = object.length,
              trailing = /\n+$/.exec(object),
              newLine;
            if (trailing) {
              length = trailing.index + 1;
            }
            while (position < length) {
              newLine = object.indexOf("\n", position);
              if (newLine > length || newLine === -1) {
                if (result) {
                  result += "\n\n";
                }
                result += foldLine(object.slice(position, length), max);
                position = length;
              } else {
                if (result) {
                  result += "\n\n";
                }
                result += foldLine(object.slice(position, newLine), max);
                position = newLine + 1;
              }
            }
            if (trailing && trailing[0] !== "\n") {
              result += trailing[0];
            }
            return result;
          }
          function foldLine(line, max) {
            if (line === "") {
              return line;
            }
            var foldRe = /[^\s] [^\s]/g,
              result = "",
              prevMatch = 0,
              foldStart = 0,
              match = foldRe.exec(line),
              index,
              foldEnd,
              folded;
            while (match) {
              index = match.index;
              if (index - foldStart > max) {
                if (prevMatch !== foldStart) {
                  foldEnd = prevMatch;
                } else {
                  foldEnd = index;
                }
                if (result) {
                  result += "\n";
                }
                folded = line.slice(foldStart, foldEnd);
                result += folded;
                foldStart = foldEnd + 1;
              }
              prevMatch = index + 1;
              match = foldRe.exec(line);
            }
            if (result) {
              result += "\n";
            }
            if (foldStart !== prevMatch && line.length - foldStart > max) {
              result +=
                line.slice(foldStart, prevMatch) +
                "\n" +
                line.slice(prevMatch + 1);
            } else {
              result += line.slice(foldStart);
            }
            return result;
          }
          function simpleChar(character) {
            return (
              CHAR_TAB !== character &&
              CHAR_LINE_FEED !== character &&
              CHAR_CARRIAGE_RETURN !== character &&
              CHAR_COMMA !== character &&
              CHAR_LEFT_SQUARE_BRACKET !== character &&
              CHAR_RIGHT_SQUARE_BRACKET !== character &&
              CHAR_LEFT_CURLY_BRACKET !== character &&
              CHAR_RIGHT_CURLY_BRACKET !== character &&
              CHAR_SHARP !== character &&
              CHAR_AMPERSAND !== character &&
              CHAR_ASTERISK !== character &&
              CHAR_EXCLAMATION !== character &&
              CHAR_VERTICAL_LINE !== character &&
              CHAR_GREATER_THAN !== character &&
              CHAR_SINGLE_QUOTE !== character &&
              CHAR_DOUBLE_QUOTE !== character &&
              CHAR_PERCENT !== character &&
              CHAR_COLON !== character &&
              !ESCAPE_SEQUENCES[character] &&
              !needsHexEscape(character)
            );
          }
          function needsHexEscape(character) {
            return !(
              (0x00020 <= character && character <= 0x00007e) ||
              0x00085 === character ||
              (0x000a0 <= character && character <= 0x00d7ff) ||
              (0x0e000 <= character && character <= 0x00fffd) ||
              (0x10000 <= character && character <= 0x10ffff)
            );
          }
          function writeFlowSequence(state, level, object) {
            var _result = "",
              _tag = state.tag,
              index,
              length;
            for (index = 0, length = object.length; index < length; index += 1) {
              if (writeNode(state, level, object[index], false, false)) {
                if (0 !== index) {
                  _result += ", ";
                }
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = "[" + _result + "]";
          }
          function writeBlockSequence(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              index,
              length;
            for (index = 0, length = object.length; index < length; index += 1) {
              if (writeNode(state, level + 1, object[index], true, true)) {
                if (!compact || 0 !== index) {
                  _result += generateNextLine(state, level);
                }
                _result += "- " + state.dump;
              }
            }
            state.tag = _tag;
            state.dump = _result || "[]";
          }
          function writeFlowMapping(state, level, object) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              pairBuffer;
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (0 !== index) {
                pairBuffer += ", ";
              }
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (!writeNode(state, level, objectKey, false, false)) {
                continue;
              }
              if (state.dump.length > 1024) {
                pairBuffer += "? ";
              }
              pairBuffer += state.dump + ": ";
              if (!writeNode(state, level, objectValue, false, false)) {
                continue;
              }
              pairBuffer += state.dump;
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = "{" + _result + "}";
          }
          function writeBlockMapping(state, level, object, compact) {
            var _result = "",
              _tag = state.tag,
              objectKeyList = Object.keys(object),
              index,
              length,
              objectKey,
              objectValue,
              explicitPair,
              pairBuffer;
            for (
              index = 0, length = objectKeyList.length;
              index < length;
              index += 1
            ) {
              pairBuffer = "";
              if (!compact || 0 !== index) {
                pairBuffer += generateNextLine(state, level);
              }
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (!writeNode(state, level + 1, objectKey, true, true)) {
                continue;
              }
              explicitPair =
                (null !== state.tag && "?" !== state.tag) ||
                (state.dump && state.dump.length > 1024);
              if (explicitPair) {
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += "?";
                } else {
                  pairBuffer += "? ";
                }
              }
              pairBuffer += state.dump;
              if (explicitPair) {
                pairBuffer += generateNextLine(state, level);
              }
              if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                continue;
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += ":";
              } else {
                pairBuffer += ": ";
              }
              pairBuffer += state.dump;
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = _result || "{}";
          }
          function detectType(state, object, explicit) {
            var _result, typeList, index, length, type, style;
            typeList = explicit ? state.explicitTypes : state.implicitTypes;
            for (
              index = 0, length = typeList.length;
              index < length;
              index += 1
            ) {
              type = typeList[index];
              if (
                (type.instanceOf || type.predicate) &&
                (!type.instanceOf ||
                  ("object" === _typeof2(object) &&
                    object instanceof type.instanceOf)) &&
                (!type.predicate || type.predicate(object))
              ) {
                state.tag = explicit ? type.tag : "?";
                if (type.represent) {
                  style = state.styleMap[type.tag] || type.defaultStyle;
                  if ("[object Function]" === _toString.call(type.represent)) {
                    _result = type.represent(object, style);
                  } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                  } else {
                    throw new YAMLException(
                      "!<" +
                        type.tag +
                        '> tag resolver accepts not "' +
                        style +
                        '" style'
                    );
                  }
                  state.dump = _result;
                }
                return true;
              }
            }
            return false;
          }
          function writeNode(state, level, object, block, compact) {
            state.tag = null;
            state.dump = object;
            if (!detectType(state, object, false)) {
              detectType(state, object, true);
            }
            var type = _toString.call(state.dump);
            if (block) {
              block = 0 > state.flowLevel || state.flowLevel > level;
            }
            if (
              (null !== state.tag && "?" !== state.tag) ||
              (2 !== state.indent && level > 0)
            ) {
              compact = false;
            }
            var objectOrArray =
                "[object Object]" === type || "[object Array]" === type,
              duplicateIndex,
              duplicate;
            if (objectOrArray) {
              duplicateIndex = state.duplicates.indexOf(object);
              duplicate = duplicateIndex !== -1;
            }
            if (duplicate && state.usedDuplicates[duplicateIndex]) {
              state.dump = "*ref_" + duplicateIndex;
            } else {
              if (
                objectOrArray &&
                duplicate &&
                !state.usedDuplicates[duplicateIndex]
              ) {
                state.usedDuplicates[duplicateIndex] = true;
              }
              if ("[object Object]" === type) {
                if (block && 0 !== Object.keys(state.dump).length) {
                  writeBlockMapping(state, level, state.dump, compact);
                  if (duplicate) {
                    state.dump =
                      "&ref_" +
                      duplicateIndex +
                      (0 === level ? "\n" : "") +
                      state.dump;
                  }
                } else {
                  writeFlowMapping(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if ("[object Array]" === type) {
                if (block && 0 !== state.dump.length) {
                  writeBlockSequence(state, level, state.dump, compact);
                  if (duplicate) {
                    state.dump =
                      "&ref_" +
                      duplicateIndex +
                      (0 === level ? "\n" : "") +
                      state.dump;
                  }
                } else {
                  writeFlowSequence(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if ("[object String]" === type) {
                if ("?" !== state.tag) {
                  writeScalar(state, state.dump, level);
                }
              } else {
                if (state.skipInvalid) {
                  return false;
                }
                throw new YAMLException(
                  "unacceptable kind of an object to dump " + type
                );
              }
              if (null !== state.tag && "?" !== state.tag) {
                state.dump = "!<" + state.tag + "> " + state.dump;
              }
            }
            return true;
          }
          function getDuplicateReferences(object, state) {
            var objects = [],
              duplicatesIndexes = [],
              index,
              length;
            inspectNode(object, objects, duplicatesIndexes);
            for (
              index = 0, length = duplicatesIndexes.length;
              index < length;
              index += 1
            ) {
              state.duplicates.push(objects[duplicatesIndexes[index]]);
            }
            state.usedDuplicates = new Array(length);
          }
          function inspectNode(object, objects, duplicatesIndexes) {
            var type = _toString.call(object),
              objectKeyList,
              index,
              length;
            if (null !== object && "object" === _typeof2(object)) {
              index = objects.indexOf(object);
              if (-1 !== index) {
                if (-1 === duplicatesIndexes.indexOf(index)) {
                  duplicatesIndexes.push(index);
                }
              } else {
                objects.push(object);
                if (Array.isArray(object)) {
                  for (
                    index = 0, length = object.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(object[index], objects, duplicatesIndexes);
                  }
                } else {
                  objectKeyList = Object.keys(object);
                  for (
                    index = 0, length = objectKeyList.length;
                    index < length;
                    index += 1
                  ) {
                    inspectNode(
                      object[objectKeyList[index]],
                      objects,
                      duplicatesIndexes
                    );
                  }
                }
              }
            }
          }
          function dump(input, options) {
            options = options || {};
            var state = new State(options);
            getDuplicateReferences(input, state);
            if (writeNode(state, 0, input, true, true)) {
              return state.dump + "\n";
            }
            return "";
          }
          exports.dump = dump;
          function safeDump(input, options) {
            return dump(
              input,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          exports.safeDump = safeDump;
        },
        {
          "./common": 190,
          "./exception": 192,
          "./schema/default_full": 199,
          "./schema/default_safe": 200
        }
      ],
      192: [
        function (require, module, exports) {
          "use strict";
          var YAMLException = (function () {
            function YAMLException(reason, mark, isWarning) {
              if (mark === void 0) {
                mark = null;
              }
              if (isWarning === void 0) {
                isWarning = false;
              }
              this.name = "YAMLException";
              this.reason = reason;
              this.mark = mark;
              this.message = this.toString(false);
              this.isWarning = isWarning;
            }
            YAMLException.isInstance = function (instance) {
              if (
                instance != null &&
                instance.getClassIdentifier &&
                typeof instance.getClassIdentifier == "function"
              ) {
                for (
                  var _i = 0, _a = instance.getClassIdentifier();
                  _i < _a.length;
                  _i++
                ) {
                  var currentIdentifier = _a[_i];
                  if (currentIdentifier == YAMLException.CLASS_IDENTIFIER)
                    return true;
                }
              }
              return false;
            };
            YAMLException.prototype.getClassIdentifier = function () {
              var superIdentifiers = [];
              return superIdentifiers.concat(YAMLException.CLASS_IDENTIFIER);
            };
            YAMLException.prototype.toString = function (compact) {
              if (compact === void 0) {
                compact = false;
              }
              var result;
              result = "JS-YAML: " + (this.reason || "(unknown reason)");
              if (!compact && this.mark) {
                result += " " + this.mark.toString();
              }
              return result;
            };
            YAMLException.CLASS_IDENTIFIER = "yaml-ast-parser.YAMLException";
            return YAMLException;
          })();
          module.exports = YAMLException;
        },
        {}
      ],
      193: [
        function (require, module, exports) {
          "use strict";
          function __export(m) {
            for (var p in m) {
              if (!exports.hasOwnProperty(p)) exports[p] = m[p];
            }
          }
          Object.defineProperty(exports, "__esModule", { value: true });
          var loader_1 = require("./loader");
          exports.load = loader_1.load;
          exports.loadAll = loader_1.loadAll;
          exports.safeLoad = loader_1.safeLoad;
          exports.safeLoadAll = loader_1.safeLoadAll;
          var dumper_1 = require("./dumper");
          exports.dump = dumper_1.dump;
          exports.safeDump = dumper_1.safeDump;
          exports.YAMLException = require("./exception");
          __export(require("./yamlAST"));
          function deprecated(name) {
            return function () {
              throw new Error(
                "Function " + name + " is deprecated and cannot be used."
              );
            };
          }
          __export(require("./scalarInference"));
        },
        {
          "./dumper": 191,
          "./exception": 192,
          "./loader": 194,
          "./scalarInference": 196,
          "./yamlAST": 219
        }
      ],
      194: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var ast = require("./yamlAST");
          ("use strict");
          var common = require("./common");
          var YAMLException = require("./exception");
          var Mark = require("./mark");
          var DEFAULT_SAFE_SCHEMA = require("./schema/default_safe");
          var DEFAULT_FULL_SCHEMA = require("./schema/default_full");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CONTEXT_FLOW_IN = 1;
          var CONTEXT_FLOW_OUT = 2;
          var CONTEXT_BLOCK_IN = 3;
          var CONTEXT_BLOCK_OUT = 4;
          var CHOMPING_CLIP = 1;
          var CHOMPING_STRIP = 2;
          var CHOMPING_KEEP = 3;
          var PATTERN_NON_PRINTABLE =
            /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
          var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
          var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
          var PATTERN_TAG_URI =
            /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
          function is_EOL(c) {
            return c === 0x0a || c === 0x0d;
          }
          function is_WHITE_SPACE(c) {
            return c === 0x09 || c === 0x20;
          }
          function is_WS_OR_EOL(c) {
            return c === 0x09 || c === 0x20 || c === 0x0a || c === 0x0d;
          }
          function is_FLOW_INDICATOR(c) {
            return (
              0x2c === c || 0x5b === c || 0x5d === c || 0x7b === c || 0x7d === c
            );
          }
          function fromHexCode(c) {
            var lc;
            if (0x30 <= c && c <= 0x39) {
              return c - 0x30;
            }
            lc = c | 0x20;
            if (0x61 <= lc && lc <= 0x66) {
              return lc - 0x61 + 10;
            }
            return -1;
          }
          function escapedHexLen(c) {
            if (c === 0x78) {
              return 2;
            }
            if (c === 0x75) {
              return 4;
            }
            if (c === 0x55) {
              return 8;
            }
            return 0;
          }
          function fromDecimalCode(c) {
            if (0x30 <= c && c <= 0x39) {
              return c - 0x30;
            }
            return -1;
          }
          function simpleEscapeSequence(c) {
            return c === 0x30
              ? "\x00"
              : c === 0x61
              ? "\x07"
              : c === 0x62
              ? "\x08"
              : c === 0x74
              ? "\x09"
              : c === 0x09
              ? "\x09"
              : c === 0x6e
              ? "\x0A"
              : c === 0x76
              ? "\x0B"
              : c === 0x66
              ? "\x0C"
              : c === 0x72
              ? "\x0D"
              : c === 0x65
              ? "\x1B"
              : c === 0x20
              ? " "
              : c === 0x22
              ? "\x22"
              : c === 0x2f
              ? "/"
              : c === 0x5c
              ? "\x5C"
              : c === 0x4e
              ? "\x85"
              : c === 0x5f
              ? "\xA0"
              : c === 0x4c
              ? "\u2028"
              : c === 0x50
              ? "\u2029"
              : "";
          }
          function charFromCodepoint(c) {
            if (c <= 0xffff) {
              return String.fromCharCode(c);
            }
            return String.fromCharCode(
              ((c - 0x010000) >> 10) + 0xd800,
              ((c - 0x010000) & 0x03ff) + 0xdc00
            );
          }
          var simpleEscapeCheck = new Array(256);
          var simpleEscapeMap = new Array(256);
          var customEscapeCheck = new Array(256);
          var customEscapeMap = new Array(256);
          for (var i = 0; i < 256; i++) {
            customEscapeMap[i] = simpleEscapeMap[i] = simpleEscapeSequence(i);
            simpleEscapeCheck[i] = simpleEscapeMap[i] ? 1 : 0;
            customEscapeCheck[i] = 1;
            if (!simpleEscapeCheck[i]) {
              customEscapeMap[i] = "\\" + String.fromCharCode(i);
            }
          }
          var State = (function () {
            function State(input, options) {
              this.errorMap = {};
              this.errors = [];
              this.lines = [];
              this.input = input;
              this.filename = options["filename"] || null;
              this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
              this.onWarning = options["onWarning"] || null;
              this.legacy = options["legacy"] || false;
              this.allowAnyEscape = options["allowAnyEscape"] || false;
              this.ignoreDuplicateKeys = options["ignoreDuplicateKeys"] || false;
              this.implicitTypes = this.schema.compiledImplicit;
              this.typeMap = this.schema.compiledTypeMap;
              this.length = input.length;
              this.position = 0;
              this.line = 0;
              this.lineStart = 0;
              this.lineIndent = 0;
              this.documents = [];
            }
            return State;
          })();
          function generateError(state, message, isWarning) {
            if (isWarning === void 0) {
              isWarning = false;
            }
            return new YAMLException(
              message,
              new Mark(
                state.filename,
                state.input,
                state.position,
                state.line,
                state.position - state.lineStart
              ),
              isWarning
            );
          }
          function throwErrorFromPosition(
            state,
            position,
            message,
            isWarning,
            toLineEnd
          ) {
            if (isWarning === void 0) {
              isWarning = false;
            }
            if (toLineEnd === void 0) {
              toLineEnd = false;
            }
            var line = positionToLine(state, position);
            if (!line) {
              return;
            }
            var hash = message + position;
            if (state.errorMap[hash]) {
              return;
            }
            var mark = new Mark(
              state.filename,
              state.input,
              position,
              line.line,
              position - line.start
            );
            if (toLineEnd) {
              mark.toLineEnd = true;
            }
            var error = new YAMLException(message, mark, isWarning);
            state.errors.push(error);
          }
          function throwError(state, message) {
            var error = generateError(state, message);
            var hash = error.message + error.mark.position;
            if (state.errorMap[hash]) {
              return;
            }
            state.errors.push(error);
            state.errorMap[hash] = 1;
            var or = state.position;
            while (true) {
              if (state.position >= state.input.length - 1) {
                return;
              }
              var c = state.input.charAt(state.position);
              if (c == "\n") {
                state.position--;
                if (state.position == or) {
                  state.position += 1;
                }
                return;
              }
              if (c == "\r") {
                state.position--;
                if (state.position == or) {
                  state.position += 1;
                }
                return;
              }
              state.position++;
            }
          }
          function throwWarning(state, message) {
            var error = generateError(state, message);
            if (state.onWarning) {
              state.onWarning.call(null, error);
            } else {
            }
          }
          var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (null !== state.version) {
                throwError(state, "duplication of %YAML directive");
              }
              if (1 !== args.length) {
                throwError(state, "YAML directive accepts exactly one argument");
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (null === match) {
                throwError(state, "ill-formed argument of the YAML directive");
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (1 !== major) {
                throwError(
                  state,
                  "found incompatible YAML document (version 1.2 is required)"
                );
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (2 !== minor) {
                throwError(
                  state,
                  "found incompatible YAML document (version 1.2 is required)"
                );
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (2 !== args.length) {
                throwError(state, "TAG directive accepts exactly two arguments");
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(
                  state,
                  "ill-formed tag handle (first argument) of the TAG directive"
                );
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(
                  state,
                  'there is a previously declared suffix for "' +
                    handle +
                    '" tag handle'
                );
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(
                  state,
                  "ill-formed tag prefix (second argument) of the TAG directive"
                );
              }
              state.tagMap[handle] = prefix;
            }
          };
          function captureSegment(state, start, end, checkJson) {
            var _position, _length, _character, _result;
            var scalar = state.result;
            if (scalar.startPosition == -1) {
              scalar.startPosition = start;
            }
            if (start <= end) {
              _result = state.input.slice(start, end);
              if (checkJson) {
                for (
                  _position = 0, _length = _result.length;
                  _position < _length;
                  _position += 1
                ) {
                  _character = _result.charCodeAt(_position);
                  if (
                    !(
                      0x09 === _character ||
                      (0x20 <= _character && _character <= 0x10ffff)
                    )
                  ) {
                    throwError(state, "expected valid JSON character");
                  }
                }
              } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                throwError(state, "the stream contains non-printable characters");
              }
              scalar.value += _result;
              scalar.endPosition = end;
            }
          }
          function mergeMappings(state, destination, source) {
            var sourceKeys, key, index, quantity;
            if (!common.isObject(source)) {
              throwError(
                state,
                "cannot merge mappings; the provided source object is unacceptable"
              );
            }
            sourceKeys = Object.keys(source);
            for (
              index = 0, quantity = sourceKeys.length;
              index < quantity;
              index += 1
            ) {
              key = sourceKeys[index];
              if (!_hasOwnProperty.call(destination, key)) {
                destination[key] = source[key];
              }
            }
          }
          function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
            var index, quantity;
            if (keyNode == null) {
              return;
            }
            if (null === _result) {
              _result = {
                startPosition: keyNode.startPosition,
                endPosition: valueNode.endPosition,
                parent: null,
                errors: [],
                mappings: [],
                kind: ast.Kind.MAP
              };
            }
            var mapping = ast.newMapping(keyNode, valueNode);
            mapping.parent = _result;
            keyNode.parent = mapping;
            if (valueNode != null) {
              valueNode.parent = mapping;
            }
            !state.ignoreDuplicateKeys &&
              _result.mappings.forEach(function (sibling) {
                if (
                  sibling.key &&
                  sibling.key.value === (mapping.key && mapping.key.value)
                ) {
                  throwErrorFromPosition(
                    state,
                    mapping.key.startPosition,
                    "duplicate key"
                  );
                  throwErrorFromPosition(
                    state,
                    sibling.key.startPosition,
                    "duplicate key"
                  );
                }
              });
            _result.mappings.push(mapping);
            _result.endPosition = valueNode
              ? valueNode.endPosition
              : keyNode.endPosition + 1;
            return _result;
          }
          function readLineBreak(state) {
            var ch;
            ch = state.input.charCodeAt(state.position);
            if (0x0a === ch) {
              state.position++;
            } else if (0x0d === ch) {
              state.position++;
              if (0x0a === state.input.charCodeAt(state.position)) {
                state.position++;
              }
            } else {
              throwError(state, "a line break is expected");
            }
            state.line += 1;
            state.lineStart = state.position;
            state.lines.push({ start: state.lineStart, line: state.line });
          }
          var Line = (function () {
            function Line() {}
            return Line;
          })();
          function positionToLine(state, position) {
            var line;
            for (var i = 0; i < state.lines.length; i++) {
              if (state.lines[i].start > position) {
                break;
              }
              line = state.lines[i];
            }
            if (!line) {
              return { start: 0, line: 0 };
            }
            return line;
          }
          function skipSeparationSpace(state, allowComments, checkIndent) {
            var lineBreaks = 0,
              ch = state.input.charCodeAt(state.position);
            while (0 !== ch) {
              while (is_WHITE_SPACE(ch)) {
                if (ch === 0x09) {
                  state.errors.push(
                    generateError(
                      state,
                      "Using tabs can lead to unpredictable results",
                      true
                    )
                  );
                }
                ch = state.input.charCodeAt(++state.position);
              }
              if (allowComments && 0x23 === ch) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0x0a && ch !== 0x0d && 0 !== ch);
              }
              if (is_EOL(ch)) {
                readLineBreak(state);
                ch = state.input.charCodeAt(state.position);
                lineBreaks++;
                state.lineIndent = 0;
                while (0x20 === ch) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
              } else {
                break;
              }
            }
            if (
              -1 !== checkIndent &&
              0 !== lineBreaks &&
              state.lineIndent < checkIndent
            ) {
              throwWarning(state, "deficient indentation");
            }
            return lineBreaks;
          }
          function testDocumentSeparator(state) {
            var _position = state.position,
              ch;
            ch = state.input.charCodeAt(_position);
            if (
              (0x2d === ch || 0x2e === ch) &&
              state.input.charCodeAt(_position + 1) === ch &&
              state.input.charCodeAt(_position + 2) === ch
            ) {
              _position += 3;
              ch = state.input.charCodeAt(_position);
              if (ch === 0 || is_WS_OR_EOL(ch)) {
                return true;
              }
            }
            return false;
          }
          function writeFoldedLines(state, scalar, count) {
            if (1 === count) {
              scalar.value += " ";
            } else if (count > 1) {
              scalar.value += common.repeat("\n", count - 1);
            }
          }
          function readPlainScalar(state, nodeIndent, withinFlowCollection) {
            var preceding,
              following,
              captureStart,
              captureEnd,
              hasPendingContent,
              _line,
              _lineStart,
              _lineIndent,
              _kind = state.kind,
              _result = state.result,
              ch;
            var state_result = ast.newScalar();
            state_result.plainScalar = true;
            state.result = state_result;
            ch = state.input.charCodeAt(state.position);
            if (
              is_WS_OR_EOL(ch) ||
              is_FLOW_INDICATOR(ch) ||
              0x23 === ch ||
              0x26 === ch ||
              0x2a === ch ||
              0x21 === ch ||
              0x7c === ch ||
              0x3e === ch ||
              0x27 === ch ||
              0x22 === ch ||
              0x25 === ch ||
              0x40 === ch ||
              0x60 === ch
            ) {
              return false;
            }
            if (0x3f === ch || 0x2d === ch) {
              following = state.input.charCodeAt(state.position + 1);
              if (
                is_WS_OR_EOL(following) ||
                (withinFlowCollection && is_FLOW_INDICATOR(following))
              ) {
                return false;
              }
            }
            state.kind = "scalar";
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
            while (0 !== ch) {
              if (0x3a === ch) {
                following = state.input.charCodeAt(state.position + 1);
                if (
                  is_WS_OR_EOL(following) ||
                  (withinFlowCollection && is_FLOW_INDICATOR(following))
                ) {
                  break;
                }
              } else if (0x23 === ch) {
                preceding = state.input.charCodeAt(state.position - 1);
                if (is_WS_OR_EOL(preceding)) {
                  break;
                }
              } else if (
                (state.position === state.lineStart &&
                  testDocumentSeparator(state)) ||
                (withinFlowCollection && is_FLOW_INDICATOR(ch))
              ) {
                break;
              } else if (is_EOL(ch)) {
                _line = state.line;
                _lineStart = state.lineStart;
                _lineIndent = state.lineIndent;
                skipSeparationSpace(state, false, -1);
                if (state.lineIndent >= nodeIndent) {
                  hasPendingContent = true;
                  ch = state.input.charCodeAt(state.position);
                  continue;
                } else {
                  state.position = captureEnd;
                  state.line = _line;
                  state.lineStart = _lineStart;
                  state.lineIndent = _lineIndent;
                  break;
                }
              }
              if (hasPendingContent) {
                captureSegment(state, captureStart, captureEnd, false);
                writeFoldedLines(state, state_result, state.line - _line);
                captureStart = captureEnd = state.position;
                hasPendingContent = false;
              }
              if (!is_WHITE_SPACE(ch)) {
                captureEnd = state.position + 1;
              }
              ch = state.input.charCodeAt(++state.position);
              if (state.position >= state.input.length) {
                return false;
              }
            }
            captureSegment(state, captureStart, captureEnd, false);
            if (state.result.startPosition != -1) {
              state_result.rawValue = state.input.substring(
                state_result.startPosition,
                state_result.endPosition
              );
              return true;
            }
            state.kind = _kind;
            state.result = _result;
            return false;
          }
          function readSingleQuotedScalar(state, nodeIndent) {
            var ch, captureStart, captureEnd;
            ch = state.input.charCodeAt(state.position);
            if (0x27 !== ch) {
              return false;
            }
            var scalar = ast.newScalar();
            scalar.singleQuoted = true;
            state.kind = "scalar";
            state.result = scalar;
            scalar.startPosition = state.position;
            state.position++;
            captureStart = captureEnd = state.position;
            while (0 !== (ch = state.input.charCodeAt(state.position))) {
              if (0x27 === ch) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                scalar.endPosition = state.position;
                if (0x27 === ch) {
                  captureStart = captureEnd = state.position;
                  state.position++;
                } else {
                  return true;
                }
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  scalar,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a single quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
                scalar.endPosition = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a single quoted scalar"
            );
          }
          function readDoubleQuotedScalar(state, nodeIndent) {
            var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x22 !== ch) {
              return false;
            }
            state.kind = "scalar";
            var scalar = ast.newScalar();
            scalar.doubleQuoted = true;
            state.result = scalar;
            scalar.startPosition = state.position;
            state.position++;
            captureStart = captureEnd = state.position;
            while (0 !== (ch = state.input.charCodeAt(state.position))) {
              if (0x22 === ch) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                scalar.endPosition = state.position;
                scalar.rawValue = state.input.substring(
                  scalar.startPosition,
                  scalar.endPosition
                );
                return true;
              } else if (0x5c === ch) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) {
                  skipSeparationSpace(state, false, nodeIndent);
                } else if (
                  ch < 256 &&
                  (state.allowAnyEscape
                    ? customEscapeCheck[ch]
                    : simpleEscapeCheck[ch])
                ) {
                  scalar.value += state.allowAnyEscape
                    ? customEscapeMap[ch]
                    : simpleEscapeMap[ch];
                  state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                  hexLength = tmp;
                  hexResult = 0;
                  for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                      hexResult = (hexResult << 4) + tmp;
                    } else {
                      throwError(state, "expected hexadecimal character");
                    }
                  }
                  scalar.value += charFromCodepoint(hexResult);
                  state.position++;
                } else {
                  throwError(state, "unknown escape sequence");
                }
                captureStart = captureEnd = state.position;
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(
                  state,
                  scalar,
                  skipSeparationSpace(state, false, nodeIndent)
                );
                captureStart = captureEnd = state.position;
              } else if (
                state.position === state.lineStart &&
                testDocumentSeparator(state)
              ) {
                throwError(
                  state,
                  "unexpected end of the document within a double quoted scalar"
                );
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a double quoted scalar"
            );
          }
          function readFlowCollection(state, nodeIndent) {
            var readNext = true,
              _line,
              _tag = state.tag,
              _result,
              _anchor = state.anchor,
              following,
              terminator,
              isPair,
              isExplicitPair,
              isMapping,
              keyNode,
              keyTag,
              valueNode,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x5b) {
              terminator = 0x5d;
              isMapping = false;
              _result = ast.newItems();
              _result.startPosition = state.position;
            } else if (ch === 0x7b) {
              terminator = 0x7d;
              isMapping = true;
              _result = ast.newMap();
              _result.startPosition = state.position;
            } else {
              return false;
            }
            if (null !== state.anchor) {
              _result.anchorId = state.anchor;
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(++state.position);
            while (0 !== ch) {
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === terminator) {
                state.position++;
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = isMapping ? "mapping" : "sequence";
                state.result = _result;
                _result.endPosition = state.position;
                return true;
              } else if (!readNext) {
                var p = state.position;
                throwError(state, "missed comma between flow collection entries");
                state.position = p + 1;
              }
              keyTag = keyNode = valueNode = null;
              isPair = isExplicitPair = false;
              if (0x3f === ch) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following)) {
                  isPair = isExplicitPair = true;
                  state.position++;
                  skipSeparationSpace(state, true, nodeIndent);
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              keyTag = state.tag;
              keyNode = state.result;
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if ((isExplicitPair || state.line === _line) && 0x3a === ch) {
                isPair = true;
                ch = state.input.charCodeAt(++state.position);
                skipSeparationSpace(state, true, nodeIndent);
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                valueNode = state.result;
              }
              if (isMapping) {
                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
              } else if (isPair) {
                var mp = storeMappingPair(
                  state,
                  null,
                  keyTag,
                  keyNode,
                  valueNode
                );
                mp.parent = _result;
                _result.items.push(mp);
              } else {
                if (keyNode) {
                  keyNode.parent = _result;
                }
                _result.items.push(keyNode);
              }
              _result.endPosition = state.position + 1;
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (0x2c === ch) {
                readNext = true;
                ch = state.input.charCodeAt(++state.position);
              } else {
                readNext = false;
              }
            }
            throwError(
              state,
              "unexpected end of the stream within a flow collection"
            );
          }
          function readBlockScalar(state, nodeIndent) {
            var captureStart,
              folding,
              chomping = CHOMPING_CLIP,
              detectedIndent = false,
              textIndent = nodeIndent,
              emptyLines = 0,
              atMoreIndented = false,
              tmp,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x7c) {
              folding = false;
            } else if (ch === 0x3e) {
              folding = true;
            } else {
              return false;
            }
            var sc = ast.newScalar();
            state.kind = "scalar";
            state.result = sc;
            sc.startPosition = state.position;
            while (0 !== ch) {
              ch = state.input.charCodeAt(++state.position);
              if (0x2b === ch || 0x2d === ch) {
                if (CHOMPING_CLIP === chomping) {
                  chomping = 0x2b === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
                } else {
                  throwError(state, "repeat of a chomping mode identifier");
                }
              } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                if (tmp === 0) {
                  throwError(
                    state,
                    "bad explicit indentation width of a block scalar; it cannot be less than one"
                  );
                } else if (!detectedIndent) {
                  textIndent = nodeIndent + tmp - 1;
                  detectedIndent = true;
                } else {
                  throwError(state, "repeat of an indentation width identifier");
                }
              } else {
                break;
              }
            }
            if (is_WHITE_SPACE(ch)) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (is_WHITE_SPACE(ch));
              if (0x23 === ch) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (!is_EOL(ch) && 0 !== ch);
              }
            }
            while (0 !== ch) {
              readLineBreak(state);
              state.lineIndent = 0;
              ch = state.input.charCodeAt(state.position);
              while (
                (!detectedIndent || state.lineIndent < textIndent) &&
                0x20 === ch
              ) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
              if (!detectedIndent && state.lineIndent > textIndent) {
                textIndent = state.lineIndent;
              }
              if (is_EOL(ch)) {
                emptyLines++;
                continue;
              }
              if (state.lineIndent < textIndent) {
                if (chomping === CHOMPING_KEEP) {
                  sc.value += common.repeat("\n", emptyLines);
                } else if (chomping === CHOMPING_CLIP) {
                  if (detectedIndent) {
                    sc.value += "\n";
                  }
                }
                break;
              }
              if (folding) {
                if (is_WHITE_SPACE(ch)) {
                  atMoreIndented = true;
                  sc.value += common.repeat("\n", emptyLines + 1);
                } else if (atMoreIndented) {
                  atMoreIndented = false;
                  sc.value += common.repeat("\n", emptyLines + 1);
                } else if (0 === emptyLines) {
                  if (detectedIndent) {
                    sc.value += " ";
                  }
                } else {
                  sc.value += common.repeat("\n", emptyLines);
                }
              } else if (detectedIndent) {
                sc.value += common.repeat("\n", emptyLines + 1);
              } else {
              }
              detectedIndent = true;
              emptyLines = 0;
              captureStart = state.position;
              while (!is_EOL(ch) && 0 !== ch) {
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, state.position, false);
            }
            sc.endPosition = state.position;
            var i = state.position - 1;
            var needMinus = false;
            while (true) {
              var c = state.input[i];
              if (c == "\r" || c == "\n") {
                if (needMinus) {
                  i--;
                }
                break;
              }
              if (c != " " && c != "\t") {
                break;
              }
              i--;
            }
            sc.endPosition = i;
            sc.rawValue = state.input.substring(sc.startPosition, sc.endPosition);
            return true;
          }
          function readBlockSequence(state, nodeIndent) {
            var _line,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = ast.newItems(),
              following,
              detected = false,
              ch;
            if (null !== state.anchor) {
              _result.anchorId = state.anchor;
              state.anchorMap[state.anchor] = _result;
            }
            _result.startPosition = state.position;
            ch = state.input.charCodeAt(state.position);
            while (0 !== ch) {
              if (0x2d !== ch) {
                break;
              }
              following = state.input.charCodeAt(state.position + 1);
              if (!is_WS_OR_EOL(following)) {
                break;
              }
              detected = true;
              state.position++;
              if (skipSeparationSpace(state, true, -1)) {
                if (state.lineIndent <= nodeIndent) {
                  _result.items.push(null);
                  ch = state.input.charCodeAt(state.position);
                  continue;
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
              if (state.result) {
                state.result.parent = _result;
                _result.items.push(state.result);
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (
                (state.line === _line || state.lineIndent > nodeIndent) &&
                0 !== ch
              ) {
                throwError(state, "bad indentation of a sequence entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            _result.endPosition = state.position;
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "sequence";
              state.result = _result;
              _result.endPosition = state.position;
              return true;
            }
            return false;
          }
          function readBlockMapping(state, nodeIndent, flowIndent) {
            var following,
              allowCompact,
              _line,
              _tag = state.tag,
              _anchor = state.anchor,
              _result = ast.newMap(),
              keyTag = null,
              keyNode = null,
              valueNode = null,
              atExplicitKey = false,
              detected = false,
              ch;
            _result.startPosition = state.position;
            if (null !== state.anchor) {
              _result.anchorId = state.anchor;
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (0 !== ch) {
              following = state.input.charCodeAt(state.position + 1);
              _line = state.line;
              if ((0x3f === ch || 0x3a === ch) && is_WS_OR_EOL(following)) {
                if (0x3f === ch) {
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = true;
                  allowCompact = true;
                } else if (atExplicitKey) {
                  atExplicitKey = false;
                  allowCompact = true;
                } else {
                  throwError(
                    state,
                    "incomplete explicit mapping pair; a key node is missed"
                  );
                }
                state.position += 1;
                ch = following;
              } else if (
                composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
              ) {
                if (state.line === _line) {
                  ch = state.input.charCodeAt(state.position);
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (0x3a === ch) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                      throwError(
                        state,
                        "a whitespace character is expected after the key-value separator within a block mapping"
                      );
                    }
                    if (atExplicitKey) {
                      storeMappingPair(state, _result, keyTag, keyNode, null);
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                  } else if (
                    state.position == state.lineStart &&
                    testDocumentSeparator(state)
                  ) {
                    break;
                  } else if (detected) {
                    throwError(
                      state,
                      "can not read an implicit mapping pair; a colon is missed"
                    );
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true;
                  }
                } else if (detected) {
                  throwError(
                    state,
                    "can not read a block mapping entry; a multiline key may not be an implicit key"
                  );
                  while (state.position > 0) {
                    ch = state.input.charCodeAt(--state.position);
                    if (is_EOL(ch)) {
                      state.position++;
                      break;
                    }
                  }
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;
                }
              } else {
                break;
              }
              if (state.line === _line || state.lineIndent > nodeIndent) {
                if (
                  composeNode(
                    state,
                    nodeIndent,
                    CONTEXT_BLOCK_OUT,
                    true,
                    allowCompact
                  )
                ) {
                  if (atExplicitKey) {
                    keyNode = state.result;
                  } else {
                    valueNode = state.result;
                  }
                }
                if (!atExplicitKey) {
                  storeMappingPair(state, _result, keyTag, keyNode, valueNode);
                  keyTag = keyNode = valueNode = null;
                }
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
              }
              if (state.lineIndent > nodeIndent && 0 !== ch) {
                throwError(state, "bad indentation of a mapping entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, keyTag, keyNode, null);
            }
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "mapping";
              state.result = _result;
            }
            return detected;
          }
          function readTagProperty(state) {
            var _position,
              isVerbatim = false,
              isNamed = false,
              tagHandle,
              tagName,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (0x21 !== ch) {
              return false;
            }
            if (null !== state.tag) {
              throwError(state, "duplication of a tag property");
            }
            ch = state.input.charCodeAt(++state.position);
            if (0x3c === ch) {
              isVerbatim = true;
              ch = state.input.charCodeAt(++state.position);
            } else if (0x21 === ch) {
              isNamed = true;
              tagHandle = "!!";
              ch = state.input.charCodeAt(++state.position);
            } else {
              tagHandle = "!";
            }
            _position = state.position;
            if (isVerbatim) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (0 !== ch && 0x3e !== ch);
              if (state.position < state.length) {
                tagName = state.input.slice(_position, state.position);
                ch = state.input.charCodeAt(++state.position);
              } else {
                throwError(
                  state,
                  "unexpected end of the stream within a verbatim tag"
                );
              }
            } else {
              while (0 !== ch && !is_WS_OR_EOL(ch)) {
                if (0x21 === ch) {
                  if (!isNamed) {
                    tagHandle = state.input.slice(
                      _position - 1,
                      state.position + 1
                    );
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                      throwError(
                        state,
                        "named tag handle cannot contain such characters"
                      );
                    }
                    isNamed = true;
                    _position = state.position + 1;
                  } else {
                    throwError(
                      state,
                      "tag suffix cannot contain exclamation marks"
                    );
                  }
                }
                ch = state.input.charCodeAt(++state.position);
              }
              tagName = state.input.slice(_position, state.position);
              if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                throwError(
                  state,
                  "tag suffix cannot contain flow indicator characters"
                );
              }
            }
            if (tagName && !PATTERN_TAG_URI.test(tagName)) {
              throwError(
                state,
                "tag name cannot contain such characters: " + tagName
              );
            }
            if (isVerbatim) {
              state.tag = tagName;
            } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
              state.tag = state.tagMap[tagHandle] + tagName;
            } else if ("!" === tagHandle) {
              state.tag = "!" + tagName;
            } else if ("!!" === tagHandle) {
              state.tag = "tag:yaml.org,2002:" + tagName;
            } else {
              throwError(state, 'undeclared tag handle "' + tagHandle + '"');
            }
            return true;
          }
          function readAnchorProperty(state) {
            var _position, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x26 !== ch) {
              return false;
            }
            if (null !== state.anchor) {
              throwError(state, "duplication of an anchor property");
            }
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(
                state,
                "name of an anchor node must contain at least one character"
              );
            }
            state.anchor = state.input.slice(_position, state.position);
            return true;
          }
          function readAlias(state) {
            var _position,
              alias,
              len = state.length,
              input = state.input,
              ch;
            ch = state.input.charCodeAt(state.position);
            if (0x2a !== ch) {
              return false;
            }
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position <= _position) {
              throwError(
                state,
                "name of an alias node must contain at least one character"
              );
              state.position = _position + 1;
            }
            alias = state.input.slice(_position, state.position);
            if (!state.anchorMap.hasOwnProperty(alias)) {
              throwError(state, 'unidentified alias "' + alias + '"');
              if (state.position <= _position) {
                state.position = _position + 1;
              }
            }
            state.result = ast.newAnchorRef(
              alias,
              _position,
              state.position,
              state.anchorMap[alias]
            );
            skipSeparationSpace(state, true, -1);
            return true;
          }
          function composeNode(
            state,
            parentIndent,
            nodeContext,
            allowToSeek,
            allowCompact
          ) {
            var allowBlockStyles,
              allowBlockScalars,
              allowBlockCollections,
              indentStatus = 1,
              atNewLine = false,
              hasContent = false,
              typeIndex,
              typeQuantity,
              type,
              flowIndent,
              blockIndent,
              _result;
            state.tag = null;
            state.anchor = null;
            state.kind = null;
            state.result = null;
            allowBlockStyles =
              allowBlockScalars =
              allowBlockCollections =
                CONTEXT_BLOCK_OUT === nodeContext ||
                CONTEXT_BLOCK_IN === nodeContext;
            if (allowToSeek) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              }
            }
            var tagStart = state.position;
            var tagColumn = state.position - state.lineStart;
            if (1 === indentStatus) {
              while (readTagProperty(state) || readAnchorProperty(state)) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  allowBlockCollections = allowBlockStyles;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                } else {
                  allowBlockCollections = false;
                }
              }
            }
            if (allowBlockCollections) {
              allowBlockCollections = atNewLine || allowCompact;
            }
            if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
              if (
                CONTEXT_FLOW_IN === nodeContext ||
                CONTEXT_FLOW_OUT === nodeContext
              ) {
                flowIndent = parentIndent;
              } else {
                flowIndent = parentIndent + 1;
              }
              blockIndent = state.position - state.lineStart;
              if (1 === indentStatus) {
                if (
                  (allowBlockCollections &&
                    (readBlockSequence(state, blockIndent) ||
                      readBlockMapping(state, blockIndent, flowIndent))) ||
                  readFlowCollection(state, flowIndent)
                ) {
                  hasContent = true;
                } else {
                  if (
                    (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                    readSingleQuotedScalar(state, flowIndent) ||
                    readDoubleQuotedScalar(state, flowIndent)
                  ) {
                    hasContent = true;
                  } else if (readAlias(state)) {
                    hasContent = true;
                    if (null !== state.tag || null !== state.anchor) {
                      throwError(
                        state,
                        "alias node should not have any properties"
                      );
                    }
                  } else if (
                    readPlainScalar(
                      state,
                      flowIndent,
                      CONTEXT_FLOW_IN === nodeContext
                    )
                  ) {
                    hasContent = true;
                    if (null === state.tag) {
                      state.tag = "?";
                    }
                  }
                  if (null !== state.anchor) {
                    state.anchorMap[state.anchor] = state.result;
                    state.result.anchorId = state.anchor;
                  }
                }
              } else if (0 === indentStatus) {
                hasContent =
                  allowBlockCollections && readBlockSequence(state, blockIndent);
              }
            }
            if (null !== state.tag && "!" !== state.tag) {
              if (state.tag == "!include") {
                if (!state.result) {
                  state.result = ast.newScalar();
                  state.result.startPosition = state.position;
                  state.result.endPosition = state.position;
                  throwError(state, "!include without value");
                }
                state.result.kind = ast.Kind.INCLUDE_REF;
              } else if ("?" === state.tag) {
                for (
                  typeIndex = 0, typeQuantity = state.implicitTypes.length;
                  typeIndex < typeQuantity;
                  typeIndex += 1
                ) {
                  type = state.implicitTypes[typeIndex];
                  var vl = state.result["value"];
                  if (type.resolve(vl)) {
                    state.result.valueObject = type.construct(
                      state.result["value"]
                    );
                    state.tag = type.tag;
                    if (null !== state.anchor) {
                      state.result.anchorId = state.anchor;
                      state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                  }
                }
              } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
                type = state.typeMap[state.tag];
                if (null !== state.result && type.kind !== state.kind) {
                  throwError(
                    state,
                    "unacceptable node kind for !<" +
                      state.tag +
                      '> tag; it should be "' +
                      type.kind +
                      '", not "' +
                      state.kind +
                      '"'
                  );
                }
                if (!type.resolve(state.result)) {
                  throwError(
                    state,
                    "cannot resolve a node with !<" + state.tag + "> explicit tag"
                  );
                } else {
                  state.result = type.construct(state.result);
                  if (null !== state.anchor) {
                    state.result.anchorId = state.anchor;
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              } else {
                throwErrorFromPosition(
                  state,
                  tagStart,
                  "unknown tag <" + state.tag + ">",
                  false,
                  true
                );
              }
            }
            return null !== state.tag || null !== state.anchor || hasContent;
          }
          function readDocument(state) {
            var documentStart = state.position,
              _position,
              directiveName,
              directiveArgs,
              hasDirectives = false,
              ch;
            state.version = null;
            state.checkLineBreaks = state.legacy;
            state.tagMap = {};
            state.anchorMap = {};
            while (0 !== (ch = state.input.charCodeAt(state.position))) {
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (state.lineIndent > 0 || 0x25 !== ch) {
                break;
              }
              hasDirectives = true;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (0 !== ch && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveName = state.input.slice(_position, state.position);
              directiveArgs = [];
              if (directiveName.length < 1) {
                throwError(
                  state,
                  "directive name must not be less than one character in length"
                );
              }
              while (0 !== ch) {
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (0x23 === ch) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (0 !== ch && !is_EOL(ch));
                  break;
                }
                if (is_EOL(ch)) {
                  break;
                }
                _position = state.position;
                while (0 !== ch && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveArgs.push(state.input.slice(_position, state.position));
              }
              if (0 !== ch) {
                readLineBreak(state);
              }
              if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                directiveHandlers[directiveName](
                  state,
                  directiveName,
                  directiveArgs
                );
              } else {
                throwWarning(
                  state,
                  'unknown document directive "' + directiveName + '"'
                );
                state.position++;
              }
            }
            skipSeparationSpace(state, true, -1);
            if (
              0 === state.lineIndent &&
              0x2d === state.input.charCodeAt(state.position) &&
              0x2d === state.input.charCodeAt(state.position + 1) &&
              0x2d === state.input.charCodeAt(state.position + 2)
            ) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) {
              throwError(state, "directives end mark is expected");
            }
            composeNode(
              state,
              state.lineIndent - 1,
              CONTEXT_BLOCK_OUT,
              false,
              true
            );
            skipSeparationSpace(state, true, -1);
            if (
              state.checkLineBreaks &&
              PATTERN_NON_ASCII_LINE_BREAKS.test(
                state.input.slice(documentStart, state.position)
              )
            ) {
              throwWarning(
                state,
                "non-ASCII line breaks are interpreted as content"
              );
            }
            state.documents.push(state.result);
            if (
              state.position === state.lineStart &&
              testDocumentSeparator(state)
            ) {
              if (0x2e === state.input.charCodeAt(state.position)) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              }
              return;
            }
            if (state.position < state.length - 1) {
              throwError(
                state,
                "end of the stream or a document separator is expected"
              );
            } else {
              return;
            }
          }
          function loadDocuments(input, options) {
            input = String(input);
            options = options || {};
            var inputLength = input.length;
            if (inputLength !== 0) {
              if (
                0x0a !== input.charCodeAt(inputLength - 1) &&
                0x0d !== input.charCodeAt(inputLength - 1)
              ) {
                input += "\n";
              }
              if (input.charCodeAt(0) === 0xfeff) {
                input = input.slice(1);
              }
            }
            var state = new State(input, options);
            state.input += "\0";
            while (0x20 === state.input.charCodeAt(state.position)) {
              state.lineIndent += 1;
              state.position += 1;
            }
            while (state.position < state.length - 1) {
              var q = state.position;
              readDocument(state);
              if (state.position <= q) {
                for (; state.position < state.length - 1; state.position++) {
                  var c = state.input.charAt(state.position);
                  if (c == "\n") {
                    break;
                  }
                }
              }
            }
            var documents = state.documents;
            var docsCount = documents.length;
            if (docsCount > 0) {
              documents[docsCount - 1].endPosition = inputLength;
            }
            for (
              var _i = 0, documents_1 = documents;
              _i < documents_1.length;
              _i++
            ) {
              var x = documents_1[_i];
              x.errors = state.errors;
              if (x.startPosition > x.endPosition) {
                x.startPosition = x.endPosition;
              }
            }
            return documents;
          }
          function loadAll(input, iterator, options) {
            if (options === void 0) {
              options = {};
            }
            var documents = loadDocuments(input, options),
              index,
              length;
            for (
              index = 0, length = documents.length;
              index < length;
              index += 1
            ) {
              iterator(documents[index]);
            }
          }
          exports.loadAll = loadAll;
          function load(input, options) {
            if (options === void 0) {
              options = {};
            }
            var documents = loadDocuments(input, options),
              index,
              length;
            if (0 === documents.length) {
              return undefined;
            } else if (1 === documents.length) {
              return documents[0];
            }
            var e = new YAMLException(
              "expected a single document in the stream, but found more"
            );
            e.mark = new Mark("", "", 0, 0, 0);
            e.mark.position = documents[0].endPosition;
            documents[0].errors.push(e);
            return documents[0];
          }
          exports.load = load;
          function safeLoadAll(input, output, options) {
            if (options === void 0) {
              options = {};
            }
            loadAll(
              input,
              output,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          exports.safeLoadAll = safeLoadAll;
          function safeLoad(input, options) {
            if (options === void 0) {
              options = {};
            }
            return load(
              input,
              common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
            );
          }
          exports.safeLoad = safeLoad;
          module.exports.loadAll = loadAll;
          module.exports.load = load;
          module.exports.safeLoadAll = safeLoadAll;
          module.exports.safeLoad = safeLoad;
        },
        {
          "./common": 190,
          "./exception": 192,
          "./mark": 195,
          "./schema/default_full": 199,
          "./schema/default_safe": 200,
          "./yamlAST": 219
        }
      ],
      195: [
        function (require, module, exports) {
          "use strict";
          var common = require("./common");
          var Mark = (function () {
            function Mark(name, buffer, position, line, column) {
              this.name = name;
              this.buffer = buffer;
              this.position = position;
              this.line = line;
              this.column = column;
            }
            Mark.prototype.getSnippet = function (indent, maxLength) {
              if (indent === void 0) {
                indent = 0;
              }
              if (maxLength === void 0) {
                maxLength = 75;
              }
              var head, start, tail, end, snippet;
              if (!this.buffer) {
                return null;
              }
              indent = indent || 4;
              maxLength = maxLength || 75;
              head = "";
              start = this.position;
              while (
                start > 0 &&
                -1 ===
                  "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1))
              ) {
                start -= 1;
                if (this.position - start > maxLength / 2 - 1) {
                  head = " ... ";
                  start += 5;
                  break;
                }
              }
              tail = "";
              end = this.position;
              while (
                end < this.buffer.length &&
                -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end))
              ) {
                end += 1;
                if (end - this.position > maxLength / 2 - 1) {
                  tail = " ... ";
                  end -= 5;
                  break;
                }
              }
              snippet = this.buffer.slice(start, end);
              return (
                common.repeat(" ", indent) +
                head +
                snippet +
                tail +
                "\n" +
                common.repeat(" ", indent + this.position - start + head.length) +
                "^"
              );
            };
            Mark.prototype.toString = function (compact) {
              if (compact === void 0) {
                compact = true;
              }
              var snippet,
                where = "";
              if (this.name) {
                where += 'in "' + this.name + '" ';
              }
              where +=
                "at line " + (this.line + 1) + ", column " + (this.column + 1);
              if (!compact) {
                snippet = this.getSnippet();
                if (snippet) {
                  where += ":\n" + snippet;
                }
              }
              return where;
            };
            return Mark;
          })();
          module.exports = Mark;
        },
        { "./common": 190 }
      ],
      196: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          function parseYamlBoolean(input) {
            if (["true", "True", "TRUE"].lastIndexOf(input) >= 0) {
              return true;
            } else if (["false", "False", "FALSE"].lastIndexOf(input) >= 0) {
              return false;
            }
            throw 'Invalid boolean "' + input + '"';
          }
          exports.parseYamlBoolean = parseYamlBoolean;
          function safeParseYamlInteger(input) {
            if (input.lastIndexOf("0o", 0) === 0) {
              return parseInt(input.substring(2), 8);
            }
            return parseInt(input);
          }
          function parseYamlInteger(input) {
            var result = safeParseYamlInteger(input);
            if (isNaN(result)) {
              throw 'Invalid integer "' + input + '"';
            }
            return result;
          }
          exports.parseYamlInteger = parseYamlInteger;
          function parseYamlFloat(input) {
            if ([".nan", ".NaN", ".NAN"].lastIndexOf(input) >= 0) {
              return NaN;
            }
            var infinity = /^([-+])?(?:\.inf|\.Inf|\.INF)$/;
            var match = infinity.exec(input);
            if (match) {
              return match[1] === "-" ? -Infinity : Infinity;
            }
            var result = parseFloat(input);
            if (!isNaN(result)) {
              return result;
            }
            throw 'Invalid float "' + input + '"';
          }
          exports.parseYamlFloat = parseYamlFloat;
          var ScalarType;
          (function (ScalarType) {
            ScalarType[(ScalarType["null"] = 0)] = "null";
            ScalarType[(ScalarType["bool"] = 1)] = "bool";
            ScalarType[(ScalarType["int"] = 2)] = "int";
            ScalarType[(ScalarType["float"] = 3)] = "float";
            ScalarType[(ScalarType["string"] = 4)] = "string";
          })((ScalarType = exports.ScalarType || (exports.ScalarType = {})));
          function determineScalarType(node) {
            if (node === undefined) {
              return ScalarType["null"];
            }
            if (node.doubleQuoted || !node.plainScalar || node["singleQuoted"]) {
              return ScalarType.string;
            }
            var value = node.value;
            if (["null", "Null", "NULL", "~", ""].indexOf(value) >= 0) {
              return ScalarType["null"];
            }
            if (value === null || value === undefined) {
              return ScalarType["null"];
            }
            if (
              ["true", "True", "TRUE", "false", "False", "FALSE"].indexOf(
                value
              ) >= 0
            ) {
              return ScalarType.bool;
            }
            var base10 = /^[-+]?[0-9]+$/;
            var base8 = /^0o[0-7]+$/;
            var base16 = /^0x[0-9a-fA-F]+$/;
            if (base10.test(value) || base8.test(value) || base16.test(value)) {
              return ScalarType["int"];
            }
            var _float = /^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$/;
            var infinity = /^[-+]?(\.inf|\.Inf|\.INF)$/;
            if (
              _float.test(value) ||
              infinity.test(value) ||
              [".nan", ".NaN", ".NAN"].indexOf(value) >= 0
            ) {
              return ScalarType["float"];
            }
            return ScalarType.string;
          }
          exports.determineScalarType = determineScalarType;
        },
        {}
      ],
      197: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var common = require("./common");
          var YAMLException = require("./exception");
          var type_1 = require("./type");
          function compileList(schema, name, result) {
            var exclude = [];
            schema.include.forEach(function (includedSchema) {
              result = compileList(includedSchema, name, result);
            });
            schema[name].forEach(function (currentType) {
              result.forEach(function (previousType, previousIndex) {
                if (previousType.tag === currentType.tag) {
                  exclude.push(previousIndex);
                }
              });
              result.push(currentType);
            });
            return result.filter(function (type, index) {
              return -1 === exclude.indexOf(index);
            });
          }
          function compileMap() {
            var result = {},
              index,
              length;
            function collectType(type) {
              result[type.tag] = type;
            }
            for (
              index = 0, length = arguments.length;
              index < length;
              index += 1
            ) {
              arguments[index].forEach(collectType);
            }
            return result;
          }
          var Schema = (function () {
            function Schema(definition) {
              this.include = definition.include || [];
              this.implicit = definition.implicit || [];
              this.explicit = definition.explicit || [];
              this.implicit.forEach(function (type) {
                if (type.loadKind && "scalar" !== type.loadKind) {
                  throw new YAMLException(
                    "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
                  );
                }
              });
              this.compiledImplicit = compileList(this, "implicit", []);
              this.compiledExplicit = compileList(this, "explicit", []);
              this.compiledTypeMap = compileMap(
                this.compiledImplicit,
                this.compiledExplicit
              );
            }
            Schema.DEFAULT = null;
            Schema.create = function createSchema() {
              var schemas, types;
              switch (arguments.length) {
                case 1:
                  schemas = Schema.DEFAULT;
                  types = arguments[0];
                  break;
                case 2:
                  schemas = arguments[0];
                  types = arguments[1];
                  break;
                default:
                  throw new YAMLException(
                    "Wrong number of arguments for Schema.create function"
                  );
              }
              schemas = common.toArray(schemas);
              types = common.toArray(types);
              if (
                !schemas.every(function (schema) {
                  return schema instanceof Schema;
                })
              ) {
                throw new YAMLException(
                  "Specified list of super schemas (or a single Schema object) contains a non-Schema object."
                );
              }
              if (
                !types.every(function (type) {
                  return type instanceof type_1.Type;
                })
              ) {
                throw new YAMLException(
                  "Specified list of YAML types (or a single Type object) contains a non-Type object."
                );
              }
              return new Schema({ include: schemas, explicit: types });
            };
            return Schema;
          })();
          exports.Schema = Schema;
        },
        { "./common": 190, "./exception": 192, "./type": 203 }
      ],
      198: [
        function (require, module, exports) {
          "use strict";
          var schema_1 = require("../schema");
          module.exports = new schema_1.Schema({ include: [require("./json")] });
        },
        { "../schema": 197, "./json": 202 }
      ],
      199: [
        function (require, module, exports) {
          "use strict";
          var schema_1 = require("../schema");
          var schema = new schema_1.Schema({
            include: [require("./default_safe")],
            explicit: [
              require("../type/js/undefined"),
              require("../type/js/regexp")
            ]
          });
          schema_1.Schema.DEFAULT = schema;
          module.exports = schema;
        },
        {
          "../schema": 197,
          "../type/js/regexp": 208,
          "../type/js/undefined": 209,
          "./default_safe": 200
        }
      ],
      200: [
        function (require, module, exports) {
          "use strict";
          var schema_1 = require("../schema");
          var schema = new schema_1.Schema({
            include: [require("./core")],
            implicit: [require("../type/timestamp"), require("../type/merge")],
            explicit: [
              require("../type/binary"),
              require("../type/omap"),
              require("../type/pairs"),
              require("../type/set")
            ]
          });
          module.exports = schema;
        },
        {
          "../schema": 197,
          "../type/binary": 204,
          "../type/merge": 211,
          "../type/omap": 213,
          "../type/pairs": 214,
          "../type/set": 216,
          "../type/timestamp": 218,
          "./core": 198
        }
      ],
      201: [
        function (require, module, exports) {
          "use strict";
          var schema_1 = require("../schema");
          module.exports = new schema_1.Schema({
            explicit: [
              require("../type/str"),
              require("../type/seq"),
              require("../type/map")
            ]
          });
        },
        {
          "../schema": 197,
          "../type/map": 210,
          "../type/seq": 215,
          "../type/str": 217
        }
      ],
      202: [
        function (require, module, exports) {
          "use strict";
          var schema_1 = require("../schema");
          module.exports = new schema_1.Schema({
            include: [require("./failsafe")],
            implicit: [
              require("../type/null"),
              require("../type/bool"),
              require("../type/int"),
              require("../type/float")
            ]
          });
        },
        {
          "../schema": 197,
          "../type/bool": 205,
          "../type/float": 206,
          "../type/int": 207,
          "../type/null": 212,
          "./failsafe": 201
        }
      ],
      203: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var YAMLException = require("./exception");
          var TYPE_CONSTRUCTOR_OPTIONS = [
            "kind",
            "resolve",
            "construct",
            "instanceOf",
            "predicate",
            "represent",
            "defaultStyle",
            "styleAliases"
          ];
          var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
          function compileStyleAliases(map) {
            var result = {};
            if (null !== map) {
              Object.keys(map).forEach(function (style) {
                map[style].forEach(function (alias) {
                  result[String(alias)] = style;
                });
              });
            }
            return result;
          }
          var Type = (function () {
            function Type(tag, options) {
              options = options || {};
              Object.keys(options).forEach(function (name) {
                if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
                  throw new YAMLException(
                    'Unknown option "' +
                      name +
                      '" is met in definition of "' +
                      tag +
                      '" YAML type.'
                  );
                }
              });
              this.tag = tag;
              this.kind = options["kind"] || null;
              this.resolve =
                options["resolve"] ||
                function () {
                  return true;
                };
              this.construct =
                options["construct"] ||
                function (data) {
                  return data;
                };
              this.instanceOf = options["instanceOf"] || null;
              this.predicate = options["predicate"] || null;
              this.represent = options["represent"] || null;
              this.defaultStyle = options["defaultStyle"] || null;
              this.styleAliases = compileStyleAliases(
                options["styleAliases"] || null
              );
              if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
                throw new YAMLException(
                  'Unknown kind "' +
                    this.kind +
                    '" is specified for "' +
                    tag +
                    '" YAML type.'
                );
              }
            }
            return Type;
          })();
          exports.Type = Type;
        },
        { "./exception": 192 }
      ],
      204: [
        function (require, module, exports) {
          "use strict";
          var NodeBuffer = require("buffer").Buffer;
          var type_1 = require("../type");
          var BASE64_MAP =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
          function resolveYamlBinary(data) {
            if (null === data) {
              return false;
            }
            var code,
              idx,
              bitlen = 0,
              len = 0,
              max = data.length,
              map = BASE64_MAP;
            for (idx = 0; idx < max; idx++) {
              code = map.indexOf(data.charAt(idx));
              if (code > 64) {
                continue;
              }
              if (code < 0) {
                return false;
              }
              bitlen += 6;
            }
            return bitlen % 8 === 0;
          }
          function constructYamlBinary(data) {
            var code,
              idx,
              tailbits,
              input = data.replace(/[\r\n=]/g, ""),
              max = input.length,
              map = BASE64_MAP,
              bits = 0,
              result = [];
            for (idx = 0; idx < max; idx++) {
              if (idx % 4 === 0 && idx) {
                result.push((bits >> 16) & 0xff);
                result.push((bits >> 8) & 0xff);
                result.push(bits & 0xff);
              }
              bits = (bits << 6) | map.indexOf(input.charAt(idx));
            }
            tailbits = (max % 4) * 6;
            if (tailbits === 0) {
              result.push((bits >> 16) & 0xff);
              result.push((bits >> 8) & 0xff);
              result.push(bits & 0xff);
            } else if (tailbits === 18) {
              result.push((bits >> 10) & 0xff);
              result.push((bits >> 2) & 0xff);
            } else if (tailbits === 12) {
              result.push((bits >> 4) & 0xff);
            }
            if (NodeBuffer) {
              return new NodeBuffer(result);
            }
            return result;
          }
          function representYamlBinary(object) {
            var result = "",
              bits = 0,
              idx,
              tail,
              max = object.length,
              map = BASE64_MAP;
            for (idx = 0; idx < max; idx++) {
              if (idx % 3 === 0 && idx) {
                result += map[(bits >> 18) & 0x3f];
                result += map[(bits >> 12) & 0x3f];
                result += map[(bits >> 6) & 0x3f];
                result += map[bits & 0x3f];
              }
              bits = (bits << 8) + object[idx];
            }
            tail = max % 3;
            if (tail === 0) {
              result += map[(bits >> 18) & 0x3f];
              result += map[(bits >> 12) & 0x3f];
              result += map[(bits >> 6) & 0x3f];
              result += map[bits & 0x3f];
            } else if (tail === 2) {
              result += map[(bits >> 10) & 0x3f];
              result += map[(bits >> 4) & 0x3f];
              result += map[(bits << 2) & 0x3f];
              result += map[64];
            } else if (tail === 1) {
              result += map[(bits >> 2) & 0x3f];
              result += map[(bits << 4) & 0x3f];
              result += map[64];
              result += map[64];
            }
            return result;
          }
          function isBinary(object) {
            return NodeBuffer && NodeBuffer.isBuffer(object);
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:binary", {
            kind: "scalar",
            resolve: resolveYamlBinary,
            construct: constructYamlBinary,
            predicate: isBinary,
            represent: representYamlBinary
          });
        },
        { "../type": 203, buffer: 223 }
      ],
      205: [
        function (require, module, exports) {
          "use strict";
          "use strict";
          var type_1 = require("../type");
          function resolveYamlBoolean(data) {
            if (null === data) {
              return false;
            }
            var max = data.length;
            return (
              (max === 4 &&
                (data === "true" || data === "True" || data === "TRUE")) ||
              (max === 5 &&
                (data === "false" || data === "False" || data === "FALSE"))
            );
          }
          function constructYamlBoolean(data) {
            return data === "true" || data === "True" || data === "TRUE";
          }
          function isBoolean(object) {
            return "[object Boolean]" === Object.prototype.toString.call(object);
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:bool", {
            kind: "scalar",
            resolve: resolveYamlBoolean,
            construct: constructYamlBoolean,
            predicate: isBoolean,
            represent: {
              lowercase: function lowercase(object) {
                return object ? "true" : "false";
              },
              uppercase: function uppercase(object) {
                return object ? "TRUE" : "FALSE";
              },
              camelcase: function camelcase(object) {
                return object ? "True" : "False";
              }
            },
            defaultStyle: "lowercase"
          });
        },
        { "../type": 203 }
      ],
      206: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var type_1 = require("../type");
          var YAML_FLOAT_PATTERN = new RegExp(
            "^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?" +
              "|\\.[0-9_]+(?:[eE][-+][0-9]+)?" +
              "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" +
              "|[-+]?\\.(?:inf|Inf|INF)" +
              "|\\.(?:nan|NaN|NAN))$"
          );
          function resolveYamlFloat(data) {
            if (null === data) {
              return false;
            }
            var value, sign, base, digits;
            if (!YAML_FLOAT_PATTERN.test(data)) {
              return false;
            }
            return true;
          }
          function constructYamlFloat(data) {
            var value, sign, base, digits;
            value = data.replace(/_/g, "").toLowerCase();
            sign = "-" === value[0] ? -1 : 1;
            digits = [];
            if (0 <= "+-".indexOf(value[0])) {
              value = value.slice(1);
            }
            if (".inf" === value) {
              return 1 === sign
                ? Number.POSITIVE_INFINITY
                : Number.NEGATIVE_INFINITY;
            } else if (".nan" === value) {
              return NaN;
            } else if (0 <= value.indexOf(":")) {
              value.split(":").forEach(function (v) {
                digits.unshift(parseFloat(v, 10));
              });
              value = 0.0;
              base = 1;
              digits.forEach(function (d) {
                value += d * base;
                base *= 60;
              });
              return sign * value;
            }
            return sign * parseFloat(value, 10);
          }
          function representYamlFloat(object, style) {
            if (isNaN(object)) {
              switch (style) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            } else if (Number.POSITIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            } else if (Number.NEGATIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            } else if (common.isNegativeZero(object)) {
              return "-0.0";
            }
            return object.toString(10);
          }
          function isFloat(object) {
            return (
              "[object Number]" === Object.prototype.toString.call(object) &&
              (0 !== object % 1 || common.isNegativeZero(object))
            );
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:float", {
            kind: "scalar",
            resolve: resolveYamlFloat,
            construct: constructYamlFloat,
            predicate: isFloat,
            represent: representYamlFloat,
            defaultStyle: "lowercase"
          });
        },
        { "../common": 190, "../type": 203 }
      ],
      207: [
        function (require, module, exports) {
          "use strict";
          var common = require("../common");
          var type_1 = require("../type");
          function isHexCode(c) {
            return (
              (0x30 <= c && c <= 0x39) ||
              (0x41 <= c && c <= 0x46) ||
              (0x61 <= c && c <= 0x66)
            );
          }
          function isOctCode(c) {
            return 0x30 <= c && c <= 0x37;
          }
          function isDecCode(c) {
            return 0x30 <= c && c <= 0x39;
          }
          function resolveYamlInteger(data) {
            if (null === data) {
              return false;
            }
            var max = data.length,
              index = 0,
              hasDigits = false,
              ch;
            if (!max) {
              return false;
            }
            ch = data[index];
            if (ch === "-" || ch === "+") {
              ch = data[++index];
            }
            if (ch === "0") {
              if (index + 1 === max) {
                return true;
              }
              ch = data[++index];
              if (ch === "b") {
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") {
                    continue;
                  }
                  if (ch !== "0" && ch !== "1") {
                    return false;
                  }
                  hasDigits = true;
                }
                return hasDigits;
              }
              if (ch === "x") {
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") {
                    continue;
                  }
                  if (!isHexCode(data.charCodeAt(index))) {
                    return false;
                  }
                  hasDigits = true;
                }
                return hasDigits;
              }
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_") {
                  continue;
                }
                if (!isOctCode(data.charCodeAt(index))) {
                  return false;
                }
                hasDigits = true;
              }
              return hasDigits;
            }
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") {
                continue;
              }
              if (ch === ":") {
                break;
              }
              if (!isDecCode(data.charCodeAt(index))) {
                return false;
              }
              hasDigits = true;
            }
            if (!hasDigits) {
              return false;
            }
            if (ch !== ":") {
              return true;
            }
            return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
          }
          function constructYamlInteger(data) {
            var value = data,
              sign = 1,
              ch,
              base,
              digits = [];
            if (value.indexOf("_") !== -1) {
              value = value.replace(/_/g, "");
            }
            ch = value[0];
            if (ch === "-" || ch === "+") {
              if (ch === "-") {
                sign = -1;
              }
              value = value.slice(1);
              ch = value[0];
            }
            if ("0" === value) {
              return 0;
            }
            if (ch === "0") {
              if (value[1] === "b") {
                return sign * parseInt(value.slice(2), 2);
              }
              if (value[1] === "x") {
                return sign * parseInt(value, 16);
              }
              return sign * parseInt(value, 8);
            }
            if (value.indexOf(":") !== -1) {
              value.split(":").forEach(function (v) {
                digits.unshift(parseInt(v, 10));
              });
              value = 0;
              base = 1;
              digits.forEach(function (d) {
                value += d * base;
                base *= 60;
              });
              return sign * value;
            }
            return sign * parseInt(value, 10);
          }
          function isInteger(object) {
            return (
              "[object Number]" === Object.prototype.toString.call(object) &&
              0 === object % 1 &&
              !common.isNegativeZero(object)
            );
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:int", {
            kind: "scalar",
            resolve: resolveYamlInteger,
            construct: constructYamlInteger,
            predicate: isInteger,
            represent: {
              binary: function binary(object) {
                return "0b" + object.toString(2);
              },
              octal: function octal(object) {
                return "0" + object.toString(8);
              },
              decimal: function decimal(object) {
                return object.toString(10);
              },
              hexadecimal: function hexadecimal(object) {
                return "0x" + object.toString(16).toUpperCase();
              }
            },
            defaultStyle: "decimal",
            styleAliases: {
              binary: [2, "bin"],
              octal: [8, "oct"],
              decimal: [10, "dec"],
              hexadecimal: [16, "hex"]
            }
          });
        },
        { "../common": 190, "../type": 203 }
      ],
      208: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../../type");
          function resolveJavascriptRegExp(data) {
            if (null === data) {
              return false;
            }
            if (0 === data.length) {
              return false;
            }
            var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = "";
            if ("/" === regexp[0]) {
              if (tail) {
                modifiers = tail[1];
              }
              if (modifiers.length > 3) {
                return false;
              }
              if (regexp[regexp.length - modifiers.length - 1] !== "/") {
                return false;
              }
              regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
            }
            try {
              var dummy = new RegExp(regexp, modifiers);
              return true;
            } catch (error) {
              return false;
            }
          }
          function constructJavascriptRegExp(data) {
            var regexp = data,
              tail = /\/([gim]*)$/.exec(data),
              modifiers = "";
            if ("/" === regexp[0]) {
              if (tail) {
                modifiers = tail[1];
              }
              regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
            }
            return new RegExp(regexp, modifiers);
          }
          function representJavascriptRegExp(object) {
            var result = "/" + object.source + "/";
            if (object.global) {
              result += "g";
            }
            if (object.multiline) {
              result += "m";
            }
            if (object.ignoreCase) {
              result += "i";
            }
            return result;
          }
          function isRegExp(object) {
            return "[object RegExp]" === Object.prototype.toString.call(object);
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:js/regexp", {
            kind: "scalar",
            resolve: resolveJavascriptRegExp,
            construct: constructJavascriptRegExp,
            predicate: isRegExp,
            represent: representJavascriptRegExp
          });
        },
        { "../../type": 203 }
      ],
      209: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../../type");
          function resolveJavascriptUndefined() {
            return true;
          }
          function constructJavascriptUndefined() {
            return undefined;
          }
          function representJavascriptUndefined() {
            return "";
          }
          function isUndefined(object) {
            return "undefined" === typeof object;
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:js/undefined", {
            kind: "scalar",
            resolve: resolveJavascriptUndefined,
            construct: constructJavascriptUndefined,
            predicate: isUndefined,
            represent: representJavascriptUndefined
          });
        },
        { "../../type": 203 }
      ],
      210: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          module.exports = new type_1.Type("tag:yaml.org,2002:map", {
            kind: "mapping",
            construct: function construct(data) {
              return null !== data ? data : {};
            }
          });
        },
        { "../type": 203 }
      ],
      211: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          function resolveYamlMerge(data) {
            return "<<" === data || null === data;
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:merge", {
            kind: "scalar",
            resolve: resolveYamlMerge
          });
        },
        { "../type": 203 }
      ],
      212: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          function resolveYamlNull(data) {
            if (null === data) {
              return true;
            }
            var max = data.length;
            return (
              (max === 1 && data === "~") ||
              (max === 4 &&
                (data === "null" || data === "Null" || data === "NULL"))
            );
          }
          function constructYamlNull() {
            return null;
          }
          function isNull(object) {
            return null === object;
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:null", {
            kind: "scalar",
            resolve: resolveYamlNull,
            construct: constructYamlNull,
            predicate: isNull,
            represent: {
              canonical: function canonical() {
                return "~";
              },
              lowercase: function lowercase() {
                return "null";
              },
              uppercase: function uppercase() {
                return "NULL";
              },
              camelcase: function camelcase() {
                return "Null";
              }
            },
            defaultStyle: "lowercase"
          });
        },
        { "../type": 203 }
      ],
      213: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var _toString = Object.prototype.toString;
          function resolveYamlOmap(data) {
            if (null === data) {
              return true;
            }
            var objectKeys = [],
              index,
              length,
              pair,
              pairKey,
              pairHasKey,
              object = data;
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              pairHasKey = false;
              if ("[object Object]" !== _toString.call(pair)) {
                return false;
              }
              for (pairKey in pair) {
                if (_hasOwnProperty.call(pair, pairKey)) {
                  if (!pairHasKey) {
                    pairHasKey = true;
                  } else {
                    return false;
                  }
                }
              }
              if (!pairHasKey) {
                return false;
              }
              if (-1 === objectKeys.indexOf(pairKey)) {
                objectKeys.push(pairKey);
              } else {
                return false;
              }
            }
            return true;
          }
          function constructYamlOmap(data) {
            return null !== data ? data : [];
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:omap", {
            kind: "sequence",
            resolve: resolveYamlOmap,
            construct: constructYamlOmap
          });
        },
        { "../type": 203 }
      ],
      214: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          var ast = require("../yamlAST");
          var _toString = Object.prototype.toString;
          function resolveYamlPairs(data) {
            if (null === data) {
              return true;
            }
            if (data.kind != ast.Kind.SEQ) {
              return false;
            }
            var index,
              length,
              pair,
              keys,
              result,
              object = data.items;
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              if ("[object Object]" !== _toString.call(pair)) {
                return false;
              }
              if (!Array.isArray(pair.mappings)) {
                return false;
              }
              if (1 !== pair.mappings.length) {
                return false;
              }
            }
            return true;
          }
          function constructYamlPairs(data) {
            if (null === data || !Array.isArray(data.items)) {
              return [];
            }
            var index,
              length,
              keys,
              result,
              object = data.items;
            result = ast.newItems();
            result.parent = data.parent;
            result.startPosition = data.startPosition;
            result.endPosition = data.endPosition;
            for (index = 0, length = object.length; index < length; index += 1) {
              var pair = object[index];
              var mapping = pair.mappings[0];
              var pairSeq = ast.newItems();
              pairSeq.parent = result;
              pairSeq.startPosition = mapping.key.startPosition;
              pairSeq.endPosition = mapping.value.startPosition;
              mapping.key.parent = pairSeq;
              mapping.value.parent = pairSeq;
              pairSeq.items = [mapping.key, mapping.value];
              result.items.push(pairSeq);
            }
            return result;
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:pairs", {
            kind: "sequence",
            resolve: resolveYamlPairs,
            construct: constructYamlPairs
          });
        },
        { "../type": 203, "../yamlAST": 219 }
      ],
      215: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          module.exports = new type_1.Type("tag:yaml.org,2002:seq", {
            kind: "sequence",
            construct: function construct(data) {
              return null !== data ? data : [];
            }
          });
        },
        { "../type": 203 }
      ],
      216: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          var ast = require("../yamlAST");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          function resolveYamlSet(data) {
            if (null === data) {
              return true;
            }
            if (data.kind != ast.Kind.MAP) {
              return false;
            }
            return true;
          }
          function constructYamlSet(data) {
            return null !== data ? data : {};
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:set", {
            kind: "mapping",
            resolve: resolveYamlSet,
            construct: constructYamlSet
          });
        },
        { "../type": 203, "../yamlAST": 219 }
      ],
      217: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          module.exports = new type_1.Type("tag:yaml.org,2002:str", {
            kind: "scalar",
            construct: function construct(data) {
              return null !== data ? data : "";
            }
          });
        },
        { "../type": 203 }
      ],
      218: [
        function (require, module, exports) {
          "use strict";
          var type_1 = require("../type");
          var YAML_TIMESTAMP_REGEXP = new RegExp(
            "^([0-9][0-9][0-9][0-9])" +
              "-([0-9][0-9]?)" +
              "-([0-9][0-9]?)" +
              "(?:(?:[Tt]|[ \\t]+)" +
              "([0-9][0-9]?)" +
              ":([0-9][0-9])" +
              ":([0-9][0-9])" +
              "(?:\\.([0-9]*))?" +
              "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" +
              "(?::([0-9][0-9]))?))?)?$"
          );
          function resolveYamlTimestamp(data) {
            if (null === data) {
              return false;
            }
            var match,
              year,
              month,
              day,
              hour,
              minute,
              second,
              fraction = 0,
              delta = null,
              tz_hour,
              tz_minute,
              date;
            match = YAML_TIMESTAMP_REGEXP.exec(data);
            if (null === match) {
              return false;
            }
            return true;
          }
          function constructYamlTimestamp(data) {
            var match,
              year,
              month,
              day,
              hour,
              minute,
              second,
              fraction = 0,
              delta = null,
              tz_hour,
              tz_minute,
              date;
            match = YAML_TIMESTAMP_REGEXP.exec(data);
            if (null === match) {
              throw new Error("Date resolve error");
            }
            year = +match[1];
            month = +match[2] - 1;
            day = +match[3];
            if (!match[4]) {
              return new Date(Date.UTC(year, month, day));
            }
            hour = +match[4];
            minute = +match[5];
            second = +match[6];
            if (match[7]) {
              fraction = match[7].slice(0, 3);
              while (fraction.length < 3) {
                fraction = fraction + "0";
              }
              fraction = +fraction;
            }
            if (match[9]) {
              tz_hour = +match[10];
              tz_minute = +(match[11] || 0);
              delta = (tz_hour * 60 + tz_minute) * 60000;
              if ("-" === match[9]) {
                delta = -delta;
              }
            }
            date = new Date(
              Date.UTC(year, month, day, hour, minute, second, fraction)
            );
            if (delta) {
              date.setTime(date.getTime() - delta);
            }
            return date;
          }
          function representYamlTimestamp(object) {
            return object.toISOString();
          }
          module.exports = new type_1.Type("tag:yaml.org,2002:timestamp", {
            kind: "scalar",
            resolve: resolveYamlTimestamp,
            construct: constructYamlTimestamp,
            instanceOf: Date,
            represent: representYamlTimestamp
          });
        },
        { "../type": 203 }
      ],
      219: [
        function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var Kind;
          (function (Kind) {
            Kind[(Kind["SCALAR"] = 0)] = "SCALAR";
            Kind[(Kind["MAPPING"] = 1)] = "MAPPING";
            Kind[(Kind["MAP"] = 2)] = "MAP";
            Kind[(Kind["SEQ"] = 3)] = "SEQ";
            Kind[(Kind["ANCHOR_REF"] = 4)] = "ANCHOR_REF";
            Kind[(Kind["INCLUDE_REF"] = 5)] = "INCLUDE_REF";
          })((Kind = exports.Kind || (exports.Kind = {})));
          function newMapping(key, value) {
            var end = value ? value.endPosition : key.endPosition + 1;
            var node = {
              key: key,
              value: value,
              startPosition: key.startPosition,
              endPosition: end,
              kind: Kind.MAPPING,
              parent: null,
              errors: []
            };
            return node;
          }
          exports.newMapping = newMapping;
          function newAnchorRef(key, start, end, value) {
            return {
              errors: [],
              referencesAnchor: key,
              value: value,
              startPosition: start,
              endPosition: end,
              kind: Kind.ANCHOR_REF,
              parent: null
            };
          }
          exports.newAnchorRef = newAnchorRef;
          function newScalar(v) {
            if (v === void 0) {
              v = "";
            }
            var result = {
              errors: [],
              startPosition: -1,
              endPosition: -1,
              value: "" + v,
              kind: Kind.SCALAR,
              parent: null,
              doubleQuoted: false,
              rawValue: "" + v
            };
            if (typeof v !== "string") {
              result.valueObject = v;
            }
            return result;
          }
          exports.newScalar = newScalar;
          function newItems() {
            return {
              errors: [],
              startPosition: -1,
              endPosition: -1,
              items: [],
              kind: Kind.SEQ,
              parent: null
            };
          }
          exports.newItems = newItems;
          function newSeq() {
            return newItems();
          }
          exports.newSeq = newSeq;
          function newMap(mappings) {
            return {
              errors: [],
              startPosition: -1,
              endPosition: -1,
              mappings: mappings ? mappings : [],
              kind: Kind.MAP,
              parent: null
            };
          }
          exports.newMap = newMap;
        },
        {}
      ],
      220: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              "use strict";
              var possibleNames = [
                "BigInt64Array",
                "BigUint64Array",
                "Float32Array",
                "Float64Array",
                "Int16Array",
                "Int32Array",
                "Int8Array",
                "Uint16Array",
                "Uint32Array",
                "Uint8Array",
                "Uint8ClampedArray"
              ];
              var g = typeof globalThis === "undefined" ? global : globalThis;
              module.exports = function availableTypedArrays() {
                var out = [];
                for (var i = 0; i < possibleNames.length; i++) {
                  if (typeof g[possibleNames[i]] === "function") {
                    out[out.length] = possibleNames[i];
                  }
                }
                return out;
              };
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      221: [
        function (require, module, exports) {
          "use strict";
          exports.byteLength = byteLength;
          exports.toByteArray = toByteArray;
          exports.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var code =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          } // Support decoding URL-safe base64 strings, as Node.js does.
          // See: https://en.wikipedia.org/wiki/Base64#URL_applications
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
          function getLens(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            } // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
            return [validLen, placeHoldersLen];
          } // base64 is 4/3 + up to two characters of the original data
          function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
          }
          function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
          }
          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i;
            for (i = 0; i < len; i += 4) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)];
              arr[curByte++] = (tmp >> 16) & 0xff;
              arr[curByte++] = (tmp >> 8) & 0xff;
              arr[curByte++] = tmp & 0xff;
            }
            if (placeHoldersLen === 2) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4);
              arr[curByte++] = tmp & 0xff;
            }
            if (placeHoldersLen === 1) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2);
              arr[curByte++] = (tmp >> 8) & 0xff;
              arr[curByte++] = tmp & 0xff;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return (
              lookup[(num >> 18) & 0x3f] +
              lookup[(num >> 12) & 0x3f] +
              lookup[(num >> 6) & 0x3f] +
              lookup[num & 0x3f]
            );
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
              tmp =
                ((uint8[i] << 16) & 0xff0000) +
                ((uint8[i + 1] << 8) & 0xff00) +
                (uint8[i + 2] & 0xff);
              output.push(tripletToBase64(tmp));
            }
            return output.join("");
          }
          function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
            var parts = [];
            var maxChunkLength = 16383; // must be multiple of 3
            // go through the array every three bytes, we'll deal with trailing stuff later
            for (
              var i = 0, len2 = len - extraBytes;
              i < len2;
              i += maxChunkLength
            ) {
              parts.push(
                encodeChunk(
                  uint8,
                  i,
                  i + maxChunkLength > len2 ? len2 : i + maxChunkLength
                )
              );
            } // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
              tmp = uint8[len - 1];
              parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1];
              parts.push(
                lookup[tmp >> 10] +
                  lookup[(tmp >> 4) & 0x3f] +
                  lookup[(tmp << 2) & 0x3f] +
                  "="
              );
            }
            return parts.join("");
          }
        },
        {}
      ],
      222: [function (require, module, exports) {}, {}],
      223: [
        function (require, module, exports) {
          (function (Buffer) {
            (function () {
              /*!
               * The buffer module from node.js, for the browser.
               *
               * @author   Feross Aboukhadijeh <https://feross.org>
               * @license  MIT
               */ /* eslint-disable no-proto */ "use strict";
              var base64 = require("base64-js");
              var ieee754 = require("ieee754");
              exports.Buffer = Buffer;
              exports.SlowBuffer = SlowBuffer;
              exports.INSPECT_MAX_BYTES = 50;
              var K_MAX_LENGTH = 0x7fffffff;
              exports.kMaxLength = K_MAX_LENGTH;
              /**
               * If `Buffer.TYPED_ARRAY_SUPPORT`:
               *   === true    Use Uint8Array implementation (fastest)
               *   === false   Print warning and recommend using `buffer` v4.x which has an Object
               *               implementation (most compatible, even IE6)
               *
               * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
               * Opera 11.6+, iOS 4.2+.
               *
               * We report that the browser does not support typed arrays if the are not subclassable
               * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
               * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
               * for __proto__ and has a buggy typed array implementation.
               */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
              if (
                !Buffer.TYPED_ARRAY_SUPPORT &&
                typeof console !== "undefined" &&
                typeof console.error === "function"
              ) {
                console.error(
                  "This browser lacks typed array (Uint8Array) support which is required by " +
                    "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                );
              }
              function typedArraySupport() {
                // Can typed array instances can be augmented?
                try {
                  var arr = new Uint8Array(1);
                  arr.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function foo() {
                      return 42;
                    }
                  };
                  return arr.foo() === 42;
                } catch (e) {
                  return false;
                }
              }
              Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function get() {
                  if (!Buffer.isBuffer(this)) return undefined;
                  return this.buffer;
                }
              });
              Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function get() {
                  if (!Buffer.isBuffer(this)) return undefined;
                  return this.byteOffset;
                }
              });
              function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                  throw new RangeError(
                    'The value "' + length + '" is invalid for option "size"'
                  );
                } // Return an augmented `Uint8Array` instance
                var buf = new Uint8Array(length);
                buf.__proto__ = Buffer.prototype;
                return buf;
              }
              /**
               * The Buffer constructor returns instances of `Uint8Array` that have their
               * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
               * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
               * and the `Uint8Array` methods. Square bracket notation works as expected -- it
               * returns a single octet.
               *
               * The `Uint8Array` prototype remains unmodified.
               */ function Buffer(arg, encodingOrOffset, length) {
                // Common case.
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new TypeError(
                      'The "string" argument must be of type string. Received type number'
                    );
                  }
                  return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
              } // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
              if (
                typeof Symbol !== "undefined" &&
                Symbol.species != null &&
                Buffer[Symbol.species] === Buffer
              ) {
                Object.defineProperty(Buffer, Symbol.species, {
                  value: null,
                  configurable: true,
                  enumerable: false,
                  writable: false
                });
              }
              Buffer.poolSize = 8192; // not used by this implementation
              function from(value, encodingOrOffset, length) {
                if (typeof value === "string") {
                  return fromString(value, encodingOrOffset);
                }
                if (ArrayBuffer.isView(value)) {
                  return fromArrayLike(value);
                }
                if (value == null) {
                  throw TypeError(
                    "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                      "or Array-like Object. Received type " +
                      _typeof2(value)
                  );
                }
                if (
                  isInstance(value, ArrayBuffer) ||
                  (value && isInstance(value.buffer, ArrayBuffer))
                ) {
                  return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof value === "number") {
                  throw new TypeError(
                    'The "value" argument must not be of type number. Received type number'
                  );
                }
                var valueOf = value.valueOf && value.valueOf();
                if (valueOf != null && valueOf !== value) {
                  return Buffer.from(valueOf, encodingOrOffset, length);
                }
                var b = fromObject(value);
                if (b) return b;
                if (
                  typeof Symbol !== "undefined" &&
                  Symbol.toPrimitive != null &&
                  typeof value[Symbol.toPrimitive] === "function"
                ) {
                  return Buffer.from(
                    value[Symbol.toPrimitive]("string"),
                    encodingOrOffset,
                    length
                  );
                }
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, " +
                    "or Array-like Object. Received type " +
                    _typeof2(value)
                );
              }
              /**
               * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
               * if value is a number.
               * Buffer.from(str[, encoding])
               * Buffer.from(array)
               * Buffer.from(buffer)
               * Buffer.from(arrayBuffer[, byteOffset[, length]])
               **/ Buffer.from = function (value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
              }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
              // https://github.com/feross/buffer/pull/148
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be of type number');
                } else if (size < 0) {
                  throw new RangeError(
                    'The value "' + size + '" is invalid for option "size"'
                  );
                }
              }
              function alloc(size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(size);
                }
                if (fill !== undefined) {
                  // Only pay attention to encoding if it's a string. This
                  // prevents accidentally sending in a number that would
                  // be interpretted as a start offset.
                  return typeof encoding === "string"
                    ? createBuffer(size).fill(fill, encoding)
                    : createBuffer(size).fill(fill);
                }
                return createBuffer(size);
              }
              /**
               * Creates a new filled Buffer instance.
               * alloc(size[, fill[, encoding]])
               **/ Buffer.alloc = function (size, fill, encoding) {
                return alloc(size, fill, encoding);
              };
              function allocUnsafe(size) {
                assertSize(size);
                return createBuffer(size < 0 ? 0 : checked(size) | 0);
              }
              /**
               * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
               * */ Buffer.allocUnsafe = function (size) {
                return allocUnsafe(size);
              };
              /**
               * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
               */ Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(size);
              };
              function fromString(string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                var length = byteLength(string, encoding) | 0;
                var buf = createBuffer(length);
                var actual = buf.write(string, encoding);
                if (actual !== length) {
                  // Writing a hex string, for example, that contains invalid characters will
                  // cause everything after the first invalid character to be ignored. (e.g.
                  // 'abxxcd' will be treated as 'ab')
                  buf = buf.slice(0, actual);
                }
                return buf;
              }
              function fromArrayLike(array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                var buf = createBuffer(length);
                for (var i = 0; i < length; i += 1) {
                  buf[i] = array[i] & 255;
                }
                return buf;
              }
              function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError('"length" is outside of buffer bounds');
                }
                var buf;
                if (byteOffset === undefined && length === undefined) {
                  buf = new Uint8Array(array);
                } else if (length === undefined) {
                  buf = new Uint8Array(array, byteOffset);
                } else {
                  buf = new Uint8Array(array, byteOffset, length);
                } // Return an augmented `Uint8Array` instance
                buf.__proto__ = Buffer.prototype;
                return buf;
              }
              function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                  var len = checked(obj.length) | 0;
                  var buf = createBuffer(len);
                  if (buf.length === 0) {
                    return buf;
                  }
                  obj.copy(buf, 0, 0, len);
                  return buf;
                }
                if (obj.length !== undefined) {
                  if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                    return createBuffer(0);
                  }
                  return fromArrayLike(obj);
                }
                if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                  return fromArrayLike(obj.data);
                }
              }
              function checked(length) {
                // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= K_MAX_LENGTH) {
                  throw new RangeError(
                    "Attempt to allocate Buffer larger than maximum " +
                      "size: 0x" +
                      K_MAX_LENGTH.toString(16) +
                      " bytes"
                  );
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  // eslint-disable-line eqeqeq
                  length = 0;
                }
                return Buffer.alloc(+length);
              }
              Buffer.isBuffer = function isBuffer(b) {
                return (
                  b != null && b._isBuffer === true && b !== Buffer.prototype
                ); // so Buffer.isBuffer(Buffer.prototype) will be false
              };
              Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array))
                  a = Buffer.from(a, a.offset, a.byteLength);
                if (isInstance(b, Uint8Array))
                  b = Buffer.from(b, b.offset, b.byteLength);
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                }
                if (a === b) return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              };
              Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                }
                if (list.length === 0) {
                  return Buffer.alloc(0);
                }
                var i;
                if (length === undefined) {
                  length = 0;
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                  }
                }
                var buffer = Buffer.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                  var buf = list[i];
                  if (isInstance(buf, Uint8Array)) {
                    buf = Buffer.from(buf);
                  }
                  if (!Buffer.isBuffer(buf)) {
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  }
                  buf.copy(buffer, pos);
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                  return string.length;
                }
                if (
                  ArrayBuffer.isView(string) ||
                  isInstance(string, ArrayBuffer)
                ) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  throw new TypeError(
                    'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                      "Received type " +
                      _typeof2(string)
                  );
                }
                var len = string.length;
                var mustMatch = arguments.length > 2 && arguments[2] === true;
                if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion
                var loweredCase = false;
                for (;;) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase) {
                        return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                      }
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.
                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                  start = 0;
                } // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                  return "";
                }
                if (end === undefined || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding) encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
              // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
              // reliably in a browserify context because there could be multiple different
              // copies of the 'buffer' package in use. This method works even for Buffer
              // instances that were created from another copy of the `buffer` package.
              // See: https://github.com/feross/buffer/issues/154
              Buffer.prototype._isBuffer = true;
              function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
              }
              Buffer.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError(
                    "Buffer size must be a multiple of 16-bits"
                  );
                }
                for (var i = 0; i < len; i += 2) {
                  swap(this, i, i + 1);
                }
                return this;
              };
              Buffer.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                }
                for (var i = 0; i < len; i += 4) {
                  swap(this, i, i + 3);
                  swap(this, i + 1, i + 2);
                }
                return this;
              };
              Buffer.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                }
                for (var i = 0; i < len; i += 8) {
                  swap(this, i, i + 7);
                  swap(this, i + 1, i + 6);
                  swap(this, i + 2, i + 5);
                  swap(this, i + 3, i + 4);
                }
                return this;
              };
              Buffer.prototype.toString = function toString() {
                var length = this.length;
                if (length === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer.prototype.toLocaleString = Buffer.prototype.toString;
              Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b))
                  throw new TypeError("Argument must be a Buffer");
                if (this === b) return true;
                return Buffer.compare(this, b) === 0;
              };
              Buffer.prototype.inspect = function inspect() {
                var str = "";
                var max = exports.INSPECT_MAX_BYTES;
                str = this.toString("hex", 0, max)
                  .replace(/(.{2})/g, "$1 ")
                  .trim();
                if (this.length > max) str += " ... ";
                return "<Buffer " + str + ">";
              };
              Buffer.prototype.compare = function compare(
                target,
                start,
                end,
                thisStart,
                thisEnd
              ) {
                if (isInstance(target, Uint8Array)) {
                  target = Buffer.from(target, target.offset, target.byteLength);
                }
                if (!Buffer.isBuffer(target)) {
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. ' +
                      "Received type " +
                      _typeof2(target)
                  );
                }
                if (start === undefined) {
                  start = 0;
                }
                if (end === undefined) {
                  end = target ? target.length : 0;
                }
                if (thisStart === undefined) {
                  thisStart = 0;
                }
                if (thisEnd === undefined) {
                  thisEnd = this.length;
                }
                if (
                  start < 0 ||
                  end > target.length ||
                  thisStart < 0 ||
                  thisEnd > this.length
                ) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
              // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
              //
              // Arguments:
              // - buffer - a Buffer to search
              // - val - a string, Buffer, or number
              // - byteOffset - an index into `buffer`; will be clamped to an int32
              // - encoding - an optional encoding, relevant is val is a string
              // - dir - true for indexOf, false for lastIndexOf
              function bidirectionalIndexOf(
                buffer,
                val,
                byteOffset,
                encoding,
                dir
              ) {
                // Empty buffer means no match
                if (buffer.length === 0) return -1; // Normalize byteOffset
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 0x7fffffff) {
                  byteOffset = 0x7fffffff;
                } else if (byteOffset < -0x80000000) {
                  byteOffset = -0x80000000;
                }
                byteOffset = +byteOffset; // Coerce to Number.
                if (numberIsNaN(byteOffset)) {
                  // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                  byteOffset = dir ? 0 : buffer.length - 1;
                } // Normalize byteOffset: negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir) return -1;
                  else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir) byteOffset = 0;
                  else return -1;
                } // Normalize val
                if (typeof val === "string") {
                  val = Buffer.from(val, encoding);
                } // Finally, search either indexOf (if dir is true) or lastIndexOf
                if (Buffer.isBuffer(val)) {
                  // Special case: looking for empty string/buffer always fails
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 0xff; // Search for a byte value [0-255]
                  if (typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(
                        buffer,
                        val,
                        byteOffset
                      );
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(
                        buffer,
                        val,
                        byteOffset
                      );
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== undefined) {
                  encoding = String(encoding).toLowerCase();
                  if (
                    encoding === "ucs2" ||
                    encoding === "ucs-2" ||
                    encoding === "utf16le" ||
                    encoding === "utf-16le"
                  ) {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i) {
                  if (indexSize === 1) {
                    return buf[i];
                  } else {
                    return buf.readUInt16BE(i * indexSize);
                  }
                }
                var i;
                if (dir) {
                  var foundIndex = -1;
                  for (i = byteOffset; i < arrLength; i++) {
                    if (
                      read(arr, i) ===
                      read(val, foundIndex === -1 ? 0 : i - foundIndex)
                    ) {
                      if (foundIndex === -1) foundIndex = i;
                      if (i - foundIndex + 1 === valLength)
                        return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1) i -= i - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength)
                    byteOffset = arrLength - valLength;
                  for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                      }
                    }
                    if (found) return i;
                  }
                }
                return -1;
              }
              Buffer.prototype.includes = function includes(
                val,
                byteOffset,
                encoding
              ) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer.prototype.indexOf = function indexOf(
                val,
                byteOffset,
                encoding
              ) {
                return bidirectionalIndexOf(
                  this,
                  val,
                  byteOffset,
                  encoding,
                  true
                );
              };
              Buffer.prototype.lastIndexOf = function lastIndexOf(
                val,
                byteOffset,
                encoding
              ) {
                return bidirectionalIndexOf(
                  this,
                  val,
                  byteOffset,
                  encoding,
                  false
                );
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                var strLen = string.length;
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                  var parsed = parseInt(string.substr(i * 2, 2), 16);
                  if (numberIsNaN(parsed)) return i;
                  buf[offset + i] = parsed;
                }
                return i;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(
                  utf8ToBytes(string, buf.length - offset),
                  buf,
                  offset,
                  length
                );
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(
                  utf16leToBytes(string, buf.length - offset),
                  buf,
                  offset,
                  length
                );
              }
              Buffer.prototype.write = function write(
                string,
                offset,
                length,
                encoding
              ) {
                // Buffer#write(string)
                if (offset === undefined) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0; // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0; // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                  offset = offset >>> 0;
                  if (isFinite(length)) {
                    length = length >>> 0;
                    if (encoding === undefined) encoding = "utf8";
                  } else {
                    encoding = length;
                    length = undefined;
                  }
                } else {
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                }
                var remaining = this.length - offset;
                if (length === undefined || length > remaining)
                  length = remaining;
                if (
                  (string.length > 0 && (length < 0 || offset < 0)) ||
                  offset > this.length
                ) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding) encoding = "utf8";
                var loweredCase = false;
                for (;;) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                      return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, string, offset, length);
                    case "base64": // Warning: maxLength not taken into account in base64Write
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                  var firstByte = buf[i];
                  var codePoint = null;
                  var bytesPerSequence =
                    firstByte > 0xef
                      ? 4
                      : firstByte > 0xdf
                      ? 3
                      : firstByte > 0xbf
                      ? 2
                      : 1;
                  if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 0x80) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 0xc0) === 0x80) {
                          tempCodePoint =
                            ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                          if (tempCodePoint > 0x7f) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if (
                          (secondByte & 0xc0) === 0x80 &&
                          (thirdByte & 0xc0) === 0x80
                        ) {
                          tempCodePoint =
                            ((firstByte & 0xf) << 0xc) |
                            ((secondByte & 0x3f) << 0x6) |
                            (thirdByte & 0x3f);
                          if (
                            tempCodePoint > 0x7ff &&
                            (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                          ) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if (
                          (secondByte & 0xc0) === 0x80 &&
                          (thirdByte & 0xc0) === 0x80 &&
                          (fourthByte & 0xc0) === 0x80
                        ) {
                          tempCodePoint =
                            ((firstByte & 0xf) << 0x12) |
                            ((secondByte & 0x3f) << 0xc) |
                            ((thirdByte & 0x3f) << 0x6) |
                            (fourthByte & 0x3f);
                          if (
                            tempCodePoint > 0xffff &&
                            tempCodePoint < 0x110000
                          ) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    // we did not generate a valid codePoint so insert a
                    // replacement char (U+FFFD) and advance only 1 byte
                    codePoint = 0xfffd;
                    bytesPerSequence = 1;
                  } else if (codePoint > 0xffff) {
                    // encode to utf16 (surrogate pair dance)
                    codePoint -= 0x10000;
                    res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                    codePoint = 0xdc00 | (codePoint & 0x3ff);
                  }
                  res.push(codePoint);
                  i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
              // the lowest limit is Chrome, with 0x10000 args.
              // We go 1 magnitude less, for safety
              var MAX_ARGUMENTS_LENGTH = 0x1000;
              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
                } // Decode in chunks to avoid "call stack size exceeded".
                var res = "";
                var i = 0;
                while (i < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
                  );
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 0x7f);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                  out += toHex(buf[i]);
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
              }
              Buffer.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === undefined ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0) start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0) end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start) end = start;
                var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance
                newBuf.__proto__ = Buffer.prototype;
                return newBuf;
              };
              /*
               * Need to make sure that buffer isn't trying to write out of bounds.
               */ function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0)
                  throw new RangeError("offset is not uint");
                if (offset + ext > length)
                  throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer.prototype.readUIntLE = function readUIntLE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 0x100)) {
                  val += this[offset + i] * mul;
                }
                return val;
              };
              Buffer.prototype.readUIntBE = function readUIntBE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength, this.length);
                }
                var val = this[offset + --byteLength];
                var mul = 1;
                while (byteLength > 0 && (mul *= 0x100)) {
                  val += this[offset + --byteLength] * mul;
                }
                return val;
              };
              Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer.prototype.readUInt16LE = function readUInt16LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | (this[offset + 1] << 8);
              };
              Buffer.prototype.readUInt16BE = function readUInt16BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return (this[offset] << 8) | this[offset + 1];
              };
              Buffer.prototype.readUInt32LE = function readUInt32LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (
                  (this[offset] |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                  this[offset + 3] * 0x1000000
                );
              };
              Buffer.prototype.readUInt32BE = function readUInt32BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (
                  this[offset] * 0x1000000 +
                  ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
                );
              };
              Buffer.prototype.readIntLE = function readIntLE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 0x100)) {
                  val += this[offset + i] * mul;
                }
                mul *= 0x80;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
              };
              Buffer.prototype.readIntBE = function readIntBE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var i = byteLength;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 0x100)) {
                  val += this[offset + --i] * mul;
                }
                mul *= 0x80;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
              };
              Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 0x80)) return this[offset];
                return (0xff - this[offset] + 1) * -1;
              };
              Buffer.prototype.readInt16LE = function readInt16LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset] | (this[offset + 1] << 8);
                return val & 0x8000 ? val | 0xffff0000 : val;
              };
              Buffer.prototype.readInt16BE = function readInt16BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | (this[offset] << 8);
                return val & 0x8000 ? val | 0xffff0000 : val;
              };
              Buffer.prototype.readInt32LE = function readInt32LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (
                  this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16) |
                  (this[offset + 3] << 24)
                );
              };
              Buffer.prototype.readInt32BE = function readInt32BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (
                  (this[offset] << 24) |
                  (this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3]
                );
              };
              Buffer.prototype.readFloatLE = function readFloatLE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer.prototype.readFloatBE = function readFloatBE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer.prototype.readDoubleLE = function readDoubleLE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer.prototype.readDoubleBE = function readDoubleBE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                  throw new TypeError(
                    '"buffer" argument must be a Buffer instance'
                  );
                if (value > max || value < min)
                  throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
              }
              Buffer.prototype.writeUIntLE = function writeUIntLE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                  checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 0xff;
                while (++i < byteLength && (mul *= 0x100)) {
                  this[offset + i] = (value / mul) & 0xff;
                }
                return offset + byteLength;
              };
              Buffer.prototype.writeUIntBE = function writeUIntBE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                  checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var i = byteLength - 1;
                var mul = 1;
                this[offset + i] = value & 0xff;
                while (--i >= 0 && (mul *= 0x100)) {
                  this[offset + i] = (value / mul) & 0xff;
                }
                return offset + byteLength;
              };
              Buffer.prototype.writeUInt8 = function writeUInt8(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
                this[offset] = value & 0xff;
                return offset + 1;
              };
              Buffer.prototype.writeUInt16LE = function writeUInt16LE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer.prototype.writeUInt16BE = function writeUInt16BE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 0xff;
                return offset + 2;
              };
              Buffer.prototype.writeUInt32LE = function writeUInt32LE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 0xff;
                return offset + 4;
              };
              Buffer.prototype.writeUInt32BE = function writeUInt32BE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 0xff;
                return offset + 4;
              };
              Buffer.prototype.writeIntLE = function writeIntLE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength - 1);
                  checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 0xff;
                while (++i < byteLength && (mul *= 0x100)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                }
                return offset + byteLength;
              };
              Buffer.prototype.writeIntBE = function writeIntBE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength - 1);
                  checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = byteLength - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 0xff;
                while (--i >= 0 && (mul *= 0x100)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                }
                return offset + byteLength;
              };
              Buffer.prototype.writeInt8 = function writeInt8(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
                if (value < 0) value = 0xff + value + 1;
                this[offset] = value & 0xff;
                return offset + 1;
              };
              Buffer.prototype.writeInt16LE = function writeInt16LE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer.prototype.writeInt16BE = function writeInt16BE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 0xff;
                return offset + 2;
              };
              Buffer.prototype.writeInt32LE = function writeInt32LE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                this[offset] = value & 0xff;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
                return offset + 4;
              };
              Buffer.prototype.writeInt32BE = function writeInt32BE(
                value,
                offset,
                noAssert
              ) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                if (value < 0) value = 0xffffffff + value + 1;
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 0xff;
                return offset + 4;
              };
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
                if (offset < 0) throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(
                    buf,
                    value,
                    offset,
                    4,
                    3.4028234663852886e38,
                    -3.4028234663852886e38
                  );
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer.prototype.writeFloatLE = function writeFloatLE(
                value,
                offset,
                noAssert
              ) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeFloatBE = function writeFloatBE(
                value,
                offset,
                noAssert
              ) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(
                    buf,
                    value,
                    offset,
                    8,
                    1.7976931348623157e308,
                    -1.7976931348623157e308
                  );
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer.prototype.writeDoubleLE = function writeDoubleLE(
                value,
                offset,
                noAssert
              ) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeDoubleBE = function writeDoubleBE(
                value,
                offset,
                noAssert
              ) {
                return writeDouble(this, value, offset, false, noAssert);
              }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
              Buffer.prototype.copy = function copy(
                target,
                targetStart,
                start,
                end
              ) {
                if (!Buffer.isBuffer(target))
                  throw new TypeError("argument should be a Buffer");
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length)
                  throw new RangeError("Index out of range");
                if (end < 0) throw new RangeError("sourceEnd out of bounds"); // Are we oob?
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                var len = end - start;
                if (
                  this === target &&
                  typeof Uint8Array.prototype.copyWithin === "function"
                ) {
                  // Use built-in when available, missing from IE11
                  this.copyWithin(targetStart, start, end);
                } else if (
                  this === target &&
                  start < targetStart &&
                  targetStart < end
                ) {
                  // descending copy from end
                  for (var i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, end),
                    targetStart
                  );
                }
                return len;
              }; // Usage:
              //    buffer.fill(number[, offset[, end]])
              //    buffer.fill(buffer[, offset[, end]])
              //    buffer.fill(string[, offset[, end]][, encoding])
              Buffer.prototype.fill = function fill(val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (encoding !== undefined && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (
                    typeof encoding === "string" &&
                    !Buffer.isEncoding(encoding)
                  ) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (
                      (encoding === "utf8" && code < 128) ||
                      encoding === "latin1"
                    ) {
                      // Fast path: If `val` fits into a single byte, use that numeric value.
                      val = code;
                    }
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                } // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === undefined ? this.length : end >>> 0;
                if (!val) val = 0;
                var i;
                if (typeof val === "number") {
                  for (i = start; i < end; ++i) {
                    this[i] = val;
                  }
                } else {
                  var bytes = Buffer.isBuffer(val)
                    ? val
                    : Buffer.from(val, encoding);
                  var len = bytes.length;
                  if (len === 0) {
                    throw new TypeError(
                      'The value "' + val + '" is invalid for argument "value"'
                    );
                  }
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                  }
                }
                return this;
              }; // HELPER FUNCTIONS
              // ================
              var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
              function base64clean(str) {
                // Node takes equal signs as end of the Base64 encoding
                str = str.split("=")[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = str.trim().replace(INVALID_BASE64_RE, ""); // Node converts strings with length < 2 to ''
                if (str.length < 2) return ""; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function toHex(n) {
                if (n < 16) return "0" + n.toString(16);
                return n.toString(16);
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i); // is surrogate component
                  if (codePoint > 0xd7ff && codePoint < 0xe000) {
                    // last char was a lead
                    if (!leadSurrogate) {
                      // no lead yet
                      if (codePoint > 0xdbff) {
                        // unexpected trail
                        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                        continue;
                      } else if (i + 1 === length) {
                        // unpaired lead
                        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                        continue;
                      } // valid lead
                      leadSurrogate = codePoint;
                      continue;
                    } // 2 leads in a row
                    if (codePoint < 0xdc00) {
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                      leadSurrogate = codePoint;
                      continue;
                    } // valid surrogate pair
                    codePoint =
                      (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                      0x10000;
                  } else if (leadSurrogate) {
                    // valid bmp char, but last char was a lead
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  }
                  leadSurrogate = null; // encode utf8
                  if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                  } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break;
                    bytes.push(
                      (codePoint >> 0x6) | 0xc0,
                      (codePoint & 0x3f) | 0x80
                    );
                  } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break;
                    bytes.push(
                      (codePoint >> 0xc) | 0xe0,
                      ((codePoint >> 0x6) & 0x3f) | 0x80,
                      (codePoint & 0x3f) | 0x80
                    );
                  } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break;
                    bytes.push(
                      (codePoint >> 0x12) | 0xf0,
                      ((codePoint >> 0xc) & 0x3f) | 0x80,
                      ((codePoint >> 0x6) & 0x3f) | 0x80,
                      (codePoint & 0x3f) | 0x80
                    );
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  // Node's code seems to be doing this and not & 0x7F..
                  byteArray.push(str.charCodeAt(i) & 0xff);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0) break;
                  c = str.charCodeAt(i);
                  hi = c >> 8;
                  lo = c % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length) break;
                  dst[i + offset] = src[i];
                }
                return i;
              } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
              // the `instanceof` check but they should be treated as of that type.
              // See: https://github.com/feross/buffer/issues/166
              function isInstance(obj, type) {
                return (
                  obj instanceof type ||
                  (obj != null &&
                    obj.constructor != null &&
                    obj.constructor.name != null &&
                    obj.constructor.name === type.name)
                );
              }
              function numberIsNaN(obj) {
                // For IE11 support
                return obj !== obj; // eslint-disable-line no-self-compare
              }
            }.call(this));
          }.call(this, require("buffer").Buffer));
        },
        { "base64-js": 221, buffer: 223, ieee754: 238 }
      ],
      224: [
        function (require, module, exports) {
          module.exports = {
            100: "Continue",
            101: "Switching Protocols",
            102: "Processing",
            200: "OK",
            201: "Created",
            202: "Accepted",
            203: "Non-Authoritative Information",
            204: "No Content",
            205: "Reset Content",
            206: "Partial Content",
            207: "Multi-Status",
            208: "Already Reported",
            226: "IM Used",
            300: "Multiple Choices",
            301: "Moved Permanently",
            302: "Found",
            303: "See Other",
            304: "Not Modified",
            305: "Use Proxy",
            307: "Temporary Redirect",
            308: "Permanent Redirect",
            400: "Bad Request",
            401: "Unauthorized",
            402: "Payment Required",
            403: "Forbidden",
            404: "Not Found",
            405: "Method Not Allowed",
            406: "Not Acceptable",
            407: "Proxy Authentication Required",
            408: "Request Timeout",
            409: "Conflict",
            410: "Gone",
            411: "Length Required",
            412: "Precondition Failed",
            413: "Payload Too Large",
            414: "URI Too Long",
            415: "Unsupported Media Type",
            416: "Range Not Satisfiable",
            417: "Expectation Failed",
            418: "I'm a teapot",
            421: "Misdirected Request",
            422: "Unprocessable Entity",
            423: "Locked",
            424: "Failed Dependency",
            425: "Unordered Collection",
            426: "Upgrade Required",
            428: "Precondition Required",
            429: "Too Many Requests",
            431: "Request Header Fields Too Large",
            451: "Unavailable For Legal Reasons",
            500: "Internal Server Error",
            501: "Not Implemented",
            502: "Bad Gateway",
            503: "Service Unavailable",
            504: "Gateway Timeout",
            505: "HTTP Version Not Supported",
            506: "Variant Also Negotiates",
            507: "Insufficient Storage",
            508: "Loop Detected",
            509: "Bandwidth Limit Exceeded",
            510: "Not Extended",
            511: "Network Authentication Required"
          };
        },
        {}
      ],
      225: [
        function (require, module, exports) {
          "use strict";
          var GetIntrinsic = require("get-intrinsic");
          var callBind = require("./");
          var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
          module.exports = function callBoundIntrinsic(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if (
              typeof intrinsic === "function" &&
              $indexOf(name, ".prototype.") > -1
            ) {
              return callBind(intrinsic);
            }
            return intrinsic;
          };
        },
        { "./": 226, "get-intrinsic": 232 }
      ],
      226: [
        function (require, module, exports) {
          "use strict";
          var bind = require("function-bind");
          var GetIntrinsic = require("get-intrinsic");
          var $apply = GetIntrinsic("%Function.prototype.apply%");
          var $call = GetIntrinsic("%Function.prototype.call%");
          var $reflectApply =
            GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
          var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
          var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
          var $max = GetIntrinsic("%Math.max%");
          if ($defineProperty) {
            try {
              $defineProperty({}, "a", { value: 1 });
            } catch (e) {
              // IE 8 has a broken defineProperty
              $defineProperty = null;
            }
          }
          module.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments);
            if ($gOPD && $defineProperty) {
              var desc = $gOPD(func, "length");
              if (desc.configurable) {
                // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(func, "length", {
                  value:
                    1 + $max(0, originalFunction.length - (arguments.length - 1))
                });
              }
            }
            return func;
          };
          var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments);
          };
          if ($defineProperty) {
            $defineProperty(module.exports, "apply", { value: applyBind });
          } else {
            module.exports.apply = applyBind;
          }
        },
        { "function-bind": 231, "get-intrinsic": 232 }
      ],
      227: [
        function (require, module, exports) {
          "use strict";
          var GetIntrinsic = require("get-intrinsic");
          var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
          if ($gOPD) {
            try {
              $gOPD([], "length");
            } catch (e) {
              // IE 8 has a broken gOPD
              $gOPD = null;
            }
          }
          module.exports = $gOPD;
        },
        { "get-intrinsic": 232 }
      ],
      228: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          "use strict";
          var R =
            (typeof Reflect === "undefined" ? "undefined" : _typeof2(Reflect)) ===
            "object"
              ? Reflect
              : null;
          var ReflectApply =
            R && typeof R.apply === "function"
              ? R.apply
              : function ReflectApply(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };
          var ReflectOwnKeys;
          if (R && typeof R.ownKeys === "function") {
            ReflectOwnKeys = R.ownKeys;
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target).concat(
                Object.getOwnPropertySymbols(target)
              );
            };
          } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target);
            };
          }
          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning);
          }
          var NumberIsNaN =
            Number.isNaN ||
            function NumberIsNaN(value) {
              return value !== value;
            };
          function EventEmitter() {
            EventEmitter.init.call(this);
          }
          module.exports = EventEmitter;
          module.exports.once = once; // Backwards-compat with node 0.10.x
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._eventsCount = 0;
          EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
          // added to it. This is a useful default which helps finding memory leaks.
          var defaultMaxListeners = 10;
          function checkListener(listener) {
            if (typeof listener !== "function") {
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  _typeof2(listener)
              );
            }
          }
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function get() {
              return defaultMaxListeners;
            },
            set: function set(arg) {
              if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    arg +
                    "."
                );
              }
              defaultMaxListeners = arg;
            }
          });
          EventEmitter.init = function () {
            if (
              this._events === undefined ||
              this._events === Object.getPrototypeOf(this)._events
            ) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || undefined;
          }; // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  n +
                  "."
              );
            }
            this._maxListeners = n;
            return this;
          };
          function _getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }
          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
          };
          EventEmitter.prototype.emit = function emit(type) {
            var args = [];
            for (var i = 1; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            var doError = type === "error";
            var events = this._events;
            if (events !== undefined)
              doError = doError && events.error === undefined;
            else if (!doError) return false; // If there is no 'error' event listener then throw.
            if (doError) {
              var er;
              if (args.length > 0) er = args[0];
              if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
              } // At least give some kind of context to the user
              var err = new Error(
                "Unhandled error." + (er ? " (" + er.message + ")" : "")
              );
              err.context = er;
              throw err; // Unhandled 'error' event
            }
            var handler = events[type];
            if (handler === undefined) return false;
            if (typeof handler === "function") {
              ReflectApply(handler, this, args);
            } else {
              var len = handler.length;
              var listeners = arrayClone(handler, len);
              for (var i = 0; i < len; ++i) {
                ReflectApply(listeners[i], this, args);
              }
            }
            return true;
          };
          function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            checkListener(listener);
            events = target._events;
            if (events === undefined) {
              events = target._events = Object.create(null);
              target._eventsCount = 0;
            } else {
              // To avoid recursion in the case that type === "newListener"! Before
              // adding it to the listeners, first emit "newListener".
              if (events.newListener !== undefined) {
                target.emit(
                  "newListener",
                  type,
                  listener.listener ? listener.listener : listener
                ); // Re-assign `events` because a newListener handler could have caused the
                // this._events to be assigned to a new object
                events = target._events;
              }
              existing = events[type];
            }
            if (existing === undefined) {
              // Optimize the case of one listener. Don't need the extra array object.
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === "function") {
                // Adding the second element, need to change to array.
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener]; // If we've already got an array, just append.
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              } // Check for listener leak
              m = _getMaxListeners(target);
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true; // No error code for this since it is a Warning
                // eslint-disable-next-line no-restricted-syntax
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    " " +
                    String(type) +
                    " listeners " +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit"
                );
                w.name = "MaxListenersExceededWarning";
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                ProcessEmitWarning(w);
              }
            }
            return target;
          }
          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false);
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true);
          };
          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              if (arguments.length === 0) return this.listener.call(this.target);
              return this.listener.apply(this.target, arguments);
            }
          }
          function _onceWrap(target, type, listener) {
            var state = {
              fired: false,
              wrapFn: undefined,
              target: target,
              type: type,
              listener: listener
            };
            var wrapped = onceWrapper.bind(state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
          }
          EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.prependOnceListener =
            function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            }; // Emits a 'removeListener' event if and only if the listener was removed.
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            var list, events, position, i, originalListener;
            checkListener(listener);
            events = this._events;
            if (events === undefined) return this;
            list = events[type];
            if (list === undefined) return this;
            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit("removeListener", type, list.listener || listener);
              }
            } else if (typeof list !== "function") {
              position = -1;
              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener;
                  position = i;
                  break;
                }
              }
              if (position < 0) return this;
              if (position === 0) list.shift();
              else {
                spliceOne(list, position);
              }
              if (list.length === 1) events[type] = list[0];
              if (events.removeListener !== undefined)
                this.emit("removeListener", type, originalListener || listener);
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(
            type
          ) {
            var listeners, events, i;
            events = this._events;
            if (events === undefined) return this; // not listening for removeListener, no need to emit
            if (events.removeListener === undefined) {
              if (arguments.length === 0) {
                this._events = Object.create(null);
                this._eventsCount = 0;
              } else if (events[type] !== undefined) {
                if (--this._eventsCount === 0) this._events = Object.create(null);
                else delete events[type];
              }
              return this;
            } // emit removeListener for all listeners on all events
            if (arguments.length === 0) {
              var keys = Object.keys(events);
              var key;
              for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === "removeListener") continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = Object.create(null);
              this._eventsCount = 0;
              return this;
            }
            listeners = events[type];
            if (typeof listeners === "function") {
              this.removeListener(type, listeners);
            } else if (listeners !== undefined) {
              // LIFO order
              for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
              }
            }
            return this;
          };
          function _listeners(target, type, unwrap) {
            var events = target._events;
            if (events === undefined) return [];
            var evlistener = events[type];
            if (evlistener === undefined) return [];
            if (typeof evlistener === "function")
              return unwrap ? [evlistener.listener || evlistener] : [evlistener];
            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length);
          }
          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };
          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };
          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === "function") {
              return emitter.listenerCount(type);
            } else {
              return listenerCount.call(emitter, type);
            }
          };
          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            var events = this._events;
            if (events !== undefined) {
              var evlistener = events[type];
              if (typeof evlistener === "function") {
                return 1;
              } else if (evlistener !== undefined) {
                return evlistener.length;
              }
            }
            return 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
          };
          function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i) {
              copy[i] = arr[i];
            }
            return copy;
          }
          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++) {
              list[index] = list[index + 1];
            }
            list.pop();
          }
          function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i];
            }
            return ret;
          }
          function once(emitter, name) {
            return new Promise(function (resolve, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver);
                reject(err);
              }
              function resolver() {
                if (typeof emitter.removeListener === "function") {
                  emitter.removeListener("error", errorListener);
                }
                resolve([].slice.call(arguments));
              }
              eventTargetAgnosticAddListener(emitter, name, resolver, {
                once: true
              });
              if (name !== "error") {
                addErrorHandlerIfEventEmitter(emitter, errorListener, {
                  once: true
                });
              }
            });
          }
          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === "function") {
              eventTargetAgnosticAddListener(emitter, "error", handler, flags);
            }
          }
          function eventTargetAgnosticAddListener(
            emitter,
            name,
            listener,
            flags
          ) {
            if (typeof emitter.on === "function") {
              if (flags.once) {
                emitter.once(name, listener);
              } else {
                emitter.on(name, listener);
              }
            } else if (typeof emitter.addEventListener === "function") {
              // EventTarget does not have `error` event semantics like Node
              // EventEmitters, we do not listen for `error` events here.
              emitter.addEventListener(name, function wrapListener(arg) {
                // IE does not have builtin `{ once: true }` support so we
                // have to do it manually.
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener);
                }
                listener(arg);
              });
            } else {
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  _typeof2(emitter)
              );
            }
          }
        },
        {}
      ],
      229: [
        function (require, module, exports) {
          "use strict";
          var isCallable = require("is-callable");
          var toStr = Object.prototype.toString;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var forEachArray = function forEachArray(array, iterator, receiver) {
            for (var i = 0, len = array.length; i < len; i++) {
              if (hasOwnProperty.call(array, i)) {
                if (receiver == null) {
                  iterator(array[i], i, array);
                } else {
                  iterator.call(receiver, array[i], i, array);
                }
              }
            }
          };
          var forEachString = function forEachString(string, iterator, receiver) {
            for (var i = 0, len = string.length; i < len; i++) {
              // no such thing as a sparse string.
              if (receiver == null) {
                iterator(string.charAt(i), i, string);
              } else {
                iterator.call(receiver, string.charAt(i), i, string);
              }
            }
          };
          var forEachObject = function forEachObject(object, iterator, receiver) {
            for (var k in object) {
              if (hasOwnProperty.call(object, k)) {
                if (receiver == null) {
                  iterator(object[k], k, object);
                } else {
                  iterator.call(receiver, object[k], k, object);
                }
              }
            }
          };
          var forEach = function forEach(list, iterator, thisArg) {
            if (!isCallable(iterator)) {
              throw new TypeError("iterator must be a function");
            }
            var receiver;
            if (arguments.length >= 3) {
              receiver = thisArg;
            }
            if (toStr.call(list) === "[object Array]") {
              forEachArray(list, iterator, receiver);
            } else if (typeof list === "string") {
              forEachString(list, iterator, receiver);
            } else {
              forEachObject(list, iterator, receiver);
            }
          };
          module.exports = forEach;
        },
        { "is-callable": 242 }
      ],
      230: [
        function (require, module, exports) {
          "use strict";
          /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE =
            "Function.prototype.bind called on incompatible ";
          var slice = Array.prototype.slice;
          var toStr = Object.prototype.toString;
          var funcType = "[object Function]";
          module.exports = function bind(that) {
            var target = this;
            if (typeof target !== "function" || toStr.call(target) !== funcType) {
              throw new TypeError(ERROR_MESSAGE + target);
            }
            var args = slice.call(arguments, 1);
            var bound;
            var binder = function binder() {
              if (this instanceof bound) {
                var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                  return result;
                }
                return this;
              } else {
                return target.apply(that, args.concat(slice.call(arguments)));
              }
            };
            var boundLength = Math.max(0, target.length - args.length);
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
              boundArgs.push("$" + i);
            }
            bound = Function(
              "binder",
              "return function (" +
                boundArgs.join(",") +
                "){ return binder.apply(this,arguments); }"
            )(binder);
            if (target.prototype) {
              var Empty = function Empty() {};
              Empty.prototype = target.prototype;
              bound.prototype = new Empty();
              Empty.prototype = null;
            }
            return bound;
          };
        },
        {}
      ],
      231: [
        function (require, module, exports) {
          "use strict";
          var implementation = require("./implementation");
          module.exports = Function.prototype.bind || implementation;
        },
        { "./implementation": 230 }
      ],
      232: [
        function (require, module, exports) {
          "use strict";
          var undefined;
          var $SyntaxError = SyntaxError;
          var $Function = Function;
          var $TypeError = TypeError; // eslint-disable-next-line consistent-return
          var getEvalledConstructor = function getEvalledConstructor(
            expressionSyntax
          ) {
            try {
              return $Function(
                '"use strict"; return (' + expressionSyntax + ").constructor;"
              )();
            } catch (e) {}
          };
          var $gOPD = Object.getOwnPropertyDescriptor;
          if ($gOPD) {
            try {
              $gOPD({}, "");
            } catch (e) {
              $gOPD = null; // this is IE 8, which has a broken gOPD
            }
          }
          var throwTypeError = function throwTypeError() {
            throw new $TypeError();
          };
          var ThrowTypeError = $gOPD
            ? (function () {
                try {
                  // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                  arguments.callee; // IE 8 does not throw here
                  return throwTypeError;
                } catch (calleeThrows) {
                  try {
                    // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                    return $gOPD(arguments, "callee").get;
                  } catch (gOPDthrows) {
                    return throwTypeError;
                  }
                }
              })()
            : throwTypeError;
          var hasSymbols = require("has-symbols")();
          var getProto =
            Object.getPrototypeOf ||
            function (x) {
              return x.__proto__;
            }; // eslint-disable-line no-proto
          var needsEval = {};
          var TypedArray =
            typeof Uint8Array === "undefined" ? undefined : getProto(Uint8Array);
          var INTRINSICS = {
            "%AggregateError%":
              typeof AggregateError === "undefined" ? undefined : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%":
              typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
            "%ArrayIteratorPrototype%": hasSymbols
              ? getProto([][Symbol.iterator]())
              : undefined,
            "%AsyncFromSyncIteratorPrototype%": undefined,
            "%AsyncFunction%": needsEval,
            "%AsyncGenerator%": needsEval,
            "%AsyncGeneratorFunction%": needsEval,
            "%AsyncIteratorPrototype%": needsEval,
            "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
            "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval, // eslint-disable-line no-eval
            "%EvalError%": EvalError,
            "%Float32Array%":
              typeof Float32Array === "undefined" ? undefined : Float32Array,
            "%Float64Array%":
              typeof Float64Array === "undefined" ? undefined : Float64Array,
            "%FinalizationRegistry%":
              typeof FinalizationRegistry === "undefined"
                ? undefined
                : FinalizationRegistry,
            "%Function%": $Function,
            "%GeneratorFunction%": needsEval,
            "%Int8Array%":
              typeof Int8Array === "undefined" ? undefined : Int8Array,
            "%Int16Array%":
              typeof Int16Array === "undefined" ? undefined : Int16Array,
            "%Int32Array%":
              typeof Int32Array === "undefined" ? undefined : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": hasSymbols
              ? getProto(getProto([][Symbol.iterator]()))
              : undefined,
            "%JSON%":
              (typeof JSON === "undefined" ? "undefined" : _typeof2(JSON)) ===
              "object"
                ? JSON
                : undefined,
            "%Map%": typeof Map === "undefined" ? undefined : Map,
            "%MapIteratorPrototype%":
              typeof Map === "undefined" || !hasSymbols
                ? undefined
                : getProto(new Map()[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
            "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set === "undefined" ? undefined : Set,
            "%SetIteratorPrototype%":
              typeof Set === "undefined" || !hasSymbols
                ? undefined
                : getProto(new Set()[Symbol.iterator]()),
            "%SharedArrayBuffer%":
              typeof SharedArrayBuffer === "undefined"
                ? undefined
                : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": hasSymbols
              ? getProto(""[Symbol.iterator]())
              : undefined,
            "%Symbol%": hasSymbols ? Symbol : undefined,
            "%SyntaxError%": $SyntaxError,
            "%ThrowTypeError%": ThrowTypeError,
            "%TypedArray%": TypedArray,
            "%TypeError%": $TypeError,
            "%Uint8Array%":
              typeof Uint8Array === "undefined" ? undefined : Uint8Array,
            "%Uint8ClampedArray%":
              typeof Uint8ClampedArray === "undefined"
                ? undefined
                : Uint8ClampedArray,
            "%Uint16Array%":
              typeof Uint16Array === "undefined" ? undefined : Uint16Array,
            "%Uint32Array%":
              typeof Uint32Array === "undefined" ? undefined : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
            "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
            "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet
          };
          var doEval = function doEval(name) {
            var value;
            if (name === "%AsyncFunction%") {
              value = getEvalledConstructor("/*async*/ function () {}");
            } else if (name === "%GeneratorFunction%") {
              value = getEvalledConstructor("function* () {}");
            } else if (name === "%AsyncGeneratorFunction%") {
              value = getEvalledConstructor("/*async*/ function* () {}");
            } else if (name === "%AsyncGenerator%") {
              var fn = doEval("%AsyncGeneratorFunction%");
              if (fn) {
                value = fn.prototype;
              }
            } else if (name === "%AsyncIteratorPrototype%") {
              var gen = doEval("%AsyncGenerator%");
              if (gen) {
                value = getProto(gen.prototype);
              }
            }
            INTRINSICS[name] = value;
            return value;
          };
          var LEGACY_ALIASES = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": [
              "AsyncGeneratorFunction",
              "prototype",
              "prototype"
            ],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": [
              "GeneratorFunction",
              "prototype",
              "prototype"
            ],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
          };
          var bind = require("function-bind");
          var hasOwn = require("has");
          var $concat = bind.call(Function.call, Array.prototype.concat);
          var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
          var $replace = bind.call(Function.call, String.prototype.replace);
          var $strSlice = bind.call(Function.call, String.prototype.slice);
          var $exec = bind.call(Function.call, RegExp.prototype.exec);
          /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName =
            /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
          var reEscapeChar = /\\(\\)?/g;
          /** Used to match backslashes in property paths. */ var stringToPath =
            function stringToPath(string) {
              var first = $strSlice(string, 0, 1);
              var last = $strSlice(string, -1);
              if (first === "%" && last !== "%") {
                throw new $SyntaxError(
                  "invalid intrinsic syntax, expected closing `%`"
                );
              } else if (last === "%" && first !== "%") {
                throw new $SyntaxError(
                  "invalid intrinsic syntax, expected opening `%`"
                );
              }
              var result = [];
              $replace(
                string,
                rePropName,
                function (match, number, quote, subString) {
                  result[result.length] = quote
                    ? $replace(subString, reEscapeChar, "$1")
                    : number || match;
                }
              );
              return result;
            };
          /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(
            name,
            allowMissing
          ) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
              alias = LEGACY_ALIASES[intrinsicName];
              intrinsicName = "%" + alias[0] + "%";
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
              var value = INTRINSICS[intrinsicName];
              if (value === needsEval) {
                value = doEval(intrinsicName);
              }
              if (typeof value === "undefined" && !allowMissing) {
                throw new $TypeError(
                  "intrinsic " +
                    name +
                    " exists, but is not available. Please file an issue!"
                );
              }
              return { alias: alias, name: intrinsicName, value: value };
            }
            throw new $SyntaxError("intrinsic " + name + " does not exist!");
          };
          module.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== "string" || name.length === 0) {
              throw new $TypeError("intrinsic name must be a non-empty string");
            }
            if (arguments.length > 1 && typeof allowMissing !== "boolean") {
              throw new $TypeError('"allowMissing" argument must be a boolean');
            }
            if ($exec(/^%?[^%]*%?$/, name) === null) {
              throw new $SyntaxError(
                "`%` may not be present anywhere but at the beginning and end of the intrinsic name"
              );
            }
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
            var intrinsic = getBaseIntrinsic(
              "%" + intrinsicBaseName + "%",
              allowMissing
            );
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
              intrinsicBaseName = alias[0];
              $spliceApply(parts, $concat([0, 1], alias));
            }
            for (var i = 1, isOwn = true; i < parts.length; i += 1) {
              var part = parts[i];
              var first = $strSlice(part, 0, 1);
              var last = $strSlice(part, -1);
              if (
                (first === '"' ||
                  first === "'" ||
                  first === "`" ||
                  last === '"' ||
                  last === "'" ||
                  last === "`") &&
                first !== last
              ) {
                throw new $SyntaxError(
                  "property names with quotes must have matching quotes"
                );
              }
              if (part === "constructor" || !isOwn) {
                skipFurtherCaching = true;
              }
              intrinsicBaseName += "." + part;
              intrinsicRealName = "%" + intrinsicBaseName + "%";
              if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName];
              } else if (value != null) {
                if (!(part in value)) {
                  if (!allowMissing) {
                    throw new $TypeError(
                      "base intrinsic for " +
                        name +
                        " exists, but the property is not available."
                    );
                  }
                  return void undefined;
                }
                if ($gOPD && i + 1 >= parts.length) {
                  var desc = $gOPD(value, part);
                  isOwn = !!desc; // By convention, when a data property is converted to an accessor
                  // property to emulate a data property that does not suffer from
                  // the override mistake, that accessor's getter is marked with
                  // an `originalValue` property. Here, when we detect this, we
                  // uphold the illusion by pretending to see that original data
                  // property, i.e., returning the value rather than the getter
                  // itself.
                  if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                    value = desc.get;
                  } else {
                    value = value[part];
                  }
                } else {
                  isOwn = hasOwn(value, part);
                  value = value[part];
                }
                if (isOwn && !skipFurtherCaching) {
                  INTRINSICS[intrinsicRealName] = value;
                }
              }
            }
            return value;
          };
        },
        { "function-bind": 231, has: 236, "has-symbols": 233 }
      ],
      233: [
        function (require, module, exports) {
          "use strict";
          var origSymbol = typeof Symbol !== "undefined" && Symbol;
          var hasSymbolSham = require("./shams");
          module.exports = function hasNativeSymbols() {
            if (typeof origSymbol !== "function") {
              return false;
            }
            if (typeof Symbol !== "function") {
              return false;
            }
            if (_typeof2(origSymbol("foo")) !== "symbol") {
              return false;
            }
            if (_typeof2(Symbol("bar")) !== "symbol") {
              return false;
            }
            return hasSymbolSham();
          };
        },
        { "./shams": 234 }
      ],
      234: [
        function (require, module, exports) {
          "use strict";
          /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports =
            function hasSymbols() {
              if (
                typeof Symbol !== "function" ||
                typeof Object.getOwnPropertySymbols !== "function"
              ) {
                return false;
              }
              if (_typeof2(Symbol.iterator) === "symbol") {
                return true;
              }
              var obj = {};
              var sym = Symbol("test");
              var symObj = Object(sym);
              if (typeof sym === "string") {
                return false;
              }
              if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                return false;
              }
              if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                return false;
              } // temp disabled per https://github.com/ljharb/object.assign/issues/17
              // if (sym instanceof Symbol) { return false; }
              // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
              // if (!(symObj instanceof Symbol)) { return false; }
              // if (typeof Symbol.prototype.toString !== 'function') { return false; }
              // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
              var symVal = 42;
              obj[sym] = symVal;
              for (sym in obj) {
                return false;
              } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
              if (
                typeof Object.keys === "function" &&
                Object.keys(obj).length !== 0
              ) {
                return false;
              }
              if (
                typeof Object.getOwnPropertyNames === "function" &&
                Object.getOwnPropertyNames(obj).length !== 0
              ) {
                return false;
              }
              var syms = Object.getOwnPropertySymbols(obj);
              if (syms.length !== 1 || syms[0] !== sym) {
                return false;
              }
              if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                return false;
              }
              if (typeof Object.getOwnPropertyDescriptor === "function") {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (
                  descriptor.value !== symVal ||
                  descriptor.enumerable !== true
                ) {
                  return false;
                }
              }
              return true;
            };
        },
        {}
      ],
      235: [
        function (require, module, exports) {
          "use strict";
          var hasSymbols = require("has-symbols/shams");
          module.exports = function hasToStringTagShams() {
            return hasSymbols() && !!Symbol.toStringTag;
          };
        },
        { "has-symbols/shams": 234 }
      ],
      236: [
        function (require, module, exports) {
          "use strict";
          var bind = require("function-bind");
          module.exports = bind.call(
            Function.call,
            Object.prototype.hasOwnProperty
          );
        },
        { "function-bind": 231 }
      ],
      237: [
        function (require, module, exports) {
          var http = require("http");
          var url = require("url");
          var https = module.exports;
          for (var key in http) {
            if (http.hasOwnProperty(key)) https[key] = http[key];
          }
          https.request = function (params, cb) {
            params = validateParams(params);
            return http.request.call(this, params, cb);
          };
          https.get = function (params, cb) {
            params = validateParams(params);
            return http.get.call(this, params, cb);
          };
          function validateParams(params) {
            if (typeof params === "string") {
              params = url.parse(params);
            }
            if (!params.protocol) {
              params.protocol = "https:";
            }
            if (params.protocol !== "https:") {
              throw new Error(
                'Protocol "' +
                  params.protocol +
                  '" not supported. Expected "https:"'
              );
            }
            return params;
          }
        },
        { http: 252, url: 272 }
      ],
      238: [
        function (require, module, exports) {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read =
            function (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? nBytes - 1 : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];
              i += d;
              e = s & ((1 << -nBits) - 1);
              s >>= -nBits;
              nBits += eLen;
              for (
                ;
                nBits > 0;
                e = e * 256 + buffer[offset + i], i += d, nBits -= 8
              ) {}
              m = e & ((1 << -nBits) - 1);
              e >>= -nBits;
              nBits += mLen;
              for (
                ;
                nBits > 0;
                m = m * 256 + buffer[offset + i], i += d, nBits -= 8
              ) {}
              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };
          exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (
              ;
              mLen >= 8;
              buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
            ) {}
            e = (e << mLen) | m;
            eLen += mLen;
            for (
              ;
              eLen > 0;
              buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
            ) {}
            buffer[offset + i - d] |= s * 128;
          };
        },
        {}
      ],
      239: [
        function (require, module, exports) {
          if (typeof Object.create === "function") {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              }
            };
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function TempCtor() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              }
            };
          }
        },
        {}
      ],
      240: [
        function (require, module, exports) {
          "use strict";
          var hasToStringTag = require("has-tostringtag/shams")();
          var callBound = require("call-bind/callBound");
          var $toString = callBound("Object.prototype.toString");
          var isStandardArguments = function isArguments(value) {
            if (
              hasToStringTag &&
              value &&
              _typeof2(value) === "object" &&
              Symbol.toStringTag in value
            ) {
              return false;
            }
            return $toString(value) === "[object Arguments]";
          };
          var isLegacyArguments = function isArguments(value) {
            if (isStandardArguments(value)) {
              return true;
            }
            return (
              value !== null &&
              _typeof2(value) === "object" &&
              typeof value.length === "number" &&
              value.length >= 0 &&
              $toString(value) !== "[object Array]" &&
              $toString(value.callee) === "[object Function]"
            );
          };
          var supportsStandardArguments = (function () {
            return isStandardArguments(arguments);
          })();
          isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
          module.exports = supportsStandardArguments
            ? isStandardArguments
            : isLegacyArguments;
        },
        { "call-bind/callBound": 225, "has-tostringtag/shams": 235 }
      ],
      241: [
        function (require, module, exports) {
          /*!
           * Determine if an object is a Buffer
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */ // The _isBuffer check is for Safari 5-7 support, because it's missing
          // Object.prototype.constructor. Remove this eventually
          module.exports = function (obj) {
            return (
              obj != null &&
              (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
            );
          };
          function isBuffer(obj) {
            return (
              !!obj.constructor &&
              typeof obj.constructor.isBuffer === "function" &&
              obj.constructor.isBuffer(obj)
            );
          } // For Node v0.10 support. Remove this eventually.
          function isSlowBuffer(obj) {
            return (
              typeof obj.readFloatLE === "function" &&
              typeof obj.slice === "function" &&
              isBuffer(obj.slice(0, 0))
            );
          }
        },
        {}
      ],
      242: [
        function (require, module, exports) {
          "use strict";
          var fnToStr = Function.prototype.toString;
          var reflectApply =
            (typeof Reflect === "undefined" ? "undefined" : _typeof2(Reflect)) ===
              "object" &&
            Reflect !== null &&
            Reflect.apply;
          var badArrayLike;
          var isCallableMarker;
          if (
            typeof reflectApply === "function" &&
            typeof Object.defineProperty === "function"
          ) {
            try {
              badArrayLike = Object.defineProperty({}, "length", {
                get: function get() {
                  throw isCallableMarker;
                }
              });
              isCallableMarker = {}; // eslint-disable-next-line no-throw-literal
              reflectApply(
                function () {
                  throw 42;
                },
                null,
                badArrayLike
              );
            } catch (_) {
              if (_ !== isCallableMarker) {
                reflectApply = null;
              }
            }
          } else {
            reflectApply = null;
          }
          var constructorRegex = /^\s*class\b/;
          var isES6ClassFn = function isES6ClassFunction(value) {
            try {
              var fnStr = fnToStr.call(value);
              return constructorRegex.test(fnStr);
            } catch (e) {
              return false; // not a function
            }
          };
          var tryFunctionObject = function tryFunctionToStr(value) {
            try {
              if (isES6ClassFn(value)) {
                return false;
              }
              fnToStr.call(value);
              return true;
            } catch (e) {
              return false;
            }
          };
          var toStr = Object.prototype.toString;
          var fnClass = "[object Function]";
          var genClass = "[object GeneratorFunction]";
          var hasToStringTag =
            typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
          var isDDA =
            (typeof document === "undefined"
              ? "undefined"
              : _typeof2(document)) === "object"
              ? function isDocumentDotAll(value) {
                  /* globals document: false */ // in IE 8, typeof document.all is "object"
                  if (
                    typeof value === "undefined" ||
                    _typeof2(value) === "object"
                  ) {
                    try {
                      return value("") === null;
                    } catch (e) {
                      /**/
                    }
                  }
                  return false;
                }
              : function () {
                  return false;
                };
          module.exports = reflectApply
            ? function isCallable(value) {
                if (isDDA(value)) {
                  return true;
                }
                if (!value) {
                  return false;
                }
                if (typeof value !== "function" && _typeof2(value) !== "object") {
                  return false;
                }
                if (typeof value === "function" && !value.prototype) {
                  return true;
                }
                try {
                  reflectApply(value, null, badArrayLike);
                } catch (e) {
                  if (e !== isCallableMarker) {
                    return false;
                  }
                }
                return !isES6ClassFn(value);
              }
            : function isCallable(value) {
                if (isDDA(value)) {
                  return true;
                }
                if (!value) {
                  return false;
                }
                if (typeof value !== "function" && _typeof2(value) !== "object") {
                  return false;
                }
                if (typeof value === "function" && !value.prototype) {
                  return true;
                }
                if (hasToStringTag) {
                  return tryFunctionObject(value);
                }
                if (isES6ClassFn(value)) {
                  return false;
                }
                var strClass = toStr.call(value);
                return (
                  strClass === fnClass ||
                  strClass === genClass ||
                  tryFunctionObject(value)
                );
              };
        },
        {}
      ],
      243: [
        function (require, module, exports) {
          "use strict";
          var toStr = Object.prototype.toString;
          var fnToStr = Function.prototype.toString;
          var isFnRegex = /^\s*(?:function)?\*/;
          var hasToStringTag = require("has-tostringtag/shams")();
          var getProto = Object.getPrototypeOf;
          var getGeneratorFunc = function getGeneratorFunc() {
            // eslint-disable-line consistent-return
            if (!hasToStringTag) {
              return false;
            }
            try {
              return Function("return function*() {}")();
            } catch (e) {}
          };
          var GeneratorFunction;
          module.exports = function isGeneratorFunction(fn) {
            if (typeof fn !== "function") {
              return false;
            }
            if (isFnRegex.test(fnToStr.call(fn))) {
              return true;
            }
            if (!hasToStringTag) {
              var str = toStr.call(fn);
              return str === "[object GeneratorFunction]";
            }
            if (!getProto) {
              return false;
            }
            if (typeof GeneratorFunction === "undefined") {
              var generatorFunc = getGeneratorFunc();
              GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
            }
            return getProto(fn) === GeneratorFunction;
          };
        },
        { "has-tostringtag/shams": 235 }
      ],
      244: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              "use strict";
              var forEach = require("for-each");
              var availableTypedArrays = require("available-typed-arrays");
              var callBound = require("call-bind/callBound");
              var $toString = callBound("Object.prototype.toString");
              var hasToStringTag = require("has-tostringtag/shams")();
              var g = typeof globalThis === "undefined" ? global : globalThis;
              var typedArrays = availableTypedArrays();
              var $indexOf =
                callBound("Array.prototype.indexOf", true) ||
                function indexOf(array, value) {
                  for (var i = 0; i < array.length; i += 1) {
                    if (array[i] === value) {
                      return i;
                    }
                  }
                  return -1;
                };
              var $slice = callBound("String.prototype.slice");
              var toStrTags = {};
              var gOPD = require("es-abstract/helpers/getOwnPropertyDescriptor");
              var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
              if (hasToStringTag && gOPD && getPrototypeOf) {
                forEach(typedArrays, function (typedArray) {
                  var arr = new g[typedArray]();
                  if (Symbol.toStringTag in arr) {
                    var proto = getPrototypeOf(arr);
                    var descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor) {
                      var superProto = getPrototypeOf(proto);
                      descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    toStrTags[typedArray] = descriptor.get;
                  }
                });
              }
              var tryTypedArrays = function tryAllTypedArrays(value) {
                var anyTrue = false;
                forEach(toStrTags, function (getter, typedArray) {
                  if (!anyTrue) {
                    try {
                      anyTrue = getter.call(value) === typedArray;
                    } catch (e) {
                      /**/
                    }
                  }
                });
                return anyTrue;
              };
              module.exports = function isTypedArray(value) {
                if (!value || _typeof2(value) !== "object") {
                  return false;
                }
                if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                  var tag = $slice($toString(value), 8, -1);
                  return $indexOf(typedArrays, tag) > -1;
                }
                if (!gOPD) {
                  return false;
                }
                return tryTypedArrays(value);
              };
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "available-typed-arrays": 220,
          "call-bind/callBound": 225,
          "es-abstract/helpers/getOwnPropertyDescriptor": 227,
          "for-each": 229,
          "has-tostringtag/shams": 235
        }
      ],
      245: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              // 'path' module extracted from Node.js v8.11.1 (only the posix part)
              // transplited with Babel
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              "use strict";
              function assertPath(path) {
                if (typeof path !== "string") {
                  throw new TypeError(
                    "Path must be a string. Received " + JSON.stringify(path)
                  );
                }
              } // Resolves . and .. elements in a path with directory names
              function normalizeStringPosix(path, allowAboveRoot) {
                var res = "";
                var lastSegmentLength = 0;
                var lastSlash = -1;
                var dots = 0;
                var code;
                for (var i = 0; i <= path.length; ++i) {
                  if (i < path.length) code = path.charCodeAt(i);
                  else if (code === 47 /*/*/) break;
                  else code = 47 /*/*/;
                  if (code === 47 /*/*/) {
                    if (lastSlash === i - 1 || dots === 1) {
                      // NOOP
                    } else if (lastSlash !== i - 1 && dots === 2) {
                      if (
                        res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== 46 /*.*/ ||
                        res.charCodeAt(res.length - 2) !== 46 /*.*/
                      ) {
                        if (res.length > 2) {
                          var lastSlashIndex = res.lastIndexOf("/");
                          if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                              res = "";
                              lastSegmentLength = 0;
                            } else {
                              res = res.slice(0, lastSlashIndex);
                              lastSegmentLength =
                                res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                          }
                        } else if (res.length === 2 || res.length === 1) {
                          res = "";
                          lastSegmentLength = 0;
                          lastSlash = i;
                          dots = 0;
                          continue;
                        }
                      }
                      if (allowAboveRoot) {
                        if (res.length > 0) res += "/..";
                        else res = "..";
                        lastSegmentLength = 2;
                      }
                    } else {
                      if (res.length > 0)
                        res += "/" + path.slice(lastSlash + 1, i);
                      else res = path.slice(lastSlash + 1, i);
                      lastSegmentLength = i - lastSlash - 1;
                    }
                    lastSlash = i;
                    dots = 0;
                  } else if (code === 46 /*.*/ && dots !== -1) {
                    ++dots;
                  } else {
                    dots = -1;
                  }
                }
                return res;
              }
              function _format(sep, pathObject) {
                var dir = pathObject.dir || pathObject.root;
                var base =
                  pathObject.base ||
                  (pathObject.name || "") + (pathObject.ext || "");
                if (!dir) {
                  return base;
                }
                if (dir === pathObject.root) {
                  return dir + base;
                }
                return dir + sep + base;
              }
              var posix = {
                // path.resolve([from ...], to)
                resolve: function resolve() {
                  var resolvedPath = "";
                  var resolvedAbsolute = false;
                  var cwd;
                  for (
                    var i = arguments.length - 1;
                    i >= -1 && !resolvedAbsolute;
                    i--
                  ) {
                    var path;
                    if (i >= 0) path = arguments[i];
                    else {
                      if (cwd === undefined) cwd = process.cwd();
                      path = cwd;
                    }
                    assertPath(path); // Skip empty entries
                    if (path.length === 0) {
                      continue;
                    }
                    resolvedPath = path + "/" + resolvedPath;
                    resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
                  } // At this point the path should be resolved to a full absolute path, but
                  // handle relative paths to be safe (might happen when process.cwd() fails)
                  // Normalize the path
                  resolvedPath = normalizeStringPosix(
                    resolvedPath,
                    !resolvedAbsolute
                  );
                  if (resolvedAbsolute) {
                    if (resolvedPath.length > 0) return "/" + resolvedPath;
                    else return "/";
                  } else if (resolvedPath.length > 0) {
                    return resolvedPath;
                  } else {
                    return ".";
                  }
                },
                normalize: function normalize(path) {
                  assertPath(path);
                  if (path.length === 0) return ".";
                  var isAbsolute = path.charCodeAt(0) === 47; /*/*/
                  var trailingSeparator =
                    path.charCodeAt(path.length - 1) === 47; /*/*/ // Normalize the path
                  path = normalizeStringPosix(path, !isAbsolute);
                  if (path.length === 0 && !isAbsolute) path = ".";
                  if (path.length > 0 && trailingSeparator) path += "/";
                  if (isAbsolute) return "/" + path;
                  return path;
                },
                isAbsolute: function isAbsolute(path) {
                  assertPath(path);
                  return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
                },
                join: function join() {
                  if (arguments.length === 0) return ".";
                  var joined;
                  for (var i = 0; i < arguments.length; ++i) {
                    var arg = arguments[i];
                    assertPath(arg);
                    if (arg.length > 0) {
                      if (joined === undefined) joined = arg;
                      else joined += "/" + arg;
                    }
                  }
                  if (joined === undefined) return ".";
                  return posix.normalize(joined);
                },
                relative: function relative(from, to) {
                  assertPath(from);
                  assertPath(to);
                  if (from === to) return "";
                  from = posix.resolve(from);
                  to = posix.resolve(to);
                  if (from === to) return ""; // Trim any leading backslashes
                  var fromStart = 1;
                  for (; fromStart < from.length; ++fromStart) {
                    if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
                  }
                  var fromEnd = from.length;
                  var fromLen = fromEnd - fromStart; // Trim any leading backslashes
                  var toStart = 1;
                  for (; toStart < to.length; ++toStart) {
                    if (to.charCodeAt(toStart) !== 47 /*/*/) break;
                  }
                  var toEnd = to.length;
                  var toLen = toEnd - toStart; // Compare paths to find the longest common path from root
                  var length = fromLen < toLen ? fromLen : toLen;
                  var lastCommonSep = -1;
                  var i = 0;
                  for (; i <= length; ++i) {
                    if (i === length) {
                      if (toLen > length) {
                        if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                          // We get here if `from` is the exact base path for `to`.
                          // For example: from='/foo/bar'; to='/foo/bar/baz'
                          return to.slice(toStart + i + 1);
                        } else if (i === 0) {
                          // We get here if `from` is the root
                          // For example: from='/'; to='/foo'
                          return to.slice(toStart + i);
                        }
                      } else if (fromLen > length) {
                        if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                          // We get here if `to` is the exact base path for `from`.
                          // For example: from='/foo/bar/baz'; to='/foo/bar'
                          lastCommonSep = i;
                        } else if (i === 0) {
                          // We get here if `to` is the root.
                          // For example: from='/foo'; to='/'
                          lastCommonSep = 0;
                        }
                      }
                      break;
                    }
                    var fromCode = from.charCodeAt(fromStart + i);
                    var toCode = to.charCodeAt(toStart + i);
                    if (fromCode !== toCode) break;
                    else if (fromCode === 47 /*/*/) lastCommonSep = i;
                  }
                  var out = ""; // Generate the relative path based on the path difference between `to`
                  // and `from`
                  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                    if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                      if (out.length === 0) out += "..";
                      else out += "/..";
                    }
                  } // Lastly, append the rest of the destination (`to`) path that comes after
                  // the common path parts
                  if (out.length > 0)
                    return out + to.slice(toStart + lastCommonSep);
                  else {
                    toStart += lastCommonSep;
                    if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
                    return to.slice(toStart);
                  }
                },
                _makeLong: function _makeLong(path) {
                  return path;
                },
                dirname: function dirname(path) {
                  assertPath(path);
                  if (path.length === 0) return ".";
                  var code = path.charCodeAt(0);
                  var hasRoot = code === 47; /*/*/
                  var end = -1;
                  var matchedSlash = true;
                  for (var i = path.length - 1; i >= 1; --i) {
                    code = path.charCodeAt(i);
                    if (code === 47 /*/*/) {
                      if (!matchedSlash) {
                        end = i;
                        break;
                      }
                    } else {
                      // We saw the first non-path separator
                      matchedSlash = false;
                    }
                  }
                  if (end === -1) return hasRoot ? "/" : ".";
                  if (hasRoot && end === 1) return "//";
                  return path.slice(0, end);
                },
                basename: function basename(path, ext) {
                  if (ext !== undefined && typeof ext !== "string")
                    throw new TypeError('"ext" argument must be a string');
                  assertPath(path);
                  var start = 0;
                  var end = -1;
                  var matchedSlash = true;
                  var i;
                  if (
                    ext !== undefined &&
                    ext.length > 0 &&
                    ext.length <= path.length
                  ) {
                    if (ext.length === path.length && ext === path) return "";
                    var extIdx = ext.length - 1;
                    var firstNonSlashEnd = -1;
                    for (i = path.length - 1; i >= 0; --i) {
                      var code = path.charCodeAt(i);
                      if (code === 47 /*/*/) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                          start = i + 1;
                          break;
                        }
                      } else {
                        if (firstNonSlashEnd === -1) {
                          // We saw the first non-path separator, remember this index in case
                          // we need it if the extension ends up not matching
                          matchedSlash = false;
                          firstNonSlashEnd = i + 1;
                        }
                        if (extIdx >= 0) {
                          // Try to match the explicit extension
                          if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                              // We matched the extension, so mark this as the end of our path
                              // component
                              end = i;
                            }
                          } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                          }
                        }
                      }
                    }
                    if (start === end) end = firstNonSlashEnd;
                    else if (end === -1) end = path.length;
                    return path.slice(start, end);
                  } else {
                    for (i = path.length - 1; i >= 0; --i) {
                      if (path.charCodeAt(i) === 47 /*/*/) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                          start = i + 1;
                          break;
                        }
                      } else if (end === -1) {
                        // We saw the first non-path separator, mark this as the end of our
                        // path component
                        matchedSlash = false;
                        end = i + 1;
                      }
                    }
                    if (end === -1) return "";
                    return path.slice(start, end);
                  }
                },
                extname: function extname(path) {
                  assertPath(path);
                  var startDot = -1;
                  var startPart = 0;
                  var end = -1;
                  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
                  // after any path separator we find
                  var preDotState = 0;
                  for (var i = path.length - 1; i >= 0; --i) {
                    var code = path.charCodeAt(i);
                    if (code === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                      }
                      continue;
                    }
                    if (end === -1) {
                      // We saw the first non-path separator, mark this as the end of our
                      // extension
                      matchedSlash = false;
                      end = i + 1;
                    }
                    if (code === 46 /*.*/) {
                      // If this is our first dot, mark it as the start of our extension
                      if (startDot === -1) startDot = i;
                      else if (preDotState !== 1) preDotState = 1;
                    } else if (startDot !== -1) {
                      // We saw a non-dot and non-path separator before our dot, so we should
                      // have a good chance at having a non-empty extension
                      preDotState = -1;
                    }
                  }
                  if (
                    startDot === -1 ||
                    end === -1 || // We saw a non-dot character immediately before the dot
                    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                    (preDotState === 1 &&
                      startDot === end - 1 &&
                      startDot === startPart + 1)
                  ) {
                    return "";
                  }
                  return path.slice(startDot, end);
                },
                format: function format(pathObject) {
                  if (pathObject === null || _typeof2(pathObject) !== "object") {
                    throw new TypeError(
                      'The "pathObject" argument must be of type Object. Received type ' +
                        _typeof2(pathObject)
                    );
                  }
                  return _format("/", pathObject);
                },
                parse: function parse(path) {
                  assertPath(path);
                  var ret = { root: "", dir: "", base: "", ext: "", name: "" };
                  if (path.length === 0) return ret;
                  var code = path.charCodeAt(0);
                  var isAbsolute = code === 47; /*/*/
                  var start;
                  if (isAbsolute) {
                    ret.root = "/";
                    start = 1;
                  } else {
                    start = 0;
                  }
                  var startDot = -1;
                  var startPart = 0;
                  var end = -1;
                  var matchedSlash = true;
                  var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
                  // after any path separator we find
                  var preDotState = 0; // Get non-dir info
                  for (; i >= start; --i) {
                    code = path.charCodeAt(i);
                    if (code === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                      }
                      continue;
                    }
                    if (end === -1) {
                      // We saw the first non-path separator, mark this as the end of our
                      // extension
                      matchedSlash = false;
                      end = i + 1;
                    }
                    if (code === 46 /*.*/) {
                      // If this is our first dot, mark it as the start of our extension
                      if (startDot === -1) startDot = i;
                      else if (preDotState !== 1) preDotState = 1;
                    } else if (startDot !== -1) {
                      // We saw a non-dot and non-path separator before our dot, so we should
                      // have a good chance at having a non-empty extension
                      preDotState = -1;
                    }
                  }
                  if (
                    startDot === -1 ||
                    end === -1 || // We saw a non-dot character immediately before the dot
                    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                    (preDotState === 1 &&
                      startDot === end - 1 &&
                      startDot === startPart + 1)
                  ) {
                    if (end !== -1) {
                      if (startPart === 0 && isAbsolute)
                        ret.base = ret.name = path.slice(1, end);
                      else ret.base = ret.name = path.slice(startPart, end);
                    }
                  } else {
                    if (startPart === 0 && isAbsolute) {
                      ret.name = path.slice(1, startDot);
                      ret.base = path.slice(1, end);
                    } else {
                      ret.name = path.slice(startPart, startDot);
                      ret.base = path.slice(startPart, end);
                    }
                    ret.ext = path.slice(startDot, end);
                  }
                  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
                  else if (isAbsolute) ret.dir = "/";
                  return ret;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
              };
              posix.posix = posix;
              module.exports = posix;
            }.call(this));
          }.call(this, require("_process")));
        },
        { _process: 246 }
      ],
      246: [
        function (require, module, exports) {
          // shim for using process in browser
          var process = (module.exports = {}); // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function () {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0);
            } // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker);
            } // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          }; // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = ""; // empty string to avoid regexp issues
          process.versions = {};
          function noop() {}
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function (name) {
            return [];
          };
          process.binding = function (name) {
            throw new Error("process.binding is not supported");
          };
          process.cwd = function () {
            return "/";
          };
          process.chdir = function (dir) {
            throw new Error("process.chdir is not supported");
          };
          process.umask = function () {
            return 0;
          };
        },
        {}
      ],
      247: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              /*! https://mths.be/punycode v1.4.1 by @mathias */ (function (
                root
              ) {
                /** Detect free variables */ var freeExports =
                  _typeof2(exports) == "object" &&
                  exports &&
                  !exports.nodeType &&
                  exports;
                var freeModule =
                  _typeof2(module) == "object" &&
                  module &&
                  !module.nodeType &&
                  module;
                var freeGlobal = _typeof2(global) == "object" && global;
                if (
                  freeGlobal.global === freeGlobal ||
                  freeGlobal.window === freeGlobal ||
                  freeGlobal.self === freeGlobal
                ) {
                  root = freeGlobal;
                }
                /**
                 * The `punycode` object.
                 * @name punycode
                 * @type Object
                 */ var punycode,
                  /** Highest positive signed 32-bit float value */ maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                  /** Bootstring parameters */ base = 36,
                  tMin = 1,
                  tMax = 26,
                  skew = 38,
                  damp = 700,
                  initialBias = 72,
                  initialN = 128, // 0x80
                  delimiter = "-", // '\x2D'
                  /** Regular expressions */ regexPunycode = /^xn--/,
                  regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                  /** Error messages */ errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                  },
                  /** Convenience shortcuts */ baseMinusTMin = base - tMin,
                  floor = Math.floor,
                  stringFromCharCode = String.fromCharCode,
                  /** Temporary variable */ key;
                /*--------------------------------------------------------------------------*/ /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */ function error(type) {
                  throw new RangeError(errors[type]);
                }
                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */ function map(array, fn) {
                  var length = array.length;
                  var result = [];
                  while (length--) {
                    result[length] = fn(array[length]);
                  }
                  return result;
                }
                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */ function mapDomain(string, fn) {
                  var parts = string.split("@");
                  var result = "";
                  if (parts.length > 1) {
                    // In email addresses, only the domain name should be punycoded. Leave
                    // the local part (i.e. everything up to `@`) intact.
                    result = parts[0] + "@";
                    string = parts[1];
                  } // Avoid `split(regex)` for IE8 compatibility. See #17.
                  string = string.replace(regexSeparators, "\x2E");
                  var labels = string.split(".");
                  var encoded = map(labels, fn).join(".");
                  return result + encoded;
                }
                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */ function ucs2decode(string) {
                  var output = [],
                    counter = 0,
                    length = string.length,
                    value,
                    extra;
                  while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                      // high surrogate, and there is a next character
                      extra = string.charCodeAt(counter++);
                      if ((extra & 0xfc00) == 0xdc00) {
                        // low surrogate
                        output.push(
                          ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                        );
                      } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                }
                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */ function ucs2encode(array) {
                  return map(array, function (value) {
                    var output = "";
                    if (value > 0xffff) {
                      value -= 0x10000;
                      output += stringFromCharCode(
                        ((value >>> 10) & 0x3ff) | 0xd800
                      );
                      value = 0xdc00 | (value & 0x3ff);
                    }
                    output += stringFromCharCode(value);
                    return output;
                  }).join("");
                }
                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */ function basicToDigit(codePoint) {
                  if (codePoint - 48 < 10) {
                    return codePoint - 22;
                  }
                  if (codePoint - 65 < 26) {
                    return codePoint - 65;
                  }
                  if (codePoint - 97 < 26) {
                    return codePoint - 97;
                  }
                  return base;
                }
                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */ function digitToBasic(digit, flag) {
                  //  0..25 map to ASCII a..z or A..Z
                  // 26..35 map to ASCII 0..9
                  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */ function adapt(delta, numPoints, firstTime) {
                  var k = 0;
                  delta = firstTime ? floor(delta / damp) : delta >> 1;
                  delta += floor(delta / numPoints);
                  for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {
                    delta = floor(delta / baseMinusTMin);
                  }
                  return floor(
                    k + ((baseMinusTMin + 1) * delta) / (delta + skew)
                  );
                }
                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */ function decode(input) {
                  // Don't use UCS-2
                  var output = [],
                    inputLength = input.length,
                    out,
                    i = 0,
                    n = initialN,
                    bias = initialBias,
                    basic,
                    j,
                    index,
                    oldi,
                    w,
                    k,
                    digit,
                    t,
                    /** Cached calculation results */ baseMinusT; // Handle the basic code points: let `basic` be the number of input code
                  // points before the last delimiter, or `0` if there is none, then copy
                  // the first basic code points to the output.
                  basic = input.lastIndexOf(delimiter);
                  if (basic < 0) {
                    basic = 0;
                  }
                  for (j = 0; j < basic; ++j) {
                    // if it's not a basic code point
                    if (input.charCodeAt(j) >= 0x80) {
                      error("not-basic");
                    }
                    output.push(input.charCodeAt(j));
                  } // Main decoding loop: start just after the last delimiter if any basic code
                  // points were copied; start at the beginning otherwise.
                  for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    // `index` is the index of the next character to be consumed.
                    // Decode a generalized variable-length integer into `delta`,
                    // which gets added to `i`. The overflow checking is easier
                    // if we increase `i` as we go, then subtract off its starting
                    // value at the end to obtain `delta`.
                    for (oldi = i, w = 1, k = base; ; k += base) {
                      if (index >= inputLength) {
                        error("invalid-input");
                      }
                      digit = basicToDigit(input.charCodeAt(index++));
                      if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error("overflow");
                      }
                      i += digit * w;
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (digit < t) {
                        break;
                      }
                      baseMinusT = base - t;
                      if (w > floor(maxInt / baseMinusT)) {
                        error("overflow");
                      }
                      w *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
                    // incrementing `n` each time, so we'll fix that now:
                    if (floor(i / out) > maxInt - n) {
                      error("overflow");
                    }
                    n += floor(i / out);
                    i %= out; // Insert `n` at position `i` of the output
                    output.splice(i++, 0, n);
                  }
                  return ucs2encode(output);
                }
                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */ function encode(input) {
                  var n,
                    delta,
                    handledCPCount,
                    basicLength,
                    bias,
                    j,
                    m,
                    q,
                    k,
                    t,
                    currentValue,
                    output = [],
                    /** `inputLength` will hold the number of code points in `input`. */ inputLength,
                    /** Cached calculation results */ handledCPCountPlusOne,
                    baseMinusT,
                    qMinusT; // Convert the input in UCS-2 to Unicode
                  input = ucs2decode(input); // Cache the length
                  inputLength = input.length; // Initialize the state
                  n = initialN;
                  delta = 0;
                  bias = initialBias; // Handle the basic code points
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < 0x80) {
                      output.push(stringFromCharCode(currentValue));
                    }
                  }
                  handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
                  // `basicLength` is the number of basic code points.
                  // Finish the basic string - if it is not empty - with a delimiter
                  if (basicLength) {
                    output.push(delimiter);
                  } // Main encoding loop:
                  while (handledCPCount < inputLength) {
                    // All non-basic code points < n have been handled already. Find the next
                    // larger one:
                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                      }
                    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                    // but guard against overflow
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                      error("overflow");
                    }
                    delta += (m - n) * handledCPCountPlusOne;
                    n = m;
                    for (j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue < n && ++delta > maxInt) {
                        error("overflow");
                      }
                      if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base; ; k += base) {
                          t =
                            k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                          if (q < t) {
                            break;
                          }
                          qMinusT = q - t;
                          baseMinusT = base - t;
                          output.push(
                            stringFromCharCode(
                              digitToBasic(t + (qMinusT % baseMinusT), 0)
                            )
                          );
                          q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(
                          delta,
                          handledCPCountPlusOne,
                          handledCPCount == basicLength
                        );
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n;
                  }
                  return output.join("");
                }
                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */ function toUnicode(input) {
                  return mapDomain(input, function (string) {
                    return regexPunycode.test(string)
                      ? decode(string.slice(4).toLowerCase())
                      : string;
                  });
                }
                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */ function toASCII(input) {
                  return mapDomain(input, function (string) {
                    return regexNonASCII.test(string)
                      ? "xn--" + encode(string)
                      : string;
                  });
                }
                /*--------------------------------------------------------------------------*/ /** Define the public API */ punycode =
                  {
                    /**
                     * A string representing the current Punycode.js version number.
                     * @memberOf punycode
                     * @type String
                     */ version: "1.4.1",
                    /**
                     * An object of methods to convert from JavaScript's internal character
                     * representation (UCS-2) to Unicode code points, and back.
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode
                     * @type Object
                     */ ucs2: { decode: ucs2decode, encode: ucs2encode },
                    decode: decode,
                    encode: encode,
                    toASCII: toASCII,
                    toUnicode: toUnicode
                  }; /** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (
                  typeof define == "function" &&
                  _typeof2(define.amd) == "object" &&
                  define.amd
                ) {
                  define("punycode", function () {
                    return punycode;
                  });
                } else if (freeExports && freeModule) {
                  if (module.exports == freeExports) {
                    // in Node.js, io.js, or RingoJS v0.8.0+
                    freeModule.exports = punycode;
                  } else {
                    // in Narwhal or RingoJS v0.7.0-
                    for (key in punycode) {
                      punycode.hasOwnProperty(key) &&
                        (freeExports[key] = punycode[key]);
                    }
                  }
                } else {
                  // in Rhino or a web browser
                  root.punycode = punycode;
                }
              })(this);
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      248: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          "use strict"; // If obj.hasOwnProperty has been overridden, then calling
          // obj.hasOwnProperty(prop) will break.
          // See: https://github.com/joyent/node/issues/1707
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          module.exports = function (qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
              return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1000;
            if (options && typeof options.maxKeys === "number") {
              maxKeys = options.maxKeys;
            }
            var len = qs.length; // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, "%20"),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v;
              if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
              } else {
                kstr = x;
                vstr = "";
              }
              k = decodeURIComponent(kstr);
              v = decodeURIComponent(vstr);
              if (!hasOwnProperty(obj, k)) {
                obj[k] = v;
              } else if (isArray(obj[k])) {
                obj[k].push(v);
              } else {
                obj[k] = [obj[k], v];
              }
            }
            return obj;
          };
          var isArray =
            Array.isArray ||
            function (xs) {
              return Object.prototype.toString.call(xs) === "[object Array]";
            };
        },
        {}
      ],
      249: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          "use strict";
          var stringifyPrimitive = function stringifyPrimitive(v) {
            switch (_typeof2(v)) {
              case "string":
                return v;
              case "boolean":
                return v ? "true" : "false";
              case "number":
                return isFinite(v) ? v : "";
              default:
                return "";
            }
          };
          module.exports = function (obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
              obj = undefined;
            }
            if (_typeof2(obj) === "object") {
              return map(objectKeys(obj), function (k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (isArray(obj[k])) {
                  return map(obj[k], function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
              }).join(sep);
            }
            if (!name) return "";
            return (
              encodeURIComponent(stringifyPrimitive(name)) +
              eq +
              encodeURIComponent(stringifyPrimitive(obj))
            );
          };
          var isArray =
            Array.isArray ||
            function (xs) {
              return Object.prototype.toString.call(xs) === "[object Array]";
            };
          function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              res.push(f(xs[i], i));
            }
            return res;
          }
          var objectKeys =
            Object.keys ||
            function (obj) {
              var res = [];
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
              }
              return res;
            };
        },
        {}
      ],
      250: [
        function (require, module, exports) {
          "use strict";
          exports.decode = exports.parse = require("./decode");
          exports.encode = exports.stringify = require("./encode");
        },
        { "./decode": 248, "./encode": 249 }
      ],
      251: [
        function (require, module, exports) {
          /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("buffer");
          var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key];
            }
          }
          if (
            Buffer.from &&
            Buffer.alloc &&
            Buffer.allocUnsafe &&
            Buffer.allocUnsafeSlow
          ) {
            module.exports = buffer;
          } else {
            // Copy properties from require('buffer')
            copyProps(buffer, exports);
            exports.Buffer = SafeBuffer;
          }
          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length);
          }
          SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer
          copyProps(Buffer, SafeBuffer);
          SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              throw new TypeError("Argument must not be a number");
            }
            return Buffer(arg, encodingOrOffset, length);
          };
          SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            var buf = Buffer(size);
            if (fill !== undefined) {
              if (typeof encoding === "string") {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
            } else {
              buf.fill(0);
            }
            return buf;
          };
          SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return Buffer(size);
          };
          SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return buffer.SlowBuffer(size);
          };
        },
        { buffer: 223 }
      ],
      252: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              var ClientRequest = require("./lib/request");
              var response = require("./lib/response");
              var extend = require("xtend");
              var statusCodes = require("builtin-status-codes");
              var url = require("url");
              var http = exports;
              http.request = function (opts, cb) {
                if (typeof opts === "string") opts = url.parse(opts);
                else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol
                // will result in a (valid) protocol-relative url. However, this won't work if
                // the protocol is something else, like 'file:'
                var defaultProtocol =
                  global.location.protocol.search(/^https?:$/) === -1
                    ? "http:"
                    : "";
                var protocol = opts.protocol || defaultProtocol;
                var host = opts.hostname || opts.host;
                var port = opts.port;
                var path = opts.path || "/"; // Necessary for IPv6 addresses
                if (host && host.indexOf(":") !== -1) host = "[" + host + "]"; // This may be a relative url. The browser should always be able to interpret it correctly.
                opts.url =
                  (host ? protocol + "//" + host : "") +
                  (port ? ":" + port : "") +
                  path;
                opts.method = (opts.method || "GET").toUpperCase();
                opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode
                var req = new ClientRequest(opts);
                if (cb) req.on("response", cb);
                return req;
              };
              http.get = function get(opts, cb) {
                var req = http.request(opts, cb);
                req.end();
                return req;
              };
              http.ClientRequest = ClientRequest;
              http.IncomingMessage = response.IncomingMessage;
              http.Agent = function () {};
              http.Agent.defaultMaxSockets = 4;
              http.globalAgent = new http.Agent();
              http.STATUS_CODES = statusCodes;
              http.METHODS = [
                "CHECKOUT",
                "CONNECT",
                "COPY",
                "DELETE",
                "GET",
                "HEAD",
                "LOCK",
                "M-SEARCH",
                "MERGE",
                "MKACTIVITY",
                "MKCOL",
                "MOVE",
                "NOTIFY",
                "OPTIONS",
                "PATCH",
                "POST",
                "PROPFIND",
                "PROPPATCH",
                "PURGE",
                "PUT",
                "REPORT",
                "SEARCH",
                "SUBSCRIBE",
                "TRACE",
                "UNLOCK",
                "UNSUBSCRIBE"
              ];
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "./lib/request": 254,
          "./lib/response": 255,
          "builtin-status-codes": 224,
          url: 272,
          xtend: 279
        }
      ],
      253: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              exports.fetch =
                isFunction(global.fetch) && isFunction(global.ReadableStream);
              exports.writableStream = isFunction(global.WritableStream);
              exports.abortController = isFunction(global.AbortController); // The xhr request to example.com may violate some restrictive CSP configurations,
              // so if we're running in a browser that supports `fetch`, avoid calling getXHR()
              // and assume support for certain features below.
              var xhr;
              function getXHR() {
                // Cache the xhr value
                if (xhr !== undefined) return xhr;
                if (global.XMLHttpRequest) {
                  xhr = new global.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work
                  // cross domain), use the page location. Otherwise use example.com
                  // Note: this doesn't actually make an http request.
                  try {
                    xhr.open(
                      "GET",
                      global.XDomainRequest ? "/" : "https://example.com"
                    );
                  } catch (e) {
                    xhr = null;
                  }
                } else {
                  // Service workers don't have XHR
                  xhr = null;
                }
                return xhr;
              }
              function checkTypeSupport(type) {
                var xhr = getXHR();
                if (!xhr) return false;
                try {
                  xhr.responseType = type;
                  return xhr.responseType === type;
                } catch (e) {}
                return false;
              } // If fetch is supported, then arraybuffer will be supported too. Skip calling
              // checkTypeSupport(), since that calls getXHR().
              exports.arraybuffer =
                exports.fetch || checkTypeSupport("arraybuffer"); // These next two tests unavoidably show warnings in Chrome. Since fetch will always
              // be used if it's available, just return false for these to avoid the warnings.
              exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
              exports.mozchunkedarraybuffer =
                !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer"); // If fetch is supported, then overrideMimeType will be supported too. Skip calling
              // getXHR().
              exports.overrideMimeType =
                exports.fetch ||
                (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
              function isFunction(value) {
                return typeof value === "function";
              }
              xhr = null; // Help gc
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      254: [
        function (require, module, exports) {
          (function (process, global, Buffer) {
            (function () {
              var capability = require("./capability");
              var inherits = require("inherits");
              var response = require("./response");
              var stream = require("readable-stream");
              var IncomingMessage = response.IncomingMessage;
              var rStates = response.readyStates;
              function decideMode(preferBinary, useFetch) {
                if (capability.fetch && useFetch) {
                  return "fetch";
                } else if (capability.mozchunkedarraybuffer) {
                  return "moz-chunked-arraybuffer";
                } else if (capability.msstream) {
                  return "ms-stream";
                } else if (capability.arraybuffer && preferBinary) {
                  return "arraybuffer";
                } else {
                  return "text";
                }
              }
              var ClientRequest = (module.exports = function (opts) {
                var self = this;
                stream.Writable.call(self);
                self._opts = opts;
                self._body = [];
                self._headers = {};
                if (opts.auth)
                  self.setHeader(
                    "Authorization",
                    "Basic " + Buffer.from(opts.auth).toString("base64")
                  );
                Object.keys(opts.headers).forEach(function (name) {
                  self.setHeader(name, opts.headers[name]);
                });
                var preferBinary;
                var useFetch = true;
                if (
                  opts.mode === "disable-fetch" ||
                  ("requestTimeout" in opts && !capability.abortController)
                ) {
                  // If the use of XHR should be preferred. Not typically needed.
                  useFetch = false;
                  preferBinary = true;
                } else if (opts.mode === "prefer-streaming") {
                  // If streaming is a high priority but binary compatibility and
                  // the accuracy of the 'content-type' header aren't
                  preferBinary = false;
                } else if (opts.mode === "allow-wrong-content-type") {
                  // If streaming is more important than preserving the 'content-type' header
                  preferBinary = !capability.overrideMimeType;
                } else if (
                  !opts.mode ||
                  opts.mode === "default" ||
                  opts.mode === "prefer-fast"
                ) {
                  // Use binary if text streaming may corrupt data or the content-type header, or for speed
                  preferBinary = true;
                } else {
                  throw new Error("Invalid value for opts.mode");
                }
                self._mode = decideMode(preferBinary, useFetch);
                self._fetchTimer = null;
                self._socketTimeout = null;
                self._socketTimer = null;
                self.on("finish", function () {
                  self._onFinish();
                });
              });
              inherits(ClientRequest, stream.Writable);
              ClientRequest.prototype.setHeader = function (name, value) {
                var self = this;
                var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe
                // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
                // http-browserify did it, so I will too.
                if (unsafeHeaders.indexOf(lowerName) !== -1) return;
                self._headers[lowerName] = { name: name, value: value };
              };
              ClientRequest.prototype.getHeader = function (name) {
                var header = this._headers[name.toLowerCase()];
                if (header) return header.value;
                return null;
              };
              ClientRequest.prototype.removeHeader = function (name) {
                var self = this;
                delete self._headers[name.toLowerCase()];
              };
              ClientRequest.prototype._onFinish = function () {
                var self = this;
                if (self._destroyed) return;
                var opts = self._opts;
                if ("timeout" in opts && opts.timeout !== 0) {
                  self.setTimeout(opts.timeout);
                }
                var headersObj = self._headers;
                var body = null;
                if (opts.method !== "GET" && opts.method !== "HEAD") {
                  body = new Blob(self._body, {
                    type: (headersObj["content-type"] || {}).value || ""
                  });
                } // create flattened list of headers
                var headersList = [];
                Object.keys(headersObj).forEach(function (keyName) {
                  var name = headersObj[keyName].name;
                  var value = headersObj[keyName].value;
                  if (Array.isArray(value)) {
                    value.forEach(function (v) {
                      headersList.push([name, v]);
                    });
                  } else {
                    headersList.push([name, value]);
                  }
                });
                if (self._mode === "fetch") {
                  var signal = null;
                  if (capability.abortController) {
                    var controller = new AbortController();
                    signal = controller.signal;
                    self._fetchAbortController = controller;
                    if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                      self._fetchTimer = global.setTimeout(function () {
                        self.emit("requestTimeout");
                        if (self._fetchAbortController)
                          self._fetchAbortController.abort();
                      }, opts.requestTimeout);
                    }
                  }
                  global
                    .fetch(self._opts.url, {
                      method: self._opts.method,
                      headers: headersList,
                      body: body || undefined,
                      mode: "cors",
                      credentials: opts.withCredentials
                        ? "include"
                        : "same-origin",
                      signal: signal
                    })
                    .then(
                      function (response) {
                        self._fetchResponse = response;
                        self._resetTimers(false);
                        self._connect();
                      },
                      function (reason) {
                        self._resetTimers(true);
                        if (!self._destroyed) self.emit("error", reason);
                      }
                    );
                } else {
                  var xhr = (self._xhr = new global.XMLHttpRequest());
                  try {
                    xhr.open(self._opts.method, self._opts.url, true);
                  } catch (err) {
                    process.nextTick(function () {
                      self.emit("error", err);
                    });
                    return;
                  } // Can't set responseType on really old browsers
                  if ("responseType" in xhr) xhr.responseType = self._mode;
                  if ("withCredentials" in xhr)
                    xhr.withCredentials = !!opts.withCredentials;
                  if (self._mode === "text" && "overrideMimeType" in xhr)
                    xhr.overrideMimeType("text/plain; charset=x-user-defined");
                  if ("requestTimeout" in opts) {
                    xhr.timeout = opts.requestTimeout;
                    xhr.ontimeout = function () {
                      self.emit("requestTimeout");
                    };
                  }
                  headersList.forEach(function (header) {
                    xhr.setRequestHeader(header[0], header[1]);
                  });
                  self._response = null;
                  xhr.onreadystatechange = function () {
                    switch (xhr.readyState) {
                      case rStates.LOADING:
                      case rStates.DONE:
                        self._onXHRProgress();
                        break;
                    }
                  }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined
                  // in onprogress, not in onreadystatechange with xhr.readyState = 3
                  if (self._mode === "moz-chunked-arraybuffer") {
                    xhr.onprogress = function () {
                      self._onXHRProgress();
                    };
                  }
                  xhr.onerror = function () {
                    if (self._destroyed) return;
                    self._resetTimers(true);
                    self.emit("error", new Error("XHR error"));
                  };
                  try {
                    xhr.send(body);
                  } catch (err) {
                    process.nextTick(function () {
                      self.emit("error", err);
                    });
                    return;
                  }
                }
              };
              /**
               * Checks if xhr.status is readable and non-zero, indicating no error.
               * Even though the spec says it should be available in readyState 3,
               * accessing it throws an exception in IE8
               */ function statusValid(xhr) {
                try {
                  var status = xhr.status;
                  return status !== null && status !== 0;
                } catch (e) {
                  return false;
                }
              }
              ClientRequest.prototype._onXHRProgress = function () {
                var self = this;
                self._resetTimers(false);
                if (!statusValid(self._xhr) || self._destroyed) return;
                if (!self._response) self._connect();
                self._response._onXHRProgress(self._resetTimers.bind(self));
              };
              ClientRequest.prototype._connect = function () {
                var self = this;
                if (self._destroyed) return;
                self._response = new IncomingMessage(
                  self._xhr,
                  self._fetchResponse,
                  self._mode,
                  self._resetTimers.bind(self)
                );
                self._response.on("error", function (err) {
                  self.emit("error", err);
                });
                self.emit("response", self._response);
              };
              ClientRequest.prototype._write = function (chunk, encoding, cb) {
                var self = this;
                self._body.push(chunk);
                cb();
              };
              ClientRequest.prototype._resetTimers = function (done) {
                var self = this;
                global.clearTimeout(self._socketTimer);
                self._socketTimer = null;
                if (done) {
                  global.clearTimeout(self._fetchTimer);
                  self._fetchTimer = null;
                } else if (self._socketTimeout) {
                  self._socketTimer = global.setTimeout(function () {
                    self.emit("timeout");
                  }, self._socketTimeout);
                }
              };
              ClientRequest.prototype.abort = ClientRequest.prototype.destroy =
                function (err) {
                  var self = this;
                  self._destroyed = true;
                  self._resetTimers(true);
                  if (self._response) self._response._destroyed = true;
                  if (self._xhr) self._xhr.abort();
                  else if (self._fetchAbortController)
                    self._fetchAbortController.abort();
                  if (err) self.emit("error", err);
                };
              ClientRequest.prototype.end = function (data, encoding, cb) {
                var self = this;
                if (typeof data === "function") {
                  cb = data;
                  data = undefined;
                }
                stream.Writable.prototype.end.call(self, data, encoding, cb);
              };
              ClientRequest.prototype.setTimeout = function (timeout, cb) {
                var self = this;
                if (cb) self.once("timeout", cb);
                self._socketTimeout = timeout;
                self._resetTimers(false);
              };
              ClientRequest.prototype.flushHeaders = function () {};
              ClientRequest.prototype.setNoDelay = function () {};
              ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
              var unsafeHeaders = [
                "accept-charset",
                "accept-encoding",
                "access-control-request-headers",
                "access-control-request-method",
                "connection",
                "content-length",
                "cookie",
                "cookie2",
                "date",
                "dnt",
                "expect",
                "host",
                "keep-alive",
                "origin",
                "referer",
                "te",
                "trailer",
                "transfer-encoding",
                "upgrade",
                "via"
              ];
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {},
            require("buffer").Buffer
          ));
        },
        {
          "./capability": 253,
          "./response": 255,
          _process: 246,
          buffer: 223,
          inherits: 239,
          "readable-stream": 270
        }
      ],
      255: [
        function (require, module, exports) {
          (function (process, global, Buffer) {
            (function () {
              var capability = require("./capability");
              var inherits = require("inherits");
              var stream = require("readable-stream");
              var rStates = (exports.readyStates = {
                UNSENT: 0,
                OPENED: 1,
                HEADERS_RECEIVED: 2,
                LOADING: 3,
                DONE: 4
              });
              var IncomingMessage = (exports.IncomingMessage = function (
                xhr,
                response,
                mode,
                resetTimers
              ) {
                var self = this;
                stream.Readable.call(self);
                self._mode = mode;
                self.headers = {};
                self.rawHeaders = [];
                self.trailers = {};
                self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires
                self.on("end", function () {
                  // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
                  process.nextTick(function () {
                    self.emit("close");
                  });
                });
                if (mode === "fetch") {
                  var read = function read() {
                    reader
                      .read()
                      .then(function (result) {
                        if (self._destroyed) return;
                        resetTimers(result.done);
                        if (result.done) {
                          self.push(null);
                          return;
                        }
                        self.push(Buffer.from(result.value));
                        read();
                      })
                      ["catch"](function (err) {
                        resetTimers(true);
                        if (!self._destroyed) self.emit("error", err);
                      });
                  };
                  self._fetchResponse = response;
                  self.url = response.url;
                  self.statusCode = response.status;
                  self.statusMessage = response.statusText;
                  response.headers.forEach(function (header, key) {
                    self.headers[key.toLowerCase()] = header;
                    self.rawHeaders.push(key, header);
                  });
                  if (capability.writableStream) {
                    var writable = new WritableStream({
                      write: function write(chunk) {
                        resetTimers(false);
                        return new Promise(function (resolve, reject) {
                          if (self._destroyed) {
                            reject();
                          } else if (self.push(Buffer.from(chunk))) {
                            resolve();
                          } else {
                            self._resumeFetch = resolve;
                          }
                        });
                      },
                      close: function close() {
                        resetTimers(true);
                        if (!self._destroyed) self.push(null);
                      },
                      abort: function abort(err) {
                        resetTimers(true);
                        if (!self._destroyed) self.emit("error", err);
                      }
                    });
                    try {
                      response.body.pipeTo(writable)["catch"](function (err) {
                        resetTimers(true);
                        if (!self._destroyed) self.emit("error", err);
                      });
                      return;
                    } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
                  } // fallback for when writableStream or pipeTo aren't available
                  var reader = response.body.getReader();
                  read();
                } else {
                  self._xhr = xhr;
                  self._pos = 0;
                  self.url = xhr.responseURL;
                  self.statusCode = xhr.status;
                  self.statusMessage = xhr.statusText;
                  var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                  headers.forEach(function (header) {
                    var matches = header.match(/^([^:]+):\s*(.*)/);
                    if (matches) {
                      var key = matches[1].toLowerCase();
                      if (key === "set-cookie") {
                        if (self.headers[key] === undefined) {
                          self.headers[key] = [];
                        }
                        self.headers[key].push(matches[2]);
                      } else if (self.headers[key] !== undefined) {
                        self.headers[key] += ", " + matches[2];
                      } else {
                        self.headers[key] = matches[2];
                      }
                      self.rawHeaders.push(matches[1], matches[2]);
                    }
                  });
                  self._charset = "x-user-defined";
                  if (!capability.overrideMimeType) {
                    var mimeType = self.rawHeaders["mime-type"];
                    if (mimeType) {
                      var charsetMatch = mimeType.match(
                        /;\s*charset=([^;])(;|$)/
                      );
                      if (charsetMatch) {
                        self._charset = charsetMatch[1].toLowerCase();
                      }
                    }
                    if (!self._charset) self._charset = "utf-8"; // best guess
                  }
                }
              });
              inherits(IncomingMessage, stream.Readable);
              IncomingMessage.prototype._read = function () {
                var self = this;
                var resolve = self._resumeFetch;
                if (resolve) {
                  self._resumeFetch = null;
                  resolve();
                }
              };
              IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
                var self = this;
                var xhr = self._xhr;
                var response = null;
                switch (self._mode) {
                  case "text":
                    response = xhr.responseText;
                    if (response.length > self._pos) {
                      var newData = response.substr(self._pos);
                      if (self._charset === "x-user-defined") {
                        var buffer = Buffer.alloc(newData.length);
                        for (var i = 0; i < newData.length; i++) {
                          buffer[i] = newData.charCodeAt(i) & 0xff;
                        }
                        self.push(buffer);
                      } else {
                        self.push(newData, self._charset);
                      }
                      self._pos = response.length;
                    }
                    break;
                  case "arraybuffer":
                    if (xhr.readyState !== rStates.DONE || !xhr.response) break;
                    response = xhr.response;
                    self.push(Buffer.from(new Uint8Array(response)));
                    break;
                  case "moz-chunked-arraybuffer": // take whole
                    response = xhr.response;
                    if (xhr.readyState !== rStates.LOADING || !response) break;
                    self.push(Buffer.from(new Uint8Array(response)));
                    break;
                  case "ms-stream":
                    response = xhr.response;
                    if (xhr.readyState !== rStates.LOADING) break;
                    var reader = new global.MSStreamReader();
                    reader.onprogress = function () {
                      if (reader.result.byteLength > self._pos) {
                        self.push(
                          Buffer.from(
                            new Uint8Array(reader.result.slice(self._pos))
                          )
                        );
                        self._pos = reader.result.byteLength;
                      }
                    };
                    reader.onload = function () {
                      resetTimers(true);
                      self.push(null);
                    }; // reader.onerror = ??? // TODO: this
                    reader.readAsArrayBuffer(response);
                    break;
                } // The ms-stream case handles end separately in reader.onload()
                if (
                  self._xhr.readyState === rStates.DONE &&
                  self._mode !== "ms-stream"
                ) {
                  resetTimers(true);
                  self.push(null);
                }
              };
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {},
            require("buffer").Buffer
          ));
        },
        {
          "./capability": 253,
          _process: 246,
          buffer: 223,
          inherits: 239,
          "readable-stream": 270
        }
      ],
      256: [
        function (require, module, exports) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var codes = {};
          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error;
            }
            function getMessage(arg1, arg2, arg3) {
              if (typeof message === "string") {
                return message;
              } else {
                return message(arg1, arg2, arg3);
              }
            }
            var NodeError = /*#__PURE__*/ (function (_Base) {
              _inheritsLoose(NodeError, _Base);
              function NodeError(arg1, arg2, arg3) {
                return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
              }
              return NodeError;
            })(Base);
            NodeError.prototype.name = Base.name;
            NodeError.prototype.code = code;
            codes[code] = NodeError;
          } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length;
              expected = expected.map(function (i) {
                return String(i);
              });
              if (len > 2) {
                return (
                  "one of "
                    .concat(thing, " ")
                    .concat(expected.slice(0, len - 1).join(", "), ", or ") +
                  expected[len - 1]
                );
              } else if (len === 2) {
                return "one of "
                  .concat(thing, " ")
                  .concat(expected[0], " or ")
                  .concat(expected[1]);
              } else {
                return "of ".concat(thing, " ").concat(expected[0]);
              }
            } else {
              return "of ".concat(thing, " ").concat(String(expected));
            }
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
          function startsWith(str, search, pos) {
            return (
              str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search
            );
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length;
            }
            return str.substring(this_len - search.length, this_len) === search;
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
          function includes(str, search, start) {
            if (typeof start !== "number") {
              start = 0;
            }
            if (start + search.length > str.length) {
              return false;
            } else {
              return str.indexOf(search, start) !== -1;
            }
          }
          createErrorType(
            "ERR_INVALID_OPT_VALUE",
            function (name, value) {
              return (
                'The value "' + value + '" is invalid for option "' + name + '"'
              );
            },
            TypeError
          );
          createErrorType(
            "ERR_INVALID_ARG_TYPE",
            function (name, expected, actual) {
              // determiner: 'must be' or 'must not be'
              var determiner;
              if (typeof expected === "string" && startsWith(expected, "not ")) {
                determiner = "must not be";
                expected = expected.replace(/^not /, "");
              } else {
                determiner = "must be";
              }
              var msg;
              if (endsWith(name, " argument")) {
                // For cases like 'first argument'
                msg = "The "
                  .concat(name, " ")
                  .concat(determiner, " ")
                  .concat(oneOf(expected, "type"));
              } else {
                var type = includes(name, ".") ? "property" : "argument";
                msg = 'The "'
                  .concat(name, '" ')
                  .concat(type, " ")
                  .concat(determiner, " ")
                  .concat(oneOf(expected, "type"));
              }
              msg += ". Received type ".concat(_typeof2(actual));
              return msg;
            },
            TypeError
          );
          createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
          createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function (name) {
            return "The " + name + " method is not implemented";
          });
          createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
          createErrorType("ERR_STREAM_DESTROYED", function (name) {
            return "Cannot call " + name + " after a stream was destroyed";
          });
          createErrorType(
            "ERR_MULTIPLE_CALLBACK",
            "Callback called multiple times"
          );
          createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
          createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
          createErrorType(
            "ERR_STREAM_NULL_VALUES",
            "May not write null values to stream",
            TypeError
          );
          createErrorType(
            "ERR_UNKNOWN_ENCODING",
            function (arg) {
              return "Unknown encoding: " + arg;
            },
            TypeError
          );
          createErrorType(
            "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
            "stream.unshift() after end event"
          );
          module.exports.codes = codes;
        },
        {}
      ],
      257: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              // a duplex stream is just a stream that is both readable and writable.
              // Since JS doesn't have multiple prototypal inheritance, this class
              // prototypally inherits from Readable, and then parasitically from
              // Writable.
              "use strict";
              /*<replacement>*/ var objectKeys =
                Object.keys ||
                function (obj) {
                  var keys = [];
                  for (var key in obj) {
                    keys.push(key);
                  }
                  return keys;
                };
              /*</replacement>*/ module.exports = Duplex;
              var Readable = require("./_stream_readable");
              var Writable = require("./_stream_writable");
              require("inherits")(Duplex, Readable);
              {
                // Allow the keys array to be GC'ed.
                var keys = objectKeys(Writable.prototype);
                for (var v = 0; v < keys.length; v++) {
                  var method = keys[v];
                  if (!Duplex.prototype[method])
                    Duplex.prototype[method] = Writable.prototype[method];
                }
              }
              function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                this.allowHalfOpen = true;
                if (options) {
                  if (options.readable === false) this.readable = false;
                  if (options.writable === false) this.writable = false;
                  if (options.allowHalfOpen === false) {
                    this.allowHalfOpen = false;
                    this.once("end", onend);
                  }
                }
              }
              Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.highWaterMark;
                }
              });
              Object.defineProperty(Duplex.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              Object.defineProperty(Duplex.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length;
                }
              }); // the no-half-open enforcer
              function onend() {
                // If the writable side ended, then we're ok.
                if (this._writableState.ended) return; // no more data can be written.
                // But allow more writes to happen in this tick.
                process.nextTick(onEndNT, this);
              }
              function onEndNT(self) {
                self.end();
              }
              Object.defineProperty(Duplex.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (
                    this._readableState === undefined ||
                    this._writableState === undefined
                  ) {
                    return false;
                  }
                  return (
                    this._readableState.destroyed && this._writableState.destroyed
                  );
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (
                    this._readableState === undefined ||
                    this._writableState === undefined
                  ) {
                    return;
                  } // backward compatibility, the user is explicitly
                  // managing destroyed
                  this._readableState.destroyed = value;
                  this._writableState.destroyed = value;
                }
              });
            }.call(this));
          }.call(this, require("_process")));
        },
        {
          "./_stream_readable": 259,
          "./_stream_writable": 261,
          _process: 246,
          inherits: 239
        }
      ],
      258: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a passthrough stream.
          // basically just the most minimal sort of Transform stream.
          // Every written chunk gets output as-is.
          "use strict";
          module.exports = PassThrough;
          var Transform = require("./_stream_transform");
          require("inherits")(PassThrough, Transform);
          function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);
            Transform.call(this, options);
          }
          PassThrough.prototype._transform = function (chunk, encoding, cb) {
            cb(null, chunk);
          };
        },
        { "./_stream_transform": 260, inherits: 239 }
      ],
      259: [
        function (require, module, exports) {
          (function (process, global) {
            (function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              "use strict";
              module.exports = Readable;
              /*<replacement>*/ var Duplex;
              /*</replacement>*/ Readable.ReadableState = ReadableState;
              /*<replacement>*/ var EE = require("events").EventEmitter;
              var EElistenerCount = function EElistenerCount(emitter, type) {
                return emitter.listeners(type).length;
              };
              /*</replacement>*/ /*<replacement>*/ var Stream = require("./internal/streams/stream");
              /*</replacement>*/ var Buffer = require("buffer").Buffer;
              var OurUint8Array = global.Uint8Array || function () {};
              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              /*<replacement>*/ var debugUtil = require("util");
              var debug;
              if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog("stream");
              } else {
                debug = function debug() {};
              }
              /*</replacement>*/ var BufferList = require("./internal/streams/buffer_list");
              var destroyImpl = require("./internal/streams/destroy");
              var _require = require("./internal/streams/state"),
                getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = require("../errors").codes,
                ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
                ERR_STREAM_PUSH_AFTER_EOF =
                  _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
                ERR_METHOD_NOT_IMPLEMENTED =
                  _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
                ERR_STREAM_UNSHIFT_AFTER_END_EVENT =
                  _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
              var StringDecoder;
              var createReadableStreamAsyncIterator;
              var from;
              require("inherits")(Readable, Stream);
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
              function prependListener(emitter, event, fn) {
                // Sadly this is not cacheable as some libraries bundle their own
                // event emitter implementation with them.
                if (typeof emitter.prependListener === "function")
                  return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
                // userland ones.  NEVER DO THIS. This is here only because this code needs
                // to continue to work with older versions of Node.js that do not include
                // the prependListener() method. The goal is to eventually remove this hack.
                if (!emitter._events || !emitter._events[event])
                  emitter.on(event, fn);
                else if (Array.isArray(emitter._events[event]))
                  emitter._events[event].unshift(fn);
                else emitter._events[event] = [fn, emitter._events[event]];
              }
              function ReadableState(options, stream, isDuplex) {
                Duplex = Duplex || require("./_stream_duplex");
                options = options || {}; // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream.
                // These options can be provided separately as readableXXX and writableXXX.
                if (typeof isDuplex !== "boolean")
                  isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
                // make all the buffer merging and length checks go away
                this.objectMode = !!options.objectMode;
                if (isDuplex)
                  this.objectMode =
                    this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
                // Note: 0 is a valid value, means "don't call _read preemptively ever"
                this.highWaterMark = getHighWaterMark(
                  this,
                  options,
                  "readableHighWaterMark",
                  isDuplex
                ); // A linked list is used to store data chunks instead of an array because the
                // linked list can remove elements from the beginning faster than
                // array.shift()
                this.buffer = new BufferList();
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
                // immediately, or on a later tick.  We set this to true at first, because
                // any actions that shouldn't happen until "later" should generally also
                // not happen before the first read call.
                this.sync = true; // whenever we return null, then we set a flag to say
                // that we're awaiting a 'readable' event emission.
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.resumeScheduled = false;
                this.paused = true; // Should close be emitted on destroy. Defaults to true.
                this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
                this.autoDestroy = !!options.autoDestroy; // has it been destroyed
                this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || "utf8"; // the number of writers that are awaiting a drain event in .pipe()s
                this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                  if (!StringDecoder)
                    StringDecoder = require("string_decoder/").StringDecoder;
                  this.decoder = new StringDecoder(options.encoding);
                  this.encoding = options.encoding;
                }
              }
              function Readable(options) {
                Duplex = Duplex || require("./_stream_duplex");
                if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
                // the ReadableState constructor, at least with V8 6.5
                var isDuplex = this instanceof Duplex;
                this._readableState = new ReadableState(options, this, isDuplex); // legacy
                this.readable = true;
                if (options) {
                  if (typeof options.read === "function")
                    this._read = options.read;
                  if (typeof options.destroy === "function")
                    this._destroy = options.destroy;
                }
                Stream.call(this);
              }
              Object.defineProperty(Readable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._readableState === undefined) {
                    return false;
                  }
                  return this._readableState.destroyed;
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (!this._readableState) {
                    return;
                  } // backward compatibility, the user is explicitly
                  // managing destroyed
                  this._readableState.destroyed = value;
                }
              });
              Readable.prototype.destroy = destroyImpl.destroy;
              Readable.prototype._undestroy = destroyImpl.undestroy;
              Readable.prototype._destroy = function (err, cb) {
                cb(err);
              }; // Manually shove something into the read() buffer.
              // This returns true if the highWaterMark has not been hit yet,
              // similar to how Writable.write() returns true if you should
              // write() some more.
              Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState;
                var skipChunkCheck;
                if (!state.objectMode) {
                  if (typeof chunk === "string") {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                      chunk = Buffer.from(chunk, encoding);
                      encoding = "";
                    }
                    skipChunkCheck = true;
                  }
                } else {
                  skipChunkCheck = true;
                }
                return readableAddChunk(
                  this,
                  chunk,
                  encoding,
                  false,
                  skipChunkCheck
                );
              }; // Unshift should *always* be something directly out of read()
              Readable.prototype.unshift = function (chunk) {
                return readableAddChunk(this, chunk, null, true, false);
              };
              function readableAddChunk(
                stream,
                chunk,
                encoding,
                addToFront,
                skipChunkCheck
              ) {
                debug("readableAddChunk", chunk);
                var state = stream._readableState;
                if (chunk === null) {
                  state.reading = false;
                  onEofChunk(stream, state);
                } else {
                  var er;
                  if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                  if (er) {
                    errorOrDestroy(stream, er);
                  } else if (state.objectMode || (chunk && chunk.length > 0)) {
                    if (
                      typeof chunk !== "string" &&
                      !state.objectMode &&
                      Object.getPrototypeOf(chunk) !== Buffer.prototype
                    ) {
                      chunk = _uint8ArrayToBuffer(chunk);
                    }
                    if (addToFront) {
                      if (state.endEmitted)
                        errorOrDestroy(
                          stream,
                          new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()
                        );
                      else addChunk(stream, state, chunk, true);
                    } else if (state.ended) {
                      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                    } else if (state.destroyed) {
                      return false;
                    } else {
                      state.reading = false;
                      if (state.decoder && !encoding) {
                        chunk = state.decoder.write(chunk);
                        if (state.objectMode || chunk.length !== 0)
                          addChunk(stream, state, chunk, false);
                        else maybeReadMore(stream, state);
                      } else {
                        addChunk(stream, state, chunk, false);
                      }
                    }
                  } else if (!addToFront) {
                    state.reading = false;
                    maybeReadMore(stream, state);
                  }
                } // We can push more data if we are below the highWaterMark.
                // Also, if we have no data yet, we can stand some more bytes.
                // This is to work around cases where hwm=0, such as the repl.
                return (
                  !state.ended &&
                  (state.length < state.highWaterMark || state.length === 0)
                );
              }
              function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  state.awaitDrain = 0;
                  stream.emit("data", chunk);
                } else {
                  // update the buffer info.
                  state.length += state.objectMode ? 1 : chunk.length;
                  if (addToFront) state.buffer.unshift(chunk);
                  else state.buffer.push(chunk);
                  if (state.needReadable) emitReadable(stream);
                }
                maybeReadMore(stream, state);
              }
              function chunkInvalid(state, chunk) {
                var er;
                if (
                  !_isUint8Array(chunk) &&
                  typeof chunk !== "string" &&
                  chunk !== undefined &&
                  !state.objectMode
                ) {
                  er = new ERR_INVALID_ARG_TYPE(
                    "chunk",
                    ["string", "Buffer", "Uint8Array"],
                    chunk
                  );
                }
                return er;
              }
              Readable.prototype.isPaused = function () {
                return this._readableState.flowing === false;
              }; // backwards compatibility.
              Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder)
                  StringDecoder = require("string_decoder/").StringDecoder;
                var decoder = new StringDecoder(enc);
                this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
                this._readableState.encoding =
                  this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
                var p = this._readableState.buffer.head;
                var content = "";
                while (p !== null) {
                  content += decoder.write(p.data);
                  p = p.next;
                }
                this._readableState.buffer.clear();
                if (content !== "") this._readableState.buffer.push(content);
                this._readableState.length = content.length;
                return this;
              }; // Don't raise the hwm > 1GB
              var MAX_HWM = 0x40000000;
              function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) {
                  // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
                  n = MAX_HWM;
                } else {
                  // Get the next highest power of 2 to prevent increasing hwm excessively in
                  // tiny amounts
                  n--;
                  n |= n >>> 1;
                  n |= n >>> 2;
                  n |= n >>> 4;
                  n |= n >>> 8;
                  n |= n >>> 16;
                  n++;
                }
                return n;
              } // This function is designed to be inlinable, so please take care when making
              // changes to the function body.
              function howMuchToRead(n, state) {
                if (n <= 0 || (state.length === 0 && state.ended)) return 0;
                if (state.objectMode) return 1;
                if (n !== n) {
                  // Only flow one buffer at a time
                  if (state.flowing && state.length)
                    return state.buffer.head.data.length;
                  else return state.length;
                } // If we're asking for more than the current hwm, then raise the hwm.
                if (n > state.highWaterMark)
                  state.highWaterMark = computeNewHighWaterMark(n);
                if (n <= state.length) return n; // Don't have enough
                if (!state.ended) {
                  state.needReadable = true;
                  return 0;
                }
                return state.length;
              } // you can override either this method, or the async _read(n) below.
              Readable.prototype.read = function (n) {
                debug("read", n);
                n = parseInt(n, 10);
                var state = this._readableState;
                var nOrig = n;
                if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
                // already have a bunch of data in the buffer, then just trigger
                // the 'readable' event and move on.
                if (
                  n === 0 &&
                  state.needReadable &&
                  ((state.highWaterMark !== 0
                    ? state.length >= state.highWaterMark
                    : state.length > 0) ||
                    state.ended)
                ) {
                  debug("read: emitReadable", state.length, state.ended);
                  if (state.length === 0 && state.ended) endReadable(this);
                  else emitReadable(this);
                  return null;
                }
                n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
                if (n === 0 && state.ended) {
                  if (state.length === 0) endReadable(this);
                  return null;
                } // All the actual chunk generation logic needs to be
                // *below* the call to _read.  The reason is that in certain
                // synthetic stream cases, such as passthrough streams, _read
                // may be a completely synchronous operation which may change
                // the state of the read buffer, providing enough data when
                // before there was *not* enough.
                //
                // So, the steps are:
                // 1. Figure out what the state of things will be after we do
                // a read from the buffer.
                //
                // 2. If that resulting state will trigger a _read, then call _read.
                // Note that this may be asynchronous, or synchronous.  Yes, it is
                // deeply ugly to write APIs this way, but that still doesn't mean
                // that the Readable class should behave improperly, as streams are
                // designed to be sync/async agnostic.
                // Take note if the _read call is sync or async (ie, if the read call
                // has returned yet), so that we know whether or not it's safe to emit
                // 'readable' etc.
                //
                // 3. Actually pull the requested chunks out of the buffer and return.
                // if we need a readable event, then we need to do some reading.
                var doRead = state.needReadable;
                debug("need readable", doRead); // if we currently have less than the highWaterMark, then also read some
                if (
                  state.length === 0 ||
                  state.length - n < state.highWaterMark
                ) {
                  doRead = true;
                  debug("length less than watermark", doRead);
                } // however, if we've ended, then there's no point, and if we're already
                // reading, then it's unnecessary.
                if (state.ended || state.reading) {
                  doRead = false;
                  debug("reading or ended", doRead);
                } else if (doRead) {
                  debug("do read");
                  state.reading = true;
                  state.sync = true; // if the length is currently zero, then we *need* a readable event.
                  if (state.length === 0) state.needReadable = true; // call internal read method
                  this._read(state.highWaterMark);
                  state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
                  // and we need to re-evaluate how much data we can return to the user.
                  if (!state.reading) n = howMuchToRead(nOrig, state);
                }
                var ret;
                if (n > 0) ret = fromList(n, state);
                else ret = null;
                if (ret === null) {
                  state.needReadable = state.length <= state.highWaterMark;
                  n = 0;
                } else {
                  state.length -= n;
                  state.awaitDrain = 0;
                }
                if (state.length === 0) {
                  // If we have nothing in the buffer, then we want to know
                  // as soon as we *do* get something into the buffer.
                  if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
                  if (nOrig !== n && state.ended) endReadable(this);
                }
                if (ret !== null) this.emit("data", ret);
                return ret;
              };
              function onEofChunk(stream, state) {
                debug("onEofChunk");
                if (state.ended) return;
                if (state.decoder) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                  }
                }
                state.ended = true;
                if (state.sync) {
                  // if we are sync, wait until next tick to emit the data.
                  // Otherwise we risk emitting data in the flow()
                  // the readable code triggers during a read() call
                  emitReadable(stream);
                } else {
                  // emit 'readable' now to make sure it gets picked up.
                  state.needReadable = false;
                  if (!state.emittedReadable) {
                    state.emittedReadable = true;
                    emitReadable_(stream);
                  }
                }
              } // Don't emit readable right away in sync mode, because this can trigger
              // another read() call => stack overflow.  This way, it might trigger
              // a nextTick recursion warning, but that's not so bad.
              function emitReadable(stream) {
                var state = stream._readableState;
                debug("emitReadable", state.needReadable, state.emittedReadable);
                state.needReadable = false;
                if (!state.emittedReadable) {
                  debug("emitReadable", state.flowing);
                  state.emittedReadable = true;
                  process.nextTick(emitReadable_, stream);
                }
              }
              function emitReadable_(stream) {
                var state = stream._readableState;
                debug(
                  "emitReadable_",
                  state.destroyed,
                  state.length,
                  state.ended
                );
                if (!state.destroyed && (state.length || state.ended)) {
                  stream.emit("readable");
                  state.emittedReadable = false;
                } // The stream needs another readable event if
                // 1. It is not flowing, as the flow mechanism will take
                //    care of it.
                // 2. It is not ended.
                // 3. It is below the highWaterMark, so we can schedule
                //    another readable later.
                state.needReadable =
                  !state.flowing &&
                  !state.ended &&
                  state.length <= state.highWaterMark;
                flow(stream);
              } // at this point, the user has presumably seen the 'readable' event,
              // and called read() to consume some data.  that may have triggered
              // in turn another _read(n) call, in which case reading = true if
              // it's in progress.
              // However, if we're not ended, or reading, and the length < hwm,
              // then go ahead and try to read some more preemptively.
              function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                  state.readingMore = true;
                  process.nextTick(maybeReadMore_, stream, state);
                }
              }
              function maybeReadMore_(stream, state) {
                // Attempt to read more data if we should.
                //
                // The conditions for reading more data are (one of):
                // - Not enough data buffered (state.length < state.highWaterMark). The loop
                //   is responsible for filling the buffer with enough data if such data
                //   is available. If highWaterMark is 0 and we are not in the flowing mode
                //   we should _not_ attempt to buffer any extra data. We'll get more data
                //   when the stream consumer calls read() instead.
                // - No data in the buffer, and the stream is in flowing mode. In this mode
                //   the loop below is responsible for ensuring read() is called. Failing to
                //   call read here would abort the flow and there's no other mechanism for
                //   continuing the flow if the stream consumer has just subscribed to the
                //   'data' event.
                //
                // In addition to the above conditions to keep reading data, the following
                // conditions prevent the data from being read:
                // - The stream has ended (state.ended).
                // - There is already a pending 'read' operation (state.reading). This is a
                //   case where the the stream has called the implementation defined _read()
                //   method, but they are processing the call asynchronously and have _not_
                //   called push() with new data. In this case we skip performing more
                //   read()s. The execution ends in this method again after the _read() ends
                //   up calling push() with more data.
                while (
                  !state.reading &&
                  !state.ended &&
                  (state.length < state.highWaterMark ||
                    (state.flowing && state.length === 0))
                ) {
                  var len = state.length;
                  debug("maybeReadMore read 0");
                  stream.read(0);
                  if (len === state.length)
                    // didn't get any data, stop spinning.
                    break;
                }
                state.readingMore = false;
              } // abstract method.  to be overridden in specific implementation classes.
              // call cb(er, data) where data is <= n in length.
              // for virtual (non-string, non-buffer) streams, "length" is somewhat
              // arbitrary, and perhaps not very meaningful.
              Readable.prototype._read = function (n) {
                errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
              };
              Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;
                  case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                  default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var doEnd =
                  (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
                var endFn = doEnd ? onend : unpipe;
                if (state.endEmitted) process.nextTick(endFn);
                else src.once("end", endFn);
                dest.on("unpipe", onunpipe);
                function onunpipe(readable, unpipeInfo) {
                  debug("onunpipe");
                  if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                      unpipeInfo.hasUnpiped = true;
                      cleanup();
                    }
                  }
                }
                function onend() {
                  debug("onend");
                  dest.end();
                } // when the dest drains, it reduces the awaitDrain counter
                // on the source.  This would be more elegant with a .once()
                // handler in flow(), but adding and removing repeatedly is
                // too slow.
                var ondrain = pipeOnDrain(src);
                dest.on("drain", ondrain);
                var cleanedUp = false;
                function cleanup() {
                  debug("cleanup"); // cleanup event handlers once the pipe is broken
                  dest.removeListener("close", onclose);
                  dest.removeListener("finish", onfinish);
                  dest.removeListener("drain", ondrain);
                  dest.removeListener("error", onerror);
                  dest.removeListener("unpipe", onunpipe);
                  src.removeListener("end", onend);
                  src.removeListener("end", unpipe);
                  src.removeListener("data", ondata);
                  cleanedUp = true; // if the reader is waiting for a drain event from this
                  // specific writer, then it would cause it to never start
                  // flowing again.
                  // So, if this is awaiting a drain, then we just call it now.
                  // If we don't know, then assume that we are waiting for one.
                  if (
                    state.awaitDrain &&
                    (!dest._writableState || dest._writableState.needDrain)
                  )
                    ondrain();
                }
                src.on("data", ondata);
                function ondata(chunk) {
                  debug("ondata");
                  var ret = dest.write(chunk);
                  debug("dest.write", ret);
                  if (ret === false) {
                    // If the user unpiped during `dest.write()`, it is possible
                    // to get stuck in a permanently paused state if that write
                    // also returned false.
                    // => Check whether `dest` is still a piping destination.
                    if (
                      ((state.pipesCount === 1 && state.pipes === dest) ||
                        (state.pipesCount > 1 &&
                          indexOf(state.pipes, dest) !== -1)) &&
                      !cleanedUp
                    ) {
                      debug("false write response, pause", state.awaitDrain);
                      state.awaitDrain++;
                    }
                    src.pause();
                  }
                } // if the dest has an error, then stop piping into it.
                // however, don't suppress the throwing behavior for this.
                function onerror(er) {
                  debug("onerror", er);
                  unpipe();
                  dest.removeListener("error", onerror);
                  if (EElistenerCount(dest, "error") === 0)
                    errorOrDestroy(dest, er);
                } // Make sure our error handler is attached before userland ones.
                prependListener(dest, "error", onerror); // Both close and finish should trigger unpipe, but only once.
                function onclose() {
                  dest.removeListener("finish", onfinish);
                  unpipe();
                }
                dest.once("close", onclose);
                function onfinish() {
                  debug("onfinish");
                  dest.removeListener("close", onclose);
                  unpipe();
                }
                dest.once("finish", onfinish);
                function unpipe() {
                  debug("unpipe");
                  src.unpipe(dest);
                } // tell the dest that it's being piped to
                dest.emit("pipe", src); // start the flow if it hasn't been started already.
                if (!state.flowing) {
                  debug("pipe resume");
                  src.resume();
                }
                return dest;
              };
              function pipeOnDrain(src) {
                return function pipeOnDrainFunctionResult() {
                  var state = src._readableState;
                  debug("pipeOnDrain", state.awaitDrain);
                  if (state.awaitDrain) state.awaitDrain--;
                  if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                  }
                };
              }
              Readable.prototype.unpipe = function (dest) {
                var state = this._readableState;
                var unpipeInfo = { hasUnpiped: false }; // if we're not piping anywhere, then do nothing.
                if (state.pipesCount === 0) return this; // just one destination.  most common case.
                if (state.pipesCount === 1) {
                  // passed in one, but it's not the right one.
                  if (dest && dest !== state.pipes) return this;
                  if (!dest) dest = state.pipes; // got a match.
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  if (dest) dest.emit("unpipe", this, unpipeInfo);
                  return this;
                } // slow case. multiple pipe destinations.
                if (!dest) {
                  // remove all.
                  var dests = state.pipes;
                  var len = state.pipesCount;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  for (var i = 0; i < len; i++) {
                    dests[i].emit("unpipe", this, { hasUnpiped: false });
                  }
                  return this;
                } // try to find the right one.
                var index = indexOf(state.pipes, dest);
                if (index === -1) return this;
                state.pipes.splice(index, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];
                dest.emit("unpipe", this, unpipeInfo);
                return this;
              }; // set up data events if they are asked for
              // Ensure readable listeners eventually get something
              Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                var state = this._readableState;
                if (ev === "data") {
                  // update readableListening so that resume() may be a no-op
                  // a few lines down. This is needed to support once('readable').
                  state.readableListening = this.listenerCount("readable") > 0; // Try start flowing on next tick if stream isn't explicitly paused
                  if (state.flowing !== false) this.resume();
                } else if (ev === "readable") {
                  if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.flowing = false;
                    state.emittedReadable = false;
                    debug("on readable", state.length, state.reading);
                    if (state.length) {
                      emitReadable(this);
                    } else if (!state.reading) {
                      process.nextTick(nReadingNextTick, this);
                    }
                  }
                }
                return res;
              };
              Readable.prototype.addListener = Readable.prototype.on;
              Readable.prototype.removeListener = function (ev, fn) {
                var res = Stream.prototype.removeListener.call(this, ev, fn);
                if (ev === "readable") {
                  // We need to check if there is someone still listening to
                  // readable and reset the state. However this needs to happen
                  // after readable has been emitted but before I/O (nextTick) to
                  // support once('readable', fn) cycles. This means that calling
                  // resume within the same tick will have no
                  // effect.
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              Readable.prototype.removeAllListeners = function (ev) {
                var res = Stream.prototype.removeAllListeners.apply(
                  this,
                  arguments
                );
                if (ev === "readable" || ev === undefined) {
                  // We need to check if there is someone still listening to
                  // readable and reset the state. However this needs to happen
                  // after readable has been emitted but before I/O (nextTick) to
                  // support once('readable', fn) cycles. This means that calling
                  // resume within the same tick will have no
                  // effect.
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              function updateReadableListening(self) {
                var state = self._readableState;
                state.readableListening = self.listenerCount("readable") > 0;
                if (state.resumeScheduled && !state.paused) {
                  // flowing needs to be set to true now, otherwise
                  // the upcoming resume will not flow.
                  state.flowing = true; // crude way to check if we should resume
                } else if (self.listenerCount("data") > 0) {
                  self.resume();
                }
              }
              function nReadingNextTick(self) {
                debug("readable nexttick read 0");
                self.read(0);
              } // pause() and resume() are remnants of the legacy readable stream API
              // If the user uses them, then switch into old mode.
              Readable.prototype.resume = function () {
                var state = this._readableState;
                if (!state.flowing) {
                  debug("resume"); // we flow only if there is no one listening
                  // for readable, but we still have to call
                  // resume()
                  state.flowing = !state.readableListening;
                  resume(this, state);
                }
                state.paused = false;
                return this;
              };
              function resume(stream, state) {
                if (!state.resumeScheduled) {
                  state.resumeScheduled = true;
                  process.nextTick(resume_, stream, state);
                }
              }
              function resume_(stream, state) {
                debug("resume", state.reading);
                if (!state.reading) {
                  stream.read(0);
                }
                state.resumeScheduled = false;
                stream.emit("resume");
                flow(stream);
                if (state.flowing && !state.reading) stream.read(0);
              }
              Readable.prototype.pause = function () {
                debug("call pause flowing=%j", this._readableState.flowing);
                if (this._readableState.flowing !== false) {
                  debug("pause");
                  this._readableState.flowing = false;
                  this.emit("pause");
                }
                this._readableState.paused = true;
                return this;
              };
              function flow(stream) {
                var state = stream._readableState;
                debug("flow", state.flowing);
                while (state.flowing && stream.read() !== null) {}
              } // wrap an old-style stream as the async data source.
              // This is *not* part of the readable stream interface.
              // It is an ugly unfortunate mess of history.
              Readable.prototype.wrap = function (stream) {
                var _this = this;
                var state = this._readableState;
                var paused = false;
                stream.on("end", function () {
                  debug("wrapped end");
                  if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) _this.push(chunk);
                  }
                  _this.push(null);
                });
                stream.on("data", function (chunk) {
                  debug("wrapped data");
                  if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
                  if (state.objectMode && (chunk === null || chunk === undefined))
                    return;
                  else if (!state.objectMode && (!chunk || !chunk.length)) return;
                  var ret = _this.push(chunk);
                  if (!ret) {
                    paused = true;
                    stream.pause();
                  }
                }); // proxy all the other methods.
                // important when wrapping filters and duplexes.
                for (var i in stream) {
                  if (this[i] === undefined && typeof stream[i] === "function") {
                    this[i] = (function methodWrap(method) {
                      return function methodWrapReturnFunction() {
                        return stream[method].apply(stream, arguments);
                      };
                    })(i);
                  }
                } // proxy certain important events.
                for (var n = 0; n < kProxyEvents.length; n++) {
                  stream.on(
                    kProxyEvents[n],
                    this.emit.bind(this, kProxyEvents[n])
                  );
                } // when we try to consume some more bytes, simply unpause the
                // underlying stream.
                this._read = function (n) {
                  debug("wrapped _read", n);
                  if (paused) {
                    paused = false;
                    stream.resume();
                  }
                };
                return this;
              };
              if (typeof Symbol === "function") {
                Readable.prototype[Symbol.asyncIterator] = function () {
                  if (createReadableStreamAsyncIterator === undefined) {
                    createReadableStreamAsyncIterator = require("./internal/streams/async_iterator");
                  }
                  return createReadableStreamAsyncIterator(this);
                };
              }
              Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.highWaterMark;
                }
              });
              Object.defineProperty(Readable.prototype, "readableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState && this._readableState.buffer;
                }
              });
              Object.defineProperty(Readable.prototype, "readableFlowing", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.flowing;
                },
                set: function set(state) {
                  if (this._readableState) {
                    this._readableState.flowing = state;
                  }
                }
              }); // exposed for testing purposes only.
              Readable._fromList = fromList;
              Object.defineProperty(Readable.prototype, "readableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.length;
                }
              }); // Pluck off n bytes from an array of buffers.
              // Length is the combined lengths of all the buffers in the list.
              // This function is designed to be inlinable, so please take care when making
              // changes to the function body.
              function fromList(n, state) {
                // nothing buffered
                if (state.length === 0) return null;
                var ret;
                if (state.objectMode) ret = state.buffer.shift();
                else if (!n || n >= state.length) {
                  // read it all, truncate the list
                  if (state.decoder) ret = state.buffer.join("");
                  else if (state.buffer.length === 1) ret = state.buffer.first();
                  else ret = state.buffer.concat(state.length);
                  state.buffer.clear();
                } else {
                  // read part of list
                  ret = state.buffer.consume(n, state.decoder);
                }
                return ret;
              }
              function endReadable(stream) {
                var state = stream._readableState;
                debug("endReadable", state.endEmitted);
                if (!state.endEmitted) {
                  state.ended = true;
                  process.nextTick(endReadableNT, state, stream);
                }
              }
              function endReadableNT(state, stream) {
                debug("endReadableNT", state.endEmitted, state.length); // Check that we didn't get one last unshift.
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream.readable = false;
                  stream.emit("end");
                  if (state.autoDestroy) {
                    // In case of duplex streams we need a way to detect
                    // if the writable side is ready for autoDestroy as well
                    var wState = stream._writableState;
                    if (!wState || (wState.autoDestroy && wState.finished)) {
                      stream.destroy();
                    }
                  }
                }
              }
              if (typeof Symbol === "function") {
                Readable.from = function (iterable, opts) {
                  if (from === undefined) {
                    from = require("./internal/streams/from");
                  }
                  return from(Readable, iterable, opts);
                };
              }
              function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                  if (xs[i] === x) return i;
                }
                return -1;
              }
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "../errors": 256,
          "./_stream_duplex": 257,
          "./internal/streams/async_iterator": 262,
          "./internal/streams/buffer_list": 263,
          "./internal/streams/destroy": 264,
          "./internal/streams/from": 266,
          "./internal/streams/state": 268,
          "./internal/streams/stream": 269,
          _process: 246,
          buffer: 223,
          events: 228,
          inherits: 239,
          "string_decoder/": 271,
          util: 222
        }
      ],
      260: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a transform stream is a readable/writable stream where you do
          // something with the data.  Sometimes it's called a "filter",
          // but that's not a great name for it, since that implies a thing where
          // some bits pass through, and others are simply ignored.  (That would
          // be a valid example of a transform, of course.)
          //
          // While the output is causally related to the input, it's not a
          // necessarily symmetric or synchronous transformation.  For example,
          // a zlib stream might take multiple plain-text writes(), and then
          // emit a single compressed chunk some time in the future.
          //
          // Here's how this works:
          //
          // The Transform stream has all the aspects of the readable and writable
          // stream classes.  When you write(chunk), that calls _write(chunk,cb)
          // internally, and returns false if there's a lot of pending writes
          // buffered up.  When you call read(), that calls _read(n) until
          // there's enough pending readable data buffered up.
          //
          // In a transform stream, the written data is placed in a buffer.  When
          // _read(n) is called, it transforms the queued up data, calling the
          // buffered _write cb's as it consumes chunks.  If consuming a single
          // written chunk would result in multiple output chunks, then the first
          // outputted bit calls the readcb, and subsequent chunks just go into
          // the read buffer, and will cause it to emit 'readable' if necessary.
          //
          // This way, back-pressure is actually determined by the reading side,
          // since _read has to be called to start processing a new chunk.  However,
          // a pathological inflate type of transform can cause excessive buffering
          // here.  For example, imagine a stream where every byte of input is
          // interpreted as an integer from 0-255, and then results in that many
          // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
          // 1kb of data being output.  In this case, you could write a very small
          // amount of input, and end up with a very large amount of output.  In
          // such a pathological inflating mechanism, there'd be no way to tell
          // the system to stop doing the transform.  A single 4MB write could
          // cause the system to run out of memory.
          //
          // However, even in such a pathological case, only a single written chunk
          // would be consumed, and then the rest would wait (un-transformed) until
          // the results of the previous transformed chunk were consumed.
          "use strict";
          module.exports = Transform;
          var _require$codes = require("../errors").codes,
            ERR_METHOD_NOT_IMPLEMENTED =
              _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
            ERR_TRANSFORM_ALREADY_TRANSFORMING =
              _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
            ERR_TRANSFORM_WITH_LENGTH_0 =
              _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
          var Duplex = require("./_stream_duplex");
          require("inherits")(Transform, Duplex);
          function afterTransform(er, data) {
            var ts = this._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (cb === null) {
              return this.emit("error", new ERR_MULTIPLE_CALLBACK());
            }
            ts.writechunk = null;
            ts.writecb = null;
            if (data != null)
              // single equals check for both `null` and `undefined`
              this.push(data);
            cb(er);
            var rs = this._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              this._read(rs.highWaterMark);
            }
          }
          function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);
            Duplex.call(this, options);
            this._transformState = {
              afterTransform: afterTransform.bind(this),
              needTransform: false,
              transforming: false,
              writecb: null,
              writechunk: null,
              writeencoding: null
            }; // start out asking for a readable event once data is transformed.
            this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
            // that Readable wants before the first _read call, so unset the
            // sync guard flag.
            this._readableState.sync = false;
            if (options) {
              if (typeof options.transform === "function")
                this._transform = options.transform;
              if (typeof options.flush === "function")
                this._flush = options.flush;
            } // When the writable side finishes, then flush out anything remaining.
            this.on("prefinish", prefinish);
          }
          function prefinish() {
            var _this = this;
            if (
              typeof this._flush === "function" &&
              !this._readableState.destroyed
            ) {
              this._flush(function (er, data) {
                done(_this, er, data);
              });
            } else {
              done(this, null, null);
            }
          }
          Transform.prototype.push = function (chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
          }; // This is the part where you do stuff!
          // override this function in implementation classes.
          // 'chunk' is an input chunk.
          //
          // Call `push(newChunk)` to pass along transformed output
          // to the readable side.  You may call 'push' zero or more times.
          //
          // Call `cb(err)` when you are done with this chunk.  If you pass
          // an error, then that'll put the hurt on the whole operation.  If you
          // never call cb(), then you'll never get another chunk.
          Transform.prototype._transform = function (chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
          };
          Transform.prototype._write = function (chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
              var rs = this._readableState;
              if (
                ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark
              )
                this._read(rs.highWaterMark);
            }
          }; // Doesn't matter what the args are here.
          // _transform does all the work.
          // That we got here means that the readable side wants more data.
          Transform.prototype._read = function (n) {
            var ts = this._transformState;
            if (ts.writechunk !== null && !ts.transforming) {
              ts.transforming = true;
              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
              // mark that we need a transform, so that any data that comes in
              // will get processed, now that we've asked for it.
              ts.needTransform = true;
            }
          };
          Transform.prototype._destroy = function (err, cb) {
            Duplex.prototype._destroy.call(this, err, function (err2) {
              cb(err2);
            });
          };
          function done(stream, er, data) {
            if (er) return stream.emit("error", er);
            if (data != null)
              // single equals check for both `null` and `undefined`
              stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
            // if there's nothing in the write buffer, then that means
            // that nothing more will ever be provided
            if (stream._writableState.length)
              throw new ERR_TRANSFORM_WITH_LENGTH_0();
            if (stream._transformState.transforming)
              throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
            return stream.push(null);
          }
        },
        { "../errors": 256, "./_stream_duplex": 257, inherits: 239 }
      ],
      261: [
        function (require, module, exports) {
          (function (process, global) {
            (function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              // A bit simpler than readable streams.
              // Implement an async ._write(chunk, encoding, cb), and it'll handle all
              // the drain event emission and buffering.
              "use strict";
              module.exports = Writable;
              /* <replacement> */ function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
                this.next = null;
              } // It seems a linked list but it is not
              // there will be only 2 of these for each stream
              function CorkedRequest(state) {
                var _this = this;
                this.next = null;
                this.entry = null;
                this.finish = function () {
                  onCorkedFinish(_this, state);
                };
              }
              /* </replacement> */ /*<replacement>*/ var Duplex;
              /*</replacement>*/ Writable.WritableState = WritableState;
              /*<replacement>*/ var internalUtil = {
                deprecate: require("util-deprecate")
              };
              /*</replacement>*/ /*<replacement>*/ var Stream = require("./internal/streams/stream");
              /*</replacement>*/ var Buffer = require("buffer").Buffer;
              var OurUint8Array = global.Uint8Array || function () {};
              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var destroyImpl = require("./internal/streams/destroy");
              var _require = require("./internal/streams/state"),
                getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = require("../errors").codes,
                ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
                ERR_METHOD_NOT_IMPLEMENTED =
                  _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
                ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
                ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
                ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
                ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
                ERR_STREAM_WRITE_AFTER_END =
                  _require$codes.ERR_STREAM_WRITE_AFTER_END,
                ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              require("inherits")(Writable, Stream);
              function nop() {}
              function WritableState(options, stream, isDuplex) {
                Duplex = Duplex || require("./_stream_duplex");
                options = options || {}; // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream,
                // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
                if (typeof isDuplex !== "boolean")
                  isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
                // contains buffers or objects.
                this.objectMode = !!options.objectMode;
                if (isDuplex)
                  this.objectMode =
                    this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
                // Note: 0 is a valid value, means that we always return false if
                // the entire buffer is not flushed immediately on write()
                this.highWaterMark = getHighWaterMark(
                  this,
                  options,
                  "writableHighWaterMark",
                  isDuplex
                ); // if _final has been called
                this.finalCalled = false; // drain event flag.
                this.needDrain = false; // at the start of calling end()
                this.ending = false; // when end() has been called, and returned
                this.ended = false; // when 'finish' is emitted
                this.finished = false; // has it been destroyed
                this.destroyed = false; // should we decode strings into buffers before passing to _write?
                // this is here so that some node-core streams can optimize string
                // handling at a lower level.
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.
                this.defaultEncoding = options.defaultEncoding || "utf8"; // not an actual buffer we keep track of, but a measurement
                // of how much we're waiting to get pushed to some underlying
                // socket or file.
                this.length = 0; // a flag to see when we're in the middle of a write.
                this.writing = false; // when true all writes will be buffered until .uncork() call
                this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
                // or on a later tick.  We set this to true at first, because any
                // actions that shouldn't happen until "later" should generally also
                // not happen before the first write call.
                this.sync = true; // a flag to know if we're processing previously buffered items, which
                // may call the _write() callback in the same tick, so that we don't
                // end up in an overlapped onwrite situation.
                this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
                this.onwrite = function (er) {
                  onwrite(stream, er);
                }; // the callback that the user supplies to write(chunk,encoding,cb)
                this.writecb = null; // the amount that is being written when _write is called.
                this.writelen = 0;
                this.bufferedRequest = null;
                this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
                // this must be 0 before 'finish' can be emitted
                this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
                // This is relevant for synchronous Transform streams
                this.prefinished = false; // True if the error was already emitted and should not be thrown again
                this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
                this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
                this.autoDestroy = !!options.autoDestroy; // count buffered requests
                this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
                // one allocated and free to use, and we maintain at most two
                this.corkedRequestsFree = new CorkedRequest(this);
              }
              WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest;
                var out = [];
                while (current) {
                  out.push(current);
                  current = current.next;
                }
                return out;
              };
              (function () {
                try {
                  Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(
                      function writableStateBufferGetter() {
                        return this.getBuffer();
                      },
                      "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                        "instead.",
                      "DEP0003"
                    )
                  });
                } catch (_) {}
              })(); // Test _writableState for inheritance to account for Duplex streams,
              // whose prototype chain only points to Readable.
              var realHasInstance;
              if (
                typeof Symbol === "function" &&
                Symbol.hasInstance &&
                typeof Function.prototype[Symbol.hasInstance] === "function"
              ) {
                realHasInstance = Function.prototype[Symbol.hasInstance];
                Object.defineProperty(Writable, Symbol.hasInstance, {
                  value: function value(object) {
                    if (realHasInstance.call(this, object)) return true;
                    if (this !== Writable) return false;
                    return (
                      object && object._writableState instanceof WritableState
                    );
                  }
                });
              } else {
                realHasInstance = function realHasInstance(object) {
                  return object instanceof this;
                };
              }
              function Writable(options) {
                Duplex = Duplex || require("./_stream_duplex"); // Writable ctor is applied to Duplexes, too.
                // `realHasInstance` is necessary because using plain `instanceof`
                // would return false, as no `_writableState` property is attached.
                // Trying to use the custom `instanceof` for Writable here will also break the
                // Node.js LazyTransform implementation, which has a non-trivial getter for
                // `_writableState` that would lead to infinite recursion.
                // Checking for a Stream.Duplex instance is faster here instead of inside
                // the WritableState constructor, at least with V8 6.5
                var isDuplex = this instanceof Duplex;
                if (!isDuplex && !realHasInstance.call(Writable, this))
                  return new Writable(options);
                this._writableState = new WritableState(options, this, isDuplex); // legacy.
                this.writable = true;
                if (options) {
                  if (typeof options.write === "function")
                    this._write = options.write;
                  if (typeof options.writev === "function")
                    this._writev = options.writev;
                  if (typeof options.destroy === "function")
                    this._destroy = options.destroy;
                  if (typeof options["final"] === "function")
                    this._final = options["final"];
                }
                Stream.call(this);
              } // Otherwise people can pipe Writable streams, which is just wrong.
              Writable.prototype.pipe = function () {
                errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
              };
              function writeAfterEnd(stream, cb) {
                var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
              } // Checks that a user-supplied chunk is valid, especially for the particular
              // mode the stream is in. Currently this means that `null` is never accepted
              // and undefined/non-string values are only allowed in object mode.
              function validChunk(stream, state, chunk, cb) {
                var er;
                if (chunk === null) {
                  er = new ERR_STREAM_NULL_VALUES();
                } else if (typeof chunk !== "string" && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE(
                    "chunk",
                    ["string", "Buffer"],
                    chunk
                  );
                }
                if (er) {
                  errorOrDestroy(stream, er);
                  process.nextTick(cb, er);
                  return false;
                }
                return true;
              }
              Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                var isBuf = !state.objectMode && _isUint8Array(chunk);
                if (isBuf && !Buffer.isBuffer(chunk)) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (isBuf) encoding = "buffer";
                else if (!encoding) encoding = state.defaultEncoding;
                if (typeof cb !== "function") cb = nop;
                if (state.ending) writeAfterEnd(this, cb);
                else if (isBuf || validChunk(this, state, chunk, cb)) {
                  state.pendingcb++;
                  ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                }
                return ret;
              };
              Writable.prototype.cork = function () {
                this._writableState.corked++;
              };
              Writable.prototype.uncork = function () {
                var state = this._writableState;
                if (state.corked) {
                  state.corked--;
                  if (
                    !state.writing &&
                    !state.corked &&
                    !state.bufferProcessing &&
                    state.bufferedRequest
                  )
                    clearBuffer(this, state);
                }
              };
              Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
                encoding
              ) {
                // node::ParseEncoding() requires lower case.
                if (typeof encoding === "string")
                  encoding = encoding.toLowerCase();
                if (
                  !(
                    [
                      "hex",
                      "utf8",
                      "utf-8",
                      "ascii",
                      "binary",
                      "base64",
                      "ucs2",
                      "ucs-2",
                      "utf16le",
                      "utf-16le",
                      "raw"
                    ].indexOf((encoding + "").toLowerCase()) > -1
                  )
                )
                  throw new ERR_UNKNOWN_ENCODING(encoding);
                this._writableState.defaultEncoding = encoding;
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              function decodeChunk(state, chunk, encoding) {
                if (
                  !state.objectMode &&
                  state.decodeStrings !== false &&
                  typeof chunk === "string"
                ) {
                  chunk = Buffer.from(chunk, encoding);
                }
                return chunk;
              }
              Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.highWaterMark;
                }
              }); // if we're already writing something, then just put this
              // in the queue, and wait our turn.  Otherwise, call _write
              // If we return false, then we need a drain event, so set that flag.
              function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) {
                  var newChunk = decodeChunk(state, chunk, encoding);
                  if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                  }
                }
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
                if (!ret) state.needDrain = true;
                if (state.writing || state.corked) {
                  var last = state.lastBufferedRequest;
                  state.lastBufferedRequest = {
                    chunk: chunk,
                    encoding: encoding,
                    isBuf: isBuf,
                    callback: cb,
                    next: null
                  };
                  if (last) {
                    last.next = state.lastBufferedRequest;
                  } else {
                    state.bufferedRequest = state.lastBufferedRequest;
                  }
                  state.bufferedRequestCount += 1;
                } else {
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                }
                return ret;
              }
              function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (state.destroyed)
                  state.onwrite(new ERR_STREAM_DESTROYED("write"));
                else if (writev) stream._writev(chunk, state.onwrite);
                else stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
              }
              function onwriteError(stream, state, sync, er, cb) {
                --state.pendingcb;
                if (sync) {
                  // defer the callback if we are being called synchronously
                  // to avoid piling up things on the stack
                  process.nextTick(cb, er); // this can emit finish, and it will always happen
                  // after error
                  process.nextTick(finishMaybe, stream, state);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er);
                } else {
                  // the caller expect this to happen before if
                  // it is async
                  cb(er);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er); // this can emit finish, but finish must
                  // always follow error
                  finishMaybe(stream, state);
                }
              }
              function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
              }
              function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
                onwriteStateUpdate(state);
                if (er) onwriteError(stream, state, sync, er, cb);
                else {
                  // Check if we're actually ready to finish, but don't emit yet
                  var finished = needFinish(state) || stream.destroyed;
                  if (
                    !finished &&
                    !state.corked &&
                    !state.bufferProcessing &&
                    state.bufferedRequest
                  ) {
                    clearBuffer(stream, state);
                  }
                  if (sync) {
                    process.nextTick(afterWrite, stream, state, finished, cb);
                  } else {
                    afterWrite(stream, state, finished, cb);
                  }
                }
              }
              function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
              } // Must force callback to be called on nextTick, so that we don't
              // emit 'drain' before the write() consumer gets the 'false' return
              // value, and has a chance to attach a 'drain' listener.
              function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                  state.needDrain = false;
                  stream.emit("drain");
                }
              } // if there's something in the buffer waiting, then process it
              function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                var entry = state.bufferedRequest;
                if (stream._writev && entry && entry.next) {
                  // Fast case, write everything using _writev()
                  var l = state.bufferedRequestCount;
                  var buffer = new Array(l);
                  var holder = state.corkedRequestsFree;
                  holder.entry = entry;
                  var count = 0;
                  var allBuffers = true;
                  while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                  }
                  buffer.allBuffers = allBuffers;
                  doWrite(
                    stream,
                    state,
                    true,
                    state.length,
                    buffer,
                    "",
                    holder.finish
                  ); // doWrite is almost always async, defer these to save a bit of time
                  // as the hot path ends with doWrite
                  state.pendingcb++;
                  state.lastBufferedRequest = null;
                  if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                  } else {
                    state.corkedRequestsFree = new CorkedRequest(state);
                  }
                  state.bufferedRequestCount = 0;
                } else {
                  // Slow case, write chunks one-by-one
                  while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
                    // it means that we need to wait until it does.
                    // also, that means that the chunk and cb are currently
                    // being processed, so move the buffer counter past them.
                    if (state.writing) {
                      break;
                    }
                  }
                  if (entry === null) state.lastBufferedRequest = null;
                }
                state.bufferedRequest = entry;
                state.bufferProcessing = false;
              }
              Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
              };
              Writable.prototype._writev = null;
              Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState;
                if (typeof chunk === "function") {
                  cb = chunk;
                  chunk = null;
                  encoding = null;
                } else if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (chunk !== null && chunk !== undefined)
                  this.write(chunk, encoding); // .end() fully uncorks
                if (state.corked) {
                  state.corked = 1;
                  this.uncork();
                } // ignore unnecessary end() calls.
                if (!state.ending) endWritable(this, state, cb);
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length;
                }
              });
              function needFinish(state) {
                return (
                  state.ending &&
                  state.length === 0 &&
                  state.bufferedRequest === null &&
                  !state.finished &&
                  !state.writing
                );
              }
              function callFinal(stream, state) {
                stream._final(function (err) {
                  state.pendingcb--;
                  if (err) {
                    errorOrDestroy(stream, err);
                  }
                  state.prefinished = true;
                  stream.emit("prefinish");
                  finishMaybe(stream, state);
                });
              }
              function prefinish(stream, state) {
                if (!state.prefinished && !state.finalCalled) {
                  if (typeof stream._final === "function" && !state.destroyed) {
                    state.pendingcb++;
                    state.finalCalled = true;
                    process.nextTick(callFinal, stream, state);
                  } else {
                    state.prefinished = true;
                    stream.emit("prefinish");
                  }
                }
              }
              function finishMaybe(stream, state) {
                var need = needFinish(state);
                if (need) {
                  prefinish(stream, state);
                  if (state.pendingcb === 0) {
                    state.finished = true;
                    stream.emit("finish");
                    if (state.autoDestroy) {
                      // In case of duplex streams we need a way to detect
                      // if the readable side is ready for autoDestroy as well
                      var rState = stream._readableState;
                      if (!rState || (rState.autoDestroy && rState.endEmitted)) {
                        stream.destroy();
                      }
                    }
                  }
                }
                return need;
              }
              function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                  if (state.finished) process.nextTick(cb);
                  else stream.once("finish", cb);
                }
                state.ended = true;
                stream.writable = false;
              }
              function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry;
                corkReq.entry = null;
                while (entry) {
                  var cb = entry.callback;
                  state.pendingcb--;
                  cb(err);
                  entry = entry.next;
                } // reuse the free corkReq.
                state.corkedRequestsFree.next = corkReq;
              }
              Object.defineProperty(Writable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._writableState === undefined) {
                    return false;
                  }
                  return this._writableState.destroyed;
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (!this._writableState) {
                    return;
                  } // backward compatibility, the user is explicitly
                  // managing destroyed
                  this._writableState.destroyed = value;
                }
              });
              Writable.prototype.destroy = destroyImpl.destroy;
              Writable.prototype._undestroy = destroyImpl.undestroy;
              Writable.prototype._destroy = function (err, cb) {
                cb(err);
              };
            }.call(this));
          }.call(
            this,
            require("_process"),
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "../errors": 256,
          "./_stream_duplex": 257,
          "./internal/streams/destroy": 264,
          "./internal/streams/state": 268,
          "./internal/streams/stream": 269,
          _process: 246,
          buffer: 223,
          inherits: 239,
          "util-deprecate": 274
        }
      ],
      262: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              "use strict";
              var _Object$setPrototypeO;
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              var finished = require("./end-of-stream");
              var kLastResolve = Symbol("lastResolve");
              var kLastReject = Symbol("lastReject");
              var kError = Symbol("error");
              var kEnded = Symbol("ended");
              var kLastPromise = Symbol("lastPromise");
              var kHandlePromise = Symbol("handlePromise");
              var kStream = Symbol("stream");
              function createIterResult(value, done) {
                return { value: value, done: done };
              }
              function readAndResolve(iter) {
                var resolve = iter[kLastResolve];
                if (resolve !== null) {
                  var data = iter[kStream].read(); // we defer if data is null
                  // we can be expecting either 'end' or
                  // 'error'
                  if (data !== null) {
                    iter[kLastPromise] = null;
                    iter[kLastResolve] = null;
                    iter[kLastReject] = null;
                    resolve(createIterResult(data, false));
                  }
                }
              }
              function onReadable(iter) {
                // we wait for the next tick, because it might
                // emit an error with process.nextTick
                process.nextTick(readAndResolve, iter);
              }
              function wrapForNext(lastPromise, iter) {
                return function (resolve, reject) {
                  lastPromise.then(function () {
                    if (iter[kEnded]) {
                      resolve(createIterResult(undefined, true));
                      return;
                    }
                    iter[kHandlePromise](resolve, reject);
                  }, reject);
                };
              }
              var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
              var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(
                ((_Object$setPrototypeO = {
                  get stream() {
                    return this[kStream];
                  },
                  next: function next() {
                    var _this = this; // if we have detected an error in the meanwhile
                    // reject straight away
                    var error = this[kError];
                    if (error !== null) {
                      return Promise.reject(error);
                    }
                    if (this[kEnded]) {
                      return Promise.resolve(createIterResult(undefined, true));
                    }
                    if (this[kStream].destroyed) {
                      // We need to defer via nextTick because if .destroy(err) is
                      // called, the error will be emitted via nextTick, and
                      // we cannot guarantee that there is no error lingering around
                      // waiting to be emitted.
                      return new Promise(function (resolve, reject) {
                        process.nextTick(function () {
                          if (_this[kError]) {
                            reject(_this[kError]);
                          } else {
                            resolve(createIterResult(undefined, true));
                          }
                        });
                      });
                    } // if we have multiple next() calls
                    // we will wait for the previous Promise to finish
                    // this logic is optimized to support for /*await*/ loops,
                    // where next() is only called once at a time
                    var lastPromise = this[kLastPromise];
                    var promise;
                    if (lastPromise) {
                      promise = new Promise(wrapForNext(lastPromise, this));
                    } else {
                      // fast path needed to support multiple this.push()
                      // without triggering the next() queue
                      var data = this[kStream].read();
                      if (data !== null) {
                        return Promise.resolve(createIterResult(data, false));
                      }
                      promise = new Promise(this[kHandlePromise]);
                    }
                    this[kLastPromise] = promise;
                    return promise;
                  }
                }),
                _defineProperty(
                  _Object$setPrototypeO,
                  Symbol.asyncIterator,
                  function () {
                    return this;
                  }
                ),
                _defineProperty(
                  _Object$setPrototypeO,
                  "return",
                  function _return() {
                    var _this2 = this; // destroy(err, cb) is a private API
                    // we can guarantee we have that here, because we control the
                    // Readable class this is attached to
                    return new Promise(function (resolve, reject) {
                      _this2[kStream].destroy(null, function (err) {
                        if (err) {
                          reject(err);
                          return;
                        }
                        resolve(createIterResult(undefined, true));
                      });
                    });
                  }
                ),
                _Object$setPrototypeO),
                AsyncIteratorPrototype
              );
              var createReadableStreamAsyncIterator =
                function createReadableStreamAsyncIterator(stream) {
                  var _Object$create;
                  var iterator = Object.create(
                    ReadableStreamAsyncIteratorPrototype,
                    ((_Object$create = {}),
                    _defineProperty(_Object$create, kStream, {
                      value: stream,
                      writable: true
                    }),
                    _defineProperty(_Object$create, kLastResolve, {
                      value: null,
                      writable: true
                    }),
                    _defineProperty(_Object$create, kLastReject, {
                      value: null,
                      writable: true
                    }),
                    _defineProperty(_Object$create, kError, {
                      value: null,
                      writable: true
                    }),
                    _defineProperty(_Object$create, kEnded, {
                      value: stream._readableState.endEmitted,
                      writable: true
                    }),
                    _defineProperty(_Object$create, kHandlePromise, {
                      value: function value(resolve, reject) {
                        var data = iterator[kStream].read();
                        if (data) {
                          iterator[kLastPromise] = null;
                          iterator[kLastResolve] = null;
                          iterator[kLastReject] = null;
                          resolve(createIterResult(data, false));
                        } else {
                          iterator[kLastResolve] = resolve;
                          iterator[kLastReject] = reject;
                        }
                      },
                      writable: true
                    }),
                    _Object$create)
                  );
                  iterator[kLastPromise] = null;
                  finished(stream, function (err) {
                    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
                      // returned by next() and store the error
                      if (reject !== null) {
                        iterator[kLastPromise] = null;
                        iterator[kLastResolve] = null;
                        iterator[kLastReject] = null;
                        reject(err);
                      }
                      iterator[kError] = err;
                      return;
                    }
                    var resolve = iterator[kLastResolve];
                    if (resolve !== null) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(undefined, true));
                    }
                    iterator[kEnded] = true;
                  });
                  stream.on("readable", onReadable.bind(null, iterator));
                  return iterator;
                };
              module.exports = createReadableStreamAsyncIterator;
            }.call(this));
          }.call(this, require("_process")));
        },
        { "./end-of-stream": 265, _process: 246 }
      ],
      263: [
        function (require, module, exports) {
          "use strict";
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                );
              } else {
                ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var _require = require("buffer"),
            Buffer = _require.Buffer;
          var _require2 = require("util"),
            inspect = _require2.inspect;
          var custom = (inspect && inspect.custom) || "inspect";
          function copyBuffer(src, target, offset) {
            Buffer.prototype.copy.call(src, target, offset);
          }
          module.exports = /*#__PURE__*/ (function () {
            function BufferList() {
              _classCallCheck(this, BufferList);
              this.head = null;
              this.tail = null;
              this.length = 0;
            }
            _createClass(BufferList, [
              {
                key: "push",
                value: function push(v) {
                  var entry = { data: v, next: null };
                  if (this.length > 0) this.tail.next = entry;
                  else this.head = entry;
                  this.tail = entry;
                  ++this.length;
                }
              },
              {
                key: "unshift",
                value: function unshift(v) {
                  var entry = { data: v, next: this.head };
                  if (this.length === 0) this.tail = entry;
                  this.head = entry;
                  ++this.length;
                }
              },
              {
                key: "shift",
                value: function shift() {
                  if (this.length === 0) return;
                  var ret = this.head.data;
                  if (this.length === 1) this.head = this.tail = null;
                  else this.head = this.head.next;
                  --this.length;
                  return ret;
                }
              },
              {
                key: "clear",
                value: function clear() {
                  this.head = this.tail = null;
                  this.length = 0;
                }
              },
              {
                key: "join",
                value: function join(s) {
                  if (this.length === 0) return "";
                  var p = this.head;
                  var ret = "" + p.data;
                  while ((p = p.next)) {
                    ret += s + p.data;
                  }
                  return ret;
                }
              },
              {
                key: "concat",
                value: function concat(n) {
                  if (this.length === 0) return Buffer.alloc(0);
                  var ret = Buffer.allocUnsafe(n >>> 0);
                  var p = this.head;
                  var i = 0;
                  while (p) {
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                  }
                  return ret;
                } // Consumes a specified amount of bytes or characters from the buffered data.
              },
              {
                key: "consume",
                value: function consume(n, hasStrings) {
                  var ret;
                  if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                  } else if (n === this.head.data.length) {
                    // First chunk is a perfect match.
                    ret = this.shift();
                  } else {
                    // Result spans more than one buffer.
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                  }
                  return ret;
                }
              },
              {
                key: "first",
                value: function first() {
                  return this.head.data;
                } // Consumes a specified amount of characters from the buffered data.
              },
              {
                key: "_getString",
                value: function _getString(n) {
                  var p = this.head;
                  var c = 1;
                  var ret = p.data;
                  n -= ret.length;
                  while ((p = p.next)) {
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                      if (nb === str.length) {
                        ++c;
                        if (p.next) this.head = p.next;
                        else this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = str.slice(nb);
                      }
                      break;
                    }
                    ++c;
                  }
                  this.length -= c;
                  return ret;
                } // Consumes a specified amount of bytes from the buffered data.
              },
              {
                key: "_getBuffer",
                value: function _getBuffer(n) {
                  var ret = Buffer.allocUnsafe(n);
                  var p = this.head;
                  var c = 1;
                  p.data.copy(ret);
                  n -= p.data.length;
                  while ((p = p.next)) {
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                      if (nb === buf.length) {
                        ++c;
                        if (p.next) this.head = p.next;
                        else this.head = this.tail = null;
                      } else {
                        this.head = p;
                        p.data = buf.slice(nb);
                      }
                      break;
                    }
                    ++c;
                  }
                  this.length -= c;
                  return ret;
                } // Make sure the linked list only shows the minimal necessary information.
              },
              {
                key: custom,
                value: function value(_, options) {
                  return inspect(
                    this,
                    _objectSpread({}, options, {
                      // Only inspect one level.
                      depth: 0, // It should not recurse.
                      customInspect: false
                    })
                  );
                }
              }
            ]);
            return BufferList;
          })();
        },
        { buffer: 223, util: 222 }
      ],
      264: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              "use strict"; // undocumented cb() API, needed for core, not for public API
              function destroy(err, cb) {
                var _this = this;
                var readableDestroyed =
                  this._readableState && this._readableState.destroyed;
                var writableDestroyed =
                  this._writableState && this._writableState.destroyed;
                if (readableDestroyed || writableDestroyed) {
                  if (cb) {
                    cb(err);
                  } else if (err) {
                    if (!this._writableState) {
                      process.nextTick(emitErrorNT, this, err);
                    } else if (!this._writableState.errorEmitted) {
                      this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorNT, this, err);
                    }
                  }
                  return this;
                } // we set destroyed to true before firing error callbacks in order
                // to make it re-entrance safe in case destroy() is called within callbacks
                if (this._readableState) {
                  this._readableState.destroyed = true;
                } // if this is a duplex stream mark the writable part as destroyed as well
                if (this._writableState) {
                  this._writableState.destroyed = true;
                }
                this._destroy(err || null, function (err) {
                  if (!cb && err) {
                    if (!_this._writableState) {
                      process.nextTick(emitErrorAndCloseNT, _this, err);
                    } else if (!_this._writableState.errorEmitted) {
                      _this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorAndCloseNT, _this, err);
                    } else {
                      process.nextTick(emitCloseNT, _this);
                    }
                  } else if (cb) {
                    process.nextTick(emitCloseNT, _this);
                    cb(err);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                });
                return this;
              }
              function emitErrorAndCloseNT(self, err) {
                emitErrorNT(self, err);
                emitCloseNT(self);
              }
              function emitCloseNT(self) {
                if (self._writableState && !self._writableState.emitClose) return;
                if (self._readableState && !self._readableState.emitClose) return;
                self.emit("close");
              }
              function undestroy() {
                if (this._readableState) {
                  this._readableState.destroyed = false;
                  this._readableState.reading = false;
                  this._readableState.ended = false;
                  this._readableState.endEmitted = false;
                }
                if (this._writableState) {
                  this._writableState.destroyed = false;
                  this._writableState.ended = false;
                  this._writableState.ending = false;
                  this._writableState.finalCalled = false;
                  this._writableState.prefinished = false;
                  this._writableState.finished = false;
                  this._writableState.errorEmitted = false;
                }
              }
              function emitErrorNT(self, err) {
                self.emit("error", err);
              }
              function errorOrDestroy(stream, err) {
                // We have tests that rely on errors being emitted
                // in the same tick, so changing this is semver major.
                // For now when you opt-in to autoDestroy we allow
                // the error to be emitted nextTick. In a future
                // semver major update we should change the default to this.
                var rState = stream._readableState;
                var wState = stream._writableState;
                if (
                  (rState && rState.autoDestroy) ||
                  (wState && wState.autoDestroy)
                )
                  stream.destroy(err);
                else stream.emit("error", err);
              }
              module.exports = {
                destroy: destroy,
                undestroy: undestroy,
                errorOrDestroy: errorOrDestroy
              };
            }.call(this));
          }.call(this, require("_process")));
        },
        { _process: 246 }
      ],
      265: [
        function (require, module, exports) {
          // Ported from https://github.com/mafintosh/end-of-stream with
          // permission from the author, Mathias Buus (@mafintosh).
          "use strict";
          var ERR_STREAM_PREMATURE_CLOSE =
            require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
          function once(callback) {
            var called = false;
            return function () {
              if (called) return;
              called = true;
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key];
              }
              callback.apply(this, args);
            };
          }
          function noop() {}
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function eos(stream, opts, callback) {
            if (typeof opts === "function") return eos(stream, null, opts);
            if (!opts) opts = {};
            callback = once(callback || noop);
            var readable =
              opts.readable || (opts.readable !== false && stream.readable);
            var writable =
              opts.writable || (opts.writable !== false && stream.writable);
            var onlegacyfinish = function onlegacyfinish() {
              if (!stream.writable) onfinish();
            };
            var writableEnded =
              stream._writableState && stream._writableState.finished;
            var onfinish = function onfinish() {
              writable = false;
              writableEnded = true;
              if (!readable) callback.call(stream);
            };
            var readableEnded =
              stream._readableState && stream._readableState.endEmitted;
            var onend = function onend() {
              readable = false;
              readableEnded = true;
              if (!writable) callback.call(stream);
            };
            var onerror = function onerror(err) {
              callback.call(stream, err);
            };
            var onclose = function onclose() {
              var err;
              if (readable && !readableEnded) {
                if (!stream._readableState || !stream._readableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
              if (writable && !writableEnded) {
                if (!stream._writableState || !stream._writableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
            };
            var onrequest = function onrequest() {
              stream.req.on("finish", onfinish);
            };
            if (isRequest(stream)) {
              stream.on("complete", onfinish);
              stream.on("abort", onclose);
              if (stream.req) onrequest();
              else stream.on("request", onrequest);
            } else if (writable && !stream._writableState) {
              // legacy streams
              stream.on("end", onlegacyfinish);
              stream.on("close", onlegacyfinish);
            }
            stream.on("end", onend);
            stream.on("finish", onfinish);
            if (opts.error !== false) stream.on("error", onerror);
            stream.on("close", onclose);
            return function () {
              stream.removeListener("complete", onfinish);
              stream.removeListener("abort", onclose);
              stream.removeListener("request", onrequest);
              if (stream.req) stream.req.removeListener("finish", onfinish);
              stream.removeListener("end", onlegacyfinish);
              stream.removeListener("close", onlegacyfinish);
              stream.removeListener("finish", onfinish);
              stream.removeListener("end", onend);
              stream.removeListener("error", onerror);
              stream.removeListener("close", onclose);
            };
          }
          module.exports = eos;
        },
        { "../../../errors": 256 }
      ],
      266: [
        function (require, module, exports) {
          module.exports = function () {
            throw new Error("Readable.from is not available in the browser");
          };
        },
        {}
      ],
      267: [
        function (require, module, exports) {
          // Ported from https://github.com/mafintosh/pump with
          // permission from the author, Mathias Buus (@mafintosh).
          "use strict";
          var eos;
          function once(callback) {
            var called = false;
            return function () {
              if (called) return;
              called = true;
              callback.apply(void 0, arguments);
            };
          }
          var _require$codes = require("../../../errors").codes,
            ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
            ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
          function noop(err) {
            // Rethrow the error if it exists to avoid swallowing it
            if (err) throw err;
          }
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function destroyer(stream, reading, writing, callback) {
            callback = once(callback);
            var closed = false;
            stream.on("close", function () {
              closed = true;
            });
            if (eos === undefined) eos = require("./end-of-stream");
            eos(stream, { readable: reading, writable: writing }, function (err) {
              if (err) return callback(err);
              closed = true;
              callback();
            });
            var destroyed = false;
            return function (err) {
              if (closed) return;
              if (destroyed) return;
              destroyed = true; // request.destroy just do .end - .abort is what we want
              if (isRequest(stream)) return stream.abort();
              if (typeof stream.destroy === "function") return stream.destroy();
              callback(err || new ERR_STREAM_DESTROYED("pipe"));
            };
          }
          function call(fn) {
            fn();
          }
          function pipe(from, to) {
            return from.pipe(to);
          }
          function popCallback(streams) {
            if (!streams.length) return noop;
            if (typeof streams[streams.length - 1] !== "function") return noop;
            return streams.pop();
          }
          function pipeline() {
            for (
              var _len = arguments.length, streams = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              streams[_key] = arguments[_key];
            }
            var callback = popCallback(streams);
            if (Array.isArray(streams[0])) streams = streams[0];
            if (streams.length < 2) {
              throw new ERR_MISSING_ARGS("streams");
            }
            var error;
            var destroys = streams.map(function (stream, i) {
              var reading = i < streams.length - 1;
              var writing = i > 0;
              return destroyer(stream, reading, writing, function (err) {
                if (!error) error = err;
                if (err) destroys.forEach(call);
                if (reading) return;
                destroys.forEach(call);
                callback(error);
              });
            });
            return streams.reduce(pipe);
          }
          module.exports = pipeline;
        },
        { "../../../errors": 256, "./end-of-stream": 265 }
      ],
      268: [
        function (require, module, exports) {
          "use strict";
          var ERR_INVALID_OPT_VALUE =
            require("../../../errors").codes.ERR_INVALID_OPT_VALUE;
          function highWaterMarkFrom(options, isDuplex, duplexKey) {
            return options.highWaterMark != null
              ? options.highWaterMark
              : isDuplex
              ? options[duplexKey]
              : null;
          }
          function getHighWaterMark(state, options, duplexKey, isDuplex) {
            var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
            if (hwm != null) {
              if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                var name = isDuplex ? duplexKey : "highWaterMark";
                throw new ERR_INVALID_OPT_VALUE(name, hwm);
              }
              return Math.floor(hwm);
            } // Default value
            return state.objectMode ? 16 : 16 * 1024;
          }
          module.exports = { getHighWaterMark: getHighWaterMark };
        },
        { "../../../errors": 256 }
      ],
      269: [
        function (require, module, exports) {
          module.exports = require("events").EventEmitter;
        },
        { events: 228 }
      ],
      270: [
        function (require, module, exports) {
          exports = module.exports = require("./lib/_stream_readable.js");
          exports.Stream = exports;
          exports.Readable = exports;
          exports.Writable = require("./lib/_stream_writable.js");
          exports.Duplex = require("./lib/_stream_duplex.js");
          exports.Transform = require("./lib/_stream_transform.js");
          exports.PassThrough = require("./lib/_stream_passthrough.js");
          exports.finished = require("./lib/internal/streams/end-of-stream.js");
          exports.pipeline = require("./lib/internal/streams/pipeline.js");
        },
        {
          "./lib/_stream_duplex.js": 257,
          "./lib/_stream_passthrough.js": 258,
          "./lib/_stream_readable.js": 259,
          "./lib/_stream_transform.js": 260,
          "./lib/_stream_writable.js": 261,
          "./lib/internal/streams/end-of-stream.js": 265,
          "./lib/internal/streams/pipeline.js": 267
        }
      ],
      271: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          "use strict";
          /*<replacement>*/ var Buffer = require("safe-buffer").Buffer;
          /*</replacement>*/ var isEncoding =
            Buffer.isEncoding ||
            function (encoding) {
              encoding = "" + encoding;
              switch (encoding && encoding.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                  return true;
                default:
                  return false;
              }
            };
          function _normalizeEncoding(enc) {
            if (!enc) return "utf8";
            var retried;
            while (true) {
              switch (enc) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return enc;
                default: // undefined
                  if (retried) return;
                  enc = ("" + enc).toLowerCase();
                  retried = true;
              }
            }
          } // Do not cache `Buffer.isEncoding` when checking encoding names as some
          // modules monkey-patch it to support additional encodings
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc);
            if (
              typeof nenc !== "string" &&
              (Buffer.isEncoding === isEncoding || !isEncoding(enc))
            )
              throw new Error("Unknown encoding: " + enc);
            return nenc || enc;
          } // StringDecoder provides an interface for efficiently splitting a series of
          // buffers into a series of JS strings without breaking apart multi-byte
          // characters.
          exports.StringDecoder = StringDecoder;
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding);
            var nb;
            switch (this.encoding) {
              case "utf16le":
                this.text = utf16Text;
                this.end = utf16End;
                nb = 4;
                break;
              case "utf8":
                this.fillLast = utf8FillLast;
                nb = 4;
                break;
              case "base64":
                this.text = base64Text;
                this.end = base64End;
                nb = 3;
                break;
              default:
                this.write = simpleWrite;
                this.end = simpleEnd;
                return;
            }
            this.lastNeed = 0;
            this.lastTotal = 0;
            this.lastChar = Buffer.allocUnsafe(nb);
          }
          StringDecoder.prototype.write = function (buf) {
            if (buf.length === 0) return "";
            var r;
            var i;
            if (this.lastNeed) {
              r = this.fillLast(buf);
              if (r === undefined) return "";
              i = this.lastNeed;
              this.lastNeed = 0;
            } else {
              i = 0;
            }
            if (i < buf.length)
              return r ? r + this.text(buf, i) : this.text(buf, i);
            return r || "";
          };
          StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer
          StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
          StringDecoder.prototype.fillLast = function (buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(
                this.lastChar,
                this.lastTotal - this.lastNeed,
                0,
                this.lastNeed
              );
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              buf.length
            );
            this.lastNeed -= buf.length;
          }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
          // continuation byte. If an invalid byte is detected, -2 is returned.
          function utf8CheckByte(_byte) {
            if (_byte <= 0x7f) return 0;
            else if (_byte >> 5 === 0x06) return 2;
            else if (_byte >> 4 === 0x0e) return 3;
            else if (_byte >> 3 === 0x1e) return 4;
            return _byte >> 6 === 0x02 ? -1 : -2;
          } // Checks at most 3 bytes at the end of a Buffer in order to detect an
          // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
          // needed to complete the UTF-8 character (if applicable) are returned.
          function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1;
            if (j < i) return 0;
            var nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 1;
              return nb;
            }
            if (--j < i || nb === -2) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 2;
              return nb;
            }
            if (--j < i || nb === -2) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2) nb = 0;
                else self.lastNeed = nb - 3;
              }
              return nb;
            }
            return 0;
          } // Validates as many continuation bytes for a multi-byte UTF-8 character as
          // needed or are available. If we see a non-continuation byte where we expect
          // one, we "replace" the validated continuation bytes we've seen so far with
          // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
          // behavior. The continuation byte check is included three times in the case
          // where all of the continuation bytes for a character exist in the same buffer.
          // It is also done this way as a slight performance increase instead of using a
          // loop.
          function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 0xc0) !== 0x80) {
              self.lastNeed = 0;
              return "\uFFFD";
            }
            if (self.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 0xc0) !== 0x80) {
                self.lastNeed = 1;
                return "\uFFFD";
              }
              if (self.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 0xc0) !== 0x80) {
                  self.lastNeed = 2;
                  return "\uFFFD";
                }
              }
            }
          } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
          function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed;
            var r = utf8CheckExtraBytes(this, buf, p);
            if (r !== undefined) return r;
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, p, 0, buf.length);
            this.lastNeed -= buf.length;
          } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
          // partial character, the character's bytes are buffered until the required
          // number of bytes are available.
          function utf8Text(buf, i) {
            var total = utf8CheckIncomplete(this, buf, i);
            if (!this.lastNeed) return buf.toString("utf8", i);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            buf.copy(this.lastChar, 0, end);
            return buf.toString("utf8", i, end);
          } // For UTF-8, a replacement character is added when ending on a partial
          // character.
          function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) return r + "\uFFFD";
            return r;
          } // UTF-16LE typically needs two bytes per character, but even if we have an even
          // number of bytes available, we need to check if we end on a leading/high
          // surrogate. In that case, we need to wait for the next two bytes in order to
          // decode the last character properly.
          function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
              var r = buf.toString("utf16le", i);
              if (r) {
                var c = r.charCodeAt(r.length - 1);
                if (c >= 0xd800 && c <= 0xdbff) {
                  this.lastNeed = 2;
                  this.lastTotal = 4;
                  this.lastChar[0] = buf[buf.length - 2];
                  this.lastChar[1] = buf[buf.length - 1];
                  return r.slice(0, -1);
                }
              }
              return r;
            }
            this.lastNeed = 1;
            this.lastTotal = 2;
            this.lastChar[0] = buf[buf.length - 1];
            return buf.toString("utf16le", i, buf.length - 1);
          } // For UTF-16LE we do not explicitly append special replacement characters if we
          // end on a partial character, we simply let v8 handle that.
          function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed;
              return r + this.lastChar.toString("utf16le", 0, end);
            }
            return r;
          }
          function base64Text(buf, i) {
            var n = (buf.length - i) % 3;
            if (n === 0) return buf.toString("base64", i);
            this.lastNeed = 3 - n;
            this.lastTotal = 3;
            if (n === 1) {
              this.lastChar[0] = buf[buf.length - 1];
            } else {
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
            }
            return buf.toString("base64", i, buf.length - n);
          }
          function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed)
              return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
            return r;
          } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
          function simpleWrite(buf) {
            return buf.toString(this.encoding);
          }
          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : "";
          }
        },
        { "safe-buffer": 251 }
      ],
      272: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          "use strict";
          var punycode = require("punycode");
          var util = require("./util");
          exports.parse = urlParse;
          exports.resolve = urlResolve;
          exports.resolveObject = urlResolveObject;
          exports.format = urlFormat;
          exports.Url = Url;
          function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
          } // Reference: RFC 3986, RFC 1808, RFC 2396
          // define these here so at least they only have to be
          // compiled once on the first module load.
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/, // Special case for a simple path URL
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, // RFC 2396: characters reserved for delimiting URLs.
            // We actually just auto-escape these.
            delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"], // RFC 2396: characters not allowed for various reasons.
            unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ["'"].concat(unwise), // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
            hostEndingChars = ["/", "?", "#"],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = { javascript: true, "javascript:": true }, // protocols that never have a hostname.
            hostlessProtocol = { javascript: true, "javascript:": true }, // protocols that always contain a // bit.
            slashedProtocol = {
              http: true,
              https: true,
              ftp: true,
              gopher: true,
              file: true,
              "http:": true,
              "https:": true,
              "ftp:": true,
              "gopher:": true,
              "file:": true
            },
            querystring = require("querystring");
          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url;
            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
          }
          Url.prototype.parse = function (
            url,
            parseQueryString,
            slashesDenoteHost
          ) {
            if (!util.isString(url)) {
              throw new TypeError(
                "Parameter 'url' must be a string, not " + _typeof2(url)
              );
            } // Copy chrome, IE, opera backslash-handling behavior.
            // Back slashes before the query string get converted to forward slashes
            // See: https://code.google.com/p/chromium/issues/detail?id=25916
            var queryIndex = url.indexOf("?"),
              splitter =
                queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
              uSplit = url.split(splitter),
              slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, "/");
            url = uSplit.join(splitter);
            var rest = url; // trim before proceeding.
            // This is to support parse stuff like "  http://foo.com  \n"
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
              // Try fast path regexp
              var simplePath = simplePathPattern.exec(rest);
              if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                  this.search = simplePath[2];
                  if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                  } else {
                    this.query = this.search.substr(1);
                  }
                } else if (parseQueryString) {
                  this.search = "";
                  this.query = {};
                }
                return this;
              }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              this.protocol = lowerProto;
              rest = rest.substr(proto.length);
            } // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (
              slashesDenoteHost ||
              proto ||
              rest.match(/^\/\/[^@\/]+@[^@\/]+/)
            ) {
              var slashes = rest.substr(0, 2) === "//";
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
              }
            }
            if (
              !hostlessProtocol[proto] &&
              (slashes || (proto && !slashedProtocol[proto]))
            ) {
              // there's a hostname.
              // the first instance of /, ?, ;, or # ends the host.
              //
              // If there is an @ in the hostname, then non-host chars *are* allowed
              // to the left of the last @ sign, unless some host-ending character
              // comes *before* the @-sign.
              // URLs are obnoxious.
              //
              // ex:
              // http://a@b@c/ => user:a@b host:c
              // http://a@b?@c => user:a host:c path:/?@c
              // v0.12 TODO(isaacs): This is not quite how Chrome does things.
              // Review our test case against browsers more comprehensively.
              // find the first instance of any hostEndingChars
              var hostEnd = -1;
              for (var i = 0; i < hostEndingChars.length; i++) {
                var hec = rest.indexOf(hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              } // at this point, either we have an explicit point where the
              // auth portion cannot go past, or the last @ char is the decider.
              var auth, atSign;
              if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf("@");
              } else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf("@", hostEnd);
              } // Now we have a portion which is definitely the auth.
              // Pull that off.
              if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
              } // the host is the remaining to the left of the first non-host char
              hostEnd = -1;
              for (var i = 0; i < nonHostChars.length; i++) {
                var hec = rest.indexOf(nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              } // if we still have not hit it, then the entire thing is a host.
              if (hostEnd === -1) hostEnd = rest.length;
              this.host = rest.slice(0, hostEnd);
              rest = rest.slice(hostEnd); // pull out port.
              this.parseHost(); // we've indicated that there is a hostname,
              // so even if it's empty, it has to be present.
              this.hostname = this.hostname || ""; // if hostname begins with [ and ends with ]
              // assume that it's an IPv6 address.
              var ipv6Hostname =
                this.hostname[0] === "[" &&
                this.hostname[this.hostname.length - 1] === "]"; // validate a little.
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (!part) continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = "";
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        // we replace non-ASCII char with a temporary placeholder
                        // we need this to make sure size of hostname is not
                        // broken by replacing non-ASCII by nothing
                        newpart += "x";
                      } else {
                        newpart += part[j];
                      }
                    } // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i);
                      var notHost = hostparts.slice(i + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = "/" + notHost.join(".") + rest;
                      }
                      this.hostname = validParts.join(".");
                      break;
                    }
                  }
                }
              }
              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = "";
              } else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase();
              }
              if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = punycode.toASCII(this.hostname);
              }
              var p = this.port ? ":" + this.port : "";
              var h = this.hostname || "";
              this.host = h + p;
              this.href += this.host; // strip [ and ] from the hostname
              // the host field still retains them, though
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== "/") {
                  rest = "/" + rest;
                }
              }
            } // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {
              // First, make 100% sure that any "autoEscape" chars get
              // escaped, even if encodeURIComponent doesn't think they
              // need to be.
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                if (rest.indexOf(ae) === -1) continue;
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                  esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
              }
            } // chop off from the tail first.
            var hash = rest.indexOf("#");
            if (hash !== -1) {
              // got a fragment string.
              this.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
              this.search = rest.substr(qm);
              this.query = rest.substr(qm + 1);
              if (parseQueryString) {
                this.query = querystring.parse(this.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              // no query string, but parseQueryString still requested
              this.search = "";
              this.query = {};
            }
            if (rest) this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
              this.pathname = "/";
            } //to support http.request
            if (this.pathname || this.search) {
              var p = this.pathname || "";
              var s = this.search || "";
              this.path = p + s;
            } // finally, reconstruct the href based on what has been validated.
            this.href = this.format();
            return this;
          }; // format a parsed object into a url string
          function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (util.isString(obj)) obj = urlParse(obj);
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
            return obj.format();
          }
          Url.prototype.format = function () {
            var auth = this.auth || "";
            if (auth) {
              auth = encodeURIComponent(auth);
              auth = auth.replace(/%3A/i, ":");
              auth += "@";
            }
            var protocol = this.protocol || "",
              pathname = this.pathname || "",
              hash = this.hash || "",
              host = false,
              query = "";
            if (this.host) {
              host = auth + this.host;
            } else if (this.hostname) {
              host =
                auth +
                (this.hostname.indexOf(":") === -1
                  ? this.hostname
                  : "[" + this.hostname + "]");
              if (this.port) {
                host += ":" + this.port;
              }
            }
            if (
              this.query &&
              util.isObject(this.query) &&
              Object.keys(this.query).length
            ) {
              query = querystring.stringify(this.query);
            }
            var search = this.search || (query && "?" + query) || "";
            if (protocol && protocol.substr(-1) !== ":") protocol += ":"; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (
              this.slashes ||
              ((!protocol || slashedProtocol[protocol]) && host !== false)
            ) {
              host = "//" + (host || "");
              if (pathname && pathname.charAt(0) !== "/")
                pathname = "/" + pathname;
            } else if (!host) {
              host = "";
            }
            if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
            if (search && search.charAt(0) !== "?") search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function (match) {
              return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
          };
          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
          }
          Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
          };
          function urlResolveObject(source, relative) {
            if (!source) return relative;
            return urlParse(source, false, true).resolveObject(relative);
          }
          Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) {
              var rel = new Url();
              rel.parse(relative, false, true);
              relative = rel;
            }
            var result = new Url();
            var tkeys = Object.keys(this);
            for (var tk = 0; tk < tkeys.length; tk++) {
              var tkey = tkeys[tk];
              result[tkey] = this[tkey];
            } // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.
            if (relative.href === "") {
              result.href = result.format();
              return result;
            } // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
              // take everything except the protocol from relative
              var rkeys = Object.keys(relative);
              for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative[rkey];
              } //urlParse appends trailing / to urls like http://www.example.com
              if (
                slashedProtocol[result.protocol] &&
                result.hostname &&
                !result.pathname
              ) {
                result.path = result.pathname = "/";
              }
              result.href = result.format();
              return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
              // if it's a known url protocol, then changing
              // the protocol does weird things
              // first, if it's not file:, then we MUST have a host,
              // and if there was a path
              // to begin with, then we MUST have a path.
              // if it is file:, then the host is dropped,
              // because that's known to be hostless.
              // anything else is assumed to be absolute.
              if (!slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                  var k = keys[v];
                  result[k] = relative[k];
                }
                result.href = result.format();
                return result;
              }
              result.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || "").split("/");
                while (relPath.length && !(relative.host = relPath.shift())) {}
                if (!relative.host) relative.host = "";
                if (!relative.hostname) relative.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
              } else {
                result.pathname = relative.pathname;
              }
              result.search = relative.search;
              result.query = relative.query;
              result.host = relative.host || "";
              result.auth = relative.auth;
              result.hostname = relative.hostname || relative.host;
              result.port = relative.port; // to support http.request
              if (result.pathname || result.search) {
                var p = result.pathname || "";
                var s = result.search || "";
                result.path = p + s;
              }
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            }
            var isSourceAbs =
                result.pathname && result.pathname.charAt(0) === "/",
              isRelAbs =
                relative.host ||
                (relative.pathname && relative.pathname.charAt(0) === "/"),
              mustEndAbs =
                isRelAbs || isSourceAbs || (result.host && relative.pathname),
              removeAllDots = mustEndAbs,
              srcPath = (result.pathname && result.pathname.split("/")) || [],
              relPath = (relative.pathname && relative.pathname.split("/")) || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
              result.hostname = "";
              result.port = null;
              if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
              }
              result.host = "";
              if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                  if (relPath[0] === "") relPath[0] = relative.host;
                  else relPath.unshift(relative.host);
                }
                relative.host = null;
              }
              mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
              // it's absolute.
              result.host =
                relative.host || relative.host === ""
                  ? relative.host
                  : result.host;
              result.hostname =
                relative.hostname || relative.hostname === ""
                  ? relative.hostname
                  : result.hostname;
              result.search = relative.search;
              result.query = relative.query;
              srcPath = relPath; // fall through to the dot-handling below.
            } else if (relPath.length) {
              // it's relative
              // throw away the existing file, and take the new path instead.
              if (!srcPath) srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              result.search = relative.search;
              result.query = relative.query;
            } else if (!util.isNullOrUndefined(relative.search)) {
              // just pull out the search.
              // like href='?foo'.
              // Put this after the other two cases because it simplifies the booleans
              if (psychotic) {
                result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost =
                  result.host && result.host.indexOf("@") > 0
                    ? result.host.split("@")
                    : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }
              result.search = relative.search;
              result.query = relative.query; //to support http.request
              if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path =
                  (result.pathname ? result.pathname : "") +
                  (result.search ? result.search : "");
              }
              result.href = result.format();
              return result;
            }
            if (!srcPath.length) {
              // no path at all.  easy.
              // we've already handled the other stuff above.
              result.pathname = null; //to support http.request
              if (result.search) {
                result.path = "/" + result.search;
              } else {
                result.path = null;
              }
              result.href = result.format();
              return result;
            } // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash =
              ((result.host || relative.host || srcPath.length > 1) &&
                (last === "." || last === "..")) ||
              last === ""; // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i];
              if (last === ".") {
                srcPath.splice(i, 1);
              } else if (last === "..") {
                srcPath.splice(i, 1);
                up++;
              } else if (up) {
                srcPath.splice(i, 1);
                up--;
              }
            } // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift("..");
              }
            }
            if (
              mustEndAbs &&
              srcPath[0] !== "" &&
              (!srcPath[0] || srcPath[0].charAt(0) !== "/")
            ) {
              srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
              srcPath.push("");
            }
            var isAbsolute =
              srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/"); // put the host back
            if (psychotic) {
              result.hostname = result.host = isAbsolute
                ? ""
                : srcPath.length
                ? srcPath.shift()
                : ""; //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf("@") > 0
                  ? result.host.split("@")
                  : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            mustEndAbs = mustEndAbs || (result.host && srcPath.length);
            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift("");
            }
            if (!srcPath.length) {
              result.pathname = null;
              result.path = null;
            } else {
              result.pathname = srcPath.join("/");
            } //to support request.http
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : "") +
                (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          };
          Url.prototype.parseHost = function () {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              if (port !== ":") {
                this.port = port.substr(1);
              }
              host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
          };
        },
        { "./util": 273, punycode: 247, querystring: 250 }
      ],
      273: [
        function (require, module, exports) {
          "use strict";
          module.exports = {
            isString: function isString(arg) {
              return typeof arg === "string";
            },
            isObject: function isObject(arg) {
              return _typeof2(arg) === "object" && arg !== null;
            },
            isNull: function isNull(arg) {
              return arg === null;
            },
            isNullOrUndefined: function isNullOrUndefined(arg) {
              return arg == null;
            }
          };
        },
        {}
      ],
      274: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              /**
               * Module exports.
               */ module.exports = deprecate;
              /**
               * Mark that a method should not be used.
               * Returns a modified function which warns once by default.
               *
               * If `localStorage.noDeprecation = true` is set, then it is a no-op.
               *
               * If `localStorage.throwDeprecation = true` is set, then deprecated functions
               * will throw an Error when invoked.
               *
               * If `localStorage.traceDeprecation = true` is set, then deprecated functions
               * will invoke `console.trace()` instead of `console.error()`.
               *
               * @param {Function} fn - the function to deprecate
               * @param {String} msg - the string to print to the console when `fn` is invoked
               * @returns {Function} a new "deprecated" version of `fn`
               * @api public
               */ function deprecate(fn, msg) {
                if (config("noDeprecation")) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (config("throwDeprecation")) {
                      throw new Error(msg);
                    } else if (config("traceDeprecation")) {
                      console.trace(msg);
                    } else {
                      console.warn(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              }
              /**
               * Checks `localStorage` for boolean values for the given `name`.
               *
               * @param {String} name
               * @returns {Boolean}
               * @api private
               */ function config(name) {
                // accessing global.localStorage can trigger a DOMException in sandboxed iframes
                try {
                  if (!global.localStorage) return false;
                } catch (_) {
                  return false;
                }
                var val = global.localStorage[name];
                if (null == val) return false;
                return String(val).toLowerCase() === "true";
              }
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {}
      ],
      275: [
        function (require, module, exports) {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              _typeof2(arg) === "object" &&
              typeof arg.copy === "function" &&
              typeof arg.fill === "function" &&
              typeof arg.readUInt8 === "function"
            );
          };
        },
        {}
      ],
      276: [
        function (require, module, exports) {
          // Currently in sync with Node.js lib/internal/util/types.js
          // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
          "use strict";
          var isArgumentsObject = require("is-arguments");
          var isGeneratorFunction = require("is-generator-function");
          var whichTypedArray = require("which-typed-array");
          var isTypedArray = require("is-typed-array");
          function uncurryThis(f) {
            return f.call.bind(f);
          }
          var BigIntSupported = typeof BigInt !== "undefined";
          var SymbolSupported = typeof Symbol !== "undefined";
          var ObjectToString = uncurryThis(Object.prototype.toString);
          var numberValue = uncurryThis(Number.prototype.valueOf);
          var stringValue = uncurryThis(String.prototype.valueOf);
          var booleanValue = uncurryThis(Boolean.prototype.valueOf);
          if (BigIntSupported) {
            var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
          }
          if (SymbolSupported) {
            var symbolValue = uncurryThis(Symbol.prototype.valueOf);
          }
          function checkBoxedPrimitive(value, prototypeValueOf) {
            if (_typeof2(value) !== "object") {
              return false;
            }
            try {
              prototypeValueOf(value);
              return true;
            } catch (e) {
              return false;
            }
          }
          exports.isArgumentsObject = isArgumentsObject;
          exports.isGeneratorFunction = isGeneratorFunction;
          exports.isTypedArray = isTypedArray; // Taken from here and modified for better browser support
          // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
          function isPromise(input) {
            return (
              (typeof Promise !== "undefined" && input instanceof Promise) ||
              (input !== null &&
                _typeof2(input) === "object" &&
                typeof input.then === "function" &&
                typeof input["catch"] === "function")
            );
          }
          exports.isPromise = isPromise;
          function isArrayBufferView(value) {
            if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
              return ArrayBuffer.isView(value);
            }
            return isTypedArray(value) || isDataView(value);
          }
          exports.isArrayBufferView = isArrayBufferView;
          function isUint8Array(value) {
            return whichTypedArray(value) === "Uint8Array";
          }
          exports.isUint8Array = isUint8Array;
          function isUint8ClampedArray(value) {
            return whichTypedArray(value) === "Uint8ClampedArray";
          }
          exports.isUint8ClampedArray = isUint8ClampedArray;
          function isUint16Array(value) {
            return whichTypedArray(value) === "Uint16Array";
          }
          exports.isUint16Array = isUint16Array;
          function isUint32Array(value) {
            return whichTypedArray(value) === "Uint32Array";
          }
          exports.isUint32Array = isUint32Array;
          function isInt8Array(value) {
            return whichTypedArray(value) === "Int8Array";
          }
          exports.isInt8Array = isInt8Array;
          function isInt16Array(value) {
            return whichTypedArray(value) === "Int16Array";
          }
          exports.isInt16Array = isInt16Array;
          function isInt32Array(value) {
            return whichTypedArray(value) === "Int32Array";
          }
          exports.isInt32Array = isInt32Array;
          function isFloat32Array(value) {
            return whichTypedArray(value) === "Float32Array";
          }
          exports.isFloat32Array = isFloat32Array;
          function isFloat64Array(value) {
            return whichTypedArray(value) === "Float64Array";
          }
          exports.isFloat64Array = isFloat64Array;
          function isBigInt64Array(value) {
            return whichTypedArray(value) === "BigInt64Array";
          }
          exports.isBigInt64Array = isBigInt64Array;
          function isBigUint64Array(value) {
            return whichTypedArray(value) === "BigUint64Array";
          }
          exports.isBigUint64Array = isBigUint64Array;
          function isMapToString(value) {
            return ObjectToString(value) === "[object Map]";
          }
          isMapToString.working =
            typeof Map !== "undefined" && isMapToString(new Map());
          function isMap(value) {
            if (typeof Map === "undefined") {
              return false;
            }
            return isMapToString.working
              ? isMapToString(value)
              : value instanceof Map;
          }
          exports.isMap = isMap;
          function isSetToString(value) {
            return ObjectToString(value) === "[object Set]";
          }
          isSetToString.working =
            typeof Set !== "undefined" && isSetToString(new Set());
          function isSet(value) {
            if (typeof Set === "undefined") {
              return false;
            }
            return isSetToString.working
              ? isSetToString(value)
              : value instanceof Set;
          }
          exports.isSet = isSet;
          function isWeakMapToString(value) {
            return ObjectToString(value) === "[object WeakMap]";
          }
          isWeakMapToString.working =
            typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
          function isWeakMap(value) {
            if (typeof WeakMap === "undefined") {
              return false;
            }
            return isWeakMapToString.working
              ? isWeakMapToString(value)
              : value instanceof WeakMap;
          }
          exports.isWeakMap = isWeakMap;
          function isWeakSetToString(value) {
            return ObjectToString(value) === "[object WeakSet]";
          }
          isWeakSetToString.working =
            typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
          function isWeakSet(value) {
            return isWeakSetToString(value);
          }
          exports.isWeakSet = isWeakSet;
          function isArrayBufferToString(value) {
            return ObjectToString(value) === "[object ArrayBuffer]";
          }
          isArrayBufferToString.working =
            typeof ArrayBuffer !== "undefined" &&
            isArrayBufferToString(new ArrayBuffer());
          function isArrayBuffer(value) {
            if (typeof ArrayBuffer === "undefined") {
              return false;
            }
            return isArrayBufferToString.working
              ? isArrayBufferToString(value)
              : value instanceof ArrayBuffer;
          }
          exports.isArrayBuffer = isArrayBuffer;
          function isDataViewToString(value) {
            return ObjectToString(value) === "[object DataView]";
          }
          isDataViewToString.working =
            typeof ArrayBuffer !== "undefined" &&
            typeof DataView !== "undefined" &&
            isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
          function isDataView(value) {
            if (typeof DataView === "undefined") {
              return false;
            }
            return isDataViewToString.working
              ? isDataViewToString(value)
              : value instanceof DataView;
          }
          exports.isDataView = isDataView; // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
          var SharedArrayBufferCopy =
            typeof SharedArrayBuffer !== "undefined"
              ? SharedArrayBuffer
              : undefined;
          function isSharedArrayBufferToString(value) {
            return ObjectToString(value) === "[object SharedArrayBuffer]";
          }
          function isSharedArrayBuffer(value) {
            if (typeof SharedArrayBufferCopy === "undefined") {
              return false;
            }
            if (typeof isSharedArrayBufferToString.working === "undefined") {
              isSharedArrayBufferToString.working = isSharedArrayBufferToString(
                new SharedArrayBufferCopy()
              );
            }
            return isSharedArrayBufferToString.working
              ? isSharedArrayBufferToString(value)
              : value instanceof SharedArrayBufferCopy;
          }
          exports.isSharedArrayBuffer = isSharedArrayBuffer;
          function isAsyncFunction(value) {
            return ObjectToString(value) === "[object AsyncFunction]";
          }
          exports.isAsyncFunction = isAsyncFunction;
          function isMapIterator(value) {
            return ObjectToString(value) === "[object Map Iterator]";
          }
          exports.isMapIterator = isMapIterator;
          function isSetIterator(value) {
            return ObjectToString(value) === "[object Set Iterator]";
          }
          exports.isSetIterator = isSetIterator;
          function isGeneratorObject(value) {
            return ObjectToString(value) === "[object Generator]";
          }
          exports.isGeneratorObject = isGeneratorObject;
          function isWebAssemblyCompiledModule(value) {
            return ObjectToString(value) === "[object WebAssembly.Module]";
          }
          exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
          function isNumberObject(value) {
            return checkBoxedPrimitive(value, numberValue);
          }
          exports.isNumberObject = isNumberObject;
          function isStringObject(value) {
            return checkBoxedPrimitive(value, stringValue);
          }
          exports.isStringObject = isStringObject;
          function isBooleanObject(value) {
            return checkBoxedPrimitive(value, booleanValue);
          }
          exports.isBooleanObject = isBooleanObject;
          function isBigIntObject(value) {
            return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
          }
          exports.isBigIntObject = isBigIntObject;
          function isSymbolObject(value) {
            return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
          }
          exports.isSymbolObject = isSymbolObject;
          function isBoxedPrimitive(value) {
            return (
              isNumberObject(value) ||
              isStringObject(value) ||
              isBooleanObject(value) ||
              isBigIntObject(value) ||
              isSymbolObject(value)
            );
          }
          exports.isBoxedPrimitive = isBoxedPrimitive;
          function isAnyArrayBuffer(value) {
            return (
              typeof Uint8Array !== "undefined" &&
              (isArrayBuffer(value) || isSharedArrayBuffer(value))
            );
          }
          exports.isAnyArrayBuffer = isAnyArrayBuffer;
          ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (
            method
          ) {
            Object.defineProperty(exports, method, {
              enumerable: false,
              value: function value() {
                throw new Error(method + " is not supported in userland");
              }
            });
          });
        },
        {
          "is-arguments": 240,
          "is-generator-function": 243,
          "is-typed-array": 244,
          "which-typed-array": 278
        }
      ],
      277: [
        function (require, module, exports) {
          (function (process) {
            (function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              var getOwnPropertyDescriptors =
                Object.getOwnPropertyDescriptors ||
                function getOwnPropertyDescriptors(obj) {
                  var keys = Object.keys(obj);
                  var descriptors = {};
                  for (var i = 0; i < keys.length; i++) {
                    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(
                      obj,
                      keys[i]
                    );
                  }
                  return descriptors;
                };
              var formatRegExp = /%[sdj%]/g;
              exports.format = function (f) {
                if (!isString(f)) {
                  var objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function (x) {
                  if (x === "%%") return "%";
                  if (i >= len) return x;
                  switch (x) {
                    case "%s":
                      return String(args[i++]);
                    case "%d":
                      return Number(args[i++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return "[Circular]";
                      }
                    default:
                      return x;
                  }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                  } else {
                    str += " " + inspect(x);
                  }
                }
                return str;
              }; // Mark that a method should not be used.
              // Returns a modified function which warns once by default.
              // If --no-deprecation is set, then it is a no-op.
              exports.deprecate = function (fn, msg) {
                if (
                  typeof process !== "undefined" &&
                  process.noDeprecation === true
                ) {
                  return fn;
                } // Allow for deprecating things in the process of starting up.
                if (typeof process === "undefined") {
                  return function () {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnvRegex = /^$/;
              if (process.env.NODE_DEBUG) {
                var debugEnv = process.env.NODE_DEBUG;
                debugEnv = debugEnv
                  .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
                  .replace(/\*/g, ".*")
                  .replace(/,/g, "$|^")
                  .toUpperCase();
                debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
              }
              exports.debuglog = function (set) {
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (debugEnvRegex.test(set)) {
                    var pid = process.pid;
                    debugs[set] = function () {
                      var msg = exports.format.apply(exports, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function () {};
                  }
                }
                return debugs[set];
              };
              /**
               * Echos the value of a value. Trys to print the value out
               * in the best way possible given the different types.
               *
               * @param {Object} obj The object to print out.
               * @param {Object} opts Optional options object that alters the output.
               */ /* legacy: obj, showHidden, depth, colors*/ function inspect(
                obj,
                opts
              ) {
                // default options
                var ctx = { seen: [], stylize: stylizeNoColor }; // legacy...
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  // legacy...
                  ctx.showHidden = opts;
                } else if (opts) {
                  // got an "options" object
                  exports._extend(ctx, opts);
                } // set default options
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
              inspect.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
              }; // Don't use 'blue' not visible on cmd.exe
              inspect.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta", // "name": intentionally not styling
                regexp: "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return (
                    "\x1B[" +
                    inspect.colors[style][0] +
                    "m" +
                    str +
                    "\x1B[" +
                    inspect.colors[style][1] +
                    "m"
                  );
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function (val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                // Provide a hook for user-specified inspect functions.
                // Check that value is an object with an inspect function on it
                if (
                  ctx.customInspect &&
                  value &&
                  isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
                  !(value.constructor && value.constructor.prototype === value)
                ) {
                  var ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                } // Primitive types cannot have properties
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                } // Look up the keys of the object.
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                } // IE doesn't make error fields non-enumerable
                // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                if (
                  isError(value) &&
                  (keys.indexOf("message") >= 0 ||
                    keys.indexOf("description") >= 0)
                ) {
                  return formatError(value);
                } // Some type of object without properties can be shortcutted.
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(
                      RegExp.prototype.toString.call(value),
                      "regexp"
                    );
                  }
                  if (isDate(value)) {
                    return ctx.stylize(
                      Date.prototype.toString.call(value),
                      "date"
                    );
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "",
                  array = false,
                  braces = ["{", "}"]; // Make Array say that they are Array
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                } // Make functions say that they are functions
                if (isFunction(value)) {
                  var n = value.name ? ": " + value.name : "";
                  base = " [Function" + n + "]";
                } // Make RegExps say that they are RegExps
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                } // Make dates with properties first say the date
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                } // Make error with message first say the error
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(
                      RegExp.prototype.toString.call(value),
                      "regexp"
                    );
                  } else {
                    return ctx.stylize("[Object]", "special");
                  }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    keys
                  );
                } else {
                  output = keys.map(function (key) {
                    return formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      array
                    );
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple =
                    "'" +
                    JSON.stringify(value)
                      .replace(/^"|"$/g, "")
                      .replace(/'/g, "\\'")
                      .replace(/\\"/g, '"') +
                    "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value)) return ctx.stylize("" + value, "number");
                if (isBoolean(value)) return ctx.stylize("" + value, "boolean"); // For some reason typeof null is "object", so special case here.
                if (isNull(value)) return ctx.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty(value, String(i))) {
                    output.push(
                      formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        String(i),
                        true
                      )
                    );
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function (key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(
                      formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        key,
                        true
                      )
                    );
                  }
                });
                return output;
              }
              function formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                key,
                array
              ) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || {
                  value: value[key]
                };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str
                          .split("\n")
                          .map(function (line) {
                            return "  " + line;
                          })
                          .join("\n")
                          .substr(2);
                      } else {
                        str =
                          "\n" +
                          str
                            .split("\n")
                            .map(function (line) {
                              return "   " + line;
                            })
                            .join("\n");
                      }
                    }
                  } else {
                    str = ctx.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, "name");
                  } else {
                    name = name
                      .replace(/'/g, "\\'")
                      .replace(/\\"/g, '"')
                      .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function (prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf("\n") >= 0) numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return (
                    braces[0] +
                    (base === "" ? "" : base + "\n ") +
                    " " +
                    output.join(",\n  ") +
                    " " +
                    braces[1]
                  );
                }
                return (
                  braces[0] + base + " " + output.join(", ") + " " + braces[1]
                );
              } // NOTE: These type checking functions intentionally don't use `instanceof`
              // because it is fragile and can be easily faked with `Object.create()`.
              exports.types = require("./support/types");
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports.isString = isString;
              function isSymbol(arg) {
                return _typeof2(arg) === "symbol";
              }
              exports.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
              }
              exports.isRegExp = isRegExp;
              exports.types.isRegExp = isRegExp;
              function isObject(arg) {
                return _typeof2(arg) === "object" && arg !== null;
              }
              exports.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
              }
              exports.isDate = isDate;
              exports.types.isDate = isDate;
              function isError(e) {
                return (
                  isObject(e) &&
                  (objectToString(e) === "[object Error]" || e instanceof Error)
                );
              }
              exports.isError = isError;
              exports.types.isNativeError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports.isFunction = isFunction;
              function isPrimitive(arg) {
                return (
                  arg === null ||
                  typeof arg === "boolean" ||
                  typeof arg === "number" ||
                  typeof arg === "string" ||
                  _typeof2(arg) === "symbol" || // ES6 symbol
                  typeof arg === "undefined"
                );
              }
              exports.isPrimitive = isPrimitive;
              exports.isBuffer = require("./support/isBuffer");
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ]; // 26 Feb 16:19:34
              function timestamp() {
                var d = new Date();
                var time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ");
              } // log is just a thin wrapper to console.log that prepends a timestamp
              exports.log = function () {
                console.log(
                  "%s - %s",
                  timestamp(),
                  exports.format.apply(exports, arguments)
                );
              };
              /**
               * Inherit the prototype methods from one constructor into another.
               *
               * The Function.prototype.inherits from lang.js rewritten as a standalone
               * function (not on Function.prototype). NOTE: If this file is to be loaded
               * during bootstrapping this function needs to be rewritten using some native
               * functions as prototype setup using normal JavaScript does not work as
               * expected during bootstrapping (see mirror.js in r114903).
               *
               * @param {function} ctor Constructor function which needs to inherit the
               *     prototype.
               * @param {function} superCtor Constructor function to inherit prototype from.
               */ exports.inherits = require("inherits");
              exports._extend = function (origin, add) {
                // Don't do anything if add isn't an object
                if (!add || !isObject(add)) return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
              var kCustomPromisifiedSymbol =
                typeof Symbol !== "undefined"
                  ? Symbol("util.promisify.custom")
                  : undefined;
              exports.promisify = function promisify(original) {
                if (typeof original !== "function")
                  throw new TypeError(
                    'The "original" argument must be of type Function'
                  );
                if (
                  kCustomPromisifiedSymbol &&
                  original[kCustomPromisifiedSymbol]
                ) {
                  var fn = original[kCustomPromisifiedSymbol];
                  if (typeof fn !== "function") {
                    throw new TypeError(
                      'The "util.promisify.custom" argument must be of type Function'
                    );
                  }
                  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                  });
                  return fn;
                }
                function fn() {
                  var promiseResolve, promiseReject;
                  var promise = new Promise(function (resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                  });
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  args.push(function (err, value) {
                    if (err) {
                      promiseReject(err);
                    } else {
                      promiseResolve(value);
                    }
                  });
                  try {
                    original.apply(this, args);
                  } catch (err) {
                    promiseReject(err);
                  }
                  return promise;
                }
                Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                if (kCustomPromisifiedSymbol)
                  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                  });
                return Object.defineProperties(
                  fn,
                  getOwnPropertyDescriptors(original)
                );
              };
              exports.promisify.custom = kCustomPromisifiedSymbol;
              function callbackifyOnRejected(reason, cb) {
                // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                // Because `null` is a special error value in callbacks which means "no error
                // occurred", we error-wrap so the callback consumer can distinguish between
                // "the promise rejected with null" or "the promise fulfilled with undefined".
                if (!reason) {
                  var newReason = new Error(
                    "Promise was rejected with a falsy value"
                  );
                  newReason.reason = reason;
                  reason = newReason;
                }
                return cb(reason);
              }
              function callbackify(original) {
                if (typeof original !== "function") {
                  throw new TypeError(
                    'The "original" argument must be of type Function'
                  );
                } // We DO NOT return the promise as it gives the user a false sense that
                // the promise is actually somehow related to the callback's execution
                // and that the callback throwing will reject the promise.
                function callbackified() {
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  var maybeCb = args.pop();
                  if (typeof maybeCb !== "function") {
                    throw new TypeError(
                      "The last argument must be of type Function"
                    );
                  }
                  var self = this;
                  var cb = function cb() {
                    return maybeCb.apply(self, arguments);
                  }; // In true node style we process the callback on `nextTick` with all the
                  // implications (stack, `uncaughtException`, `async_hooks`)
                  original.apply(this, args).then(
                    function (ret) {
                      process.nextTick(cb.bind(null, null, ret));
                    },
                    function (rej) {
                      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                    }
                  );
                }
                Object.setPrototypeOf(
                  callbackified,
                  Object.getPrototypeOf(original)
                );
                Object.defineProperties(
                  callbackified,
                  getOwnPropertyDescriptors(original)
                );
                return callbackified;
              }
              exports.callbackify = callbackify;
            }.call(this));
          }.call(this, require("_process")));
        },
        {
          "./support/isBuffer": 275,
          "./support/types": 276,
          _process: 246,
          inherits: 239
        }
      ],
      278: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              "use strict";
              var forEach = require("for-each");
              var availableTypedArrays = require("available-typed-arrays");
              var callBound = require("call-bind/callBound");
              var $toString = callBound("Object.prototype.toString");
              var hasToStringTag = require("has-tostringtag/shams")();
              var g = typeof globalThis === "undefined" ? global : globalThis;
              var typedArrays = availableTypedArrays();
              var $slice = callBound("String.prototype.slice");
              var toStrTags = {};
              var gOPD = require("es-abstract/helpers/getOwnPropertyDescriptor");
              var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
              if (hasToStringTag && gOPD && getPrototypeOf) {
                forEach(typedArrays, function (typedArray) {
                  if (typeof g[typedArray] === "function") {
                    var arr = new g[typedArray]();
                    if (Symbol.toStringTag in arr) {
                      var proto = getPrototypeOf(arr);
                      var descriptor = gOPD(proto, Symbol.toStringTag);
                      if (!descriptor) {
                        var superProto = getPrototypeOf(proto);
                        descriptor = gOPD(superProto, Symbol.toStringTag);
                      }
                      toStrTags[typedArray] = descriptor.get;
                    }
                  }
                });
              }
              var tryTypedArrays = function tryAllTypedArrays(value) {
                var foundName = false;
                forEach(toStrTags, function (getter, typedArray) {
                  if (!foundName) {
                    try {
                      var name = getter.call(value);
                      if (name === typedArray) {
                        foundName = name;
                      }
                    } catch (e) {}
                  }
                });
                return foundName;
              };
              var isTypedArray = require("is-typed-array");
              module.exports = function whichTypedArray(value) {
                if (!isTypedArray(value)) {
                  return false;
                }
                if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                  return $slice($toString(value), 8, -1);
                }
                return tryTypedArrays(value);
              };
            }.call(this));
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          "available-typed-arrays": 220,
          "call-bind/callBound": 225,
          "es-abstract/helpers/getOwnPropertyDescriptor": 227,
          "for-each": 229,
          "has-tostringtag/shams": 235,
          "is-typed-array": 244
        }
      ],
      279: [
        function (require, module, exports) {
          module.exports = extend;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function extend() {
            var target = {};
            for (var i = 0; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          }
        },
        {}
      ]
    },
    {},
    [47]
  );
  